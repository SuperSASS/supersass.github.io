
<!DOCTYPE html>
<html lang="zh-CN">



<head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='贪心算法中邻项比较排序的详细讲解……'><title>邻项比较排序……</title>

<link rel='canonical' href='https://supersass.github.io/p/neighbor-sort/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='邻项比较排序……'>
<meta property='og:description' content='贪心算法中邻项比较排序的详细讲解……'>
<meta property='og:url' content='https://supersass.github.io/p/neighbor-sort/'>
<meta property='og:site_name' content='Super SASS……'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='基础部分' /><meta property='article:tag' content='贪心' /><meta property='article:tag' content='邻项比较排序' /><meta property='article:published_time' content='2020-12-15T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2020-12-18T19:29:00&#43;00:00'/><meta property='og:image' content='https://supersass.github.io/p/neighbor-sort/71111285_p0.png' />
<meta name="twitter:site" content="SuperSASS_"><meta name="twitter:title" content="邻项比较排序……">
<meta name="twitter:description" content="贪心算法中邻项比较排序的详细讲解……"><meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:image" content='https://supersass.github.io/p/neighbor-sort/71111285_p0.png' />
<link rel="shortcut icon" href="https://supersass.github.io/img/favicon.ico">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" />


<link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
</head>



<body class="" data-scheme="">
    
    
    
<div class="background" id="background">
	<script>
		let backgroundElem = document.getElementById("background"),
			backgroundList = [{"illustrator":"のう","local":true,"pixivID":84038692,"src":"img/background_01.jpg"},{"illustrator":"のう","local":true,"pixivID":84150375,"src":"img/background_02.jpg"},{"illustrator":"のう","local":true,"pixivID":83166664,"src":"img/background_03.jpg"}];
		_length = backgroundList.length;

		
		let rand = Math.floor(Math.random() * _length);
		while (backgroundList[rand].appear == false) rand = Math.floor(Math.random() * _length);
		let background = backgroundList[rand];

		if (sessionStorage.getItem("background"))	
			backgroundElem.style.backgroundImage = sessionStorage.getItem("background");	
		else {
			let url;
			if (background.local)
				url = "url(/" + background.src + ")";	
			else
				url = "url(/" + background.src + ")";
			backgroundElem.style.backgroundImage = url;
			sessionStorage.setItem("background", url);
		}

	</script>
</div>


    <div class="container flex on-phone--column align-items--flex-start extended article-page with-toolbar">

        
        <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hub0ab58ae8b72553f595d525edd405dd1_160792_300x0_resize_q75_box.jpg" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
                    <span class="emoji">🐺</span>
                
            </figure>
        
        <h1 class="site-name"><a href="https://supersass.github.io/">Super SASS……</a></h1>
        <h2 class="site-description">万华散尽……</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        

        
        <li id="dark-mode-toggle">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>
            <span>夜间模式</span>
        </li>
    </ol>
</aside>


        
        <main class="main full-width">
            

    <div id="article-toolbar">
        <a href="https://supersass.github.io/" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>上一个页面</span>
        </a>
    </div>

    

<article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <img srcset="/p/neighbor-sort/71111285_p0_hud2648e021785c2a9f9434e425c67999f_2056049_1024x0_resize_box_2.png 1024w, /p/neighbor-sort/71111285_p0_hud2648e021785c2a9f9434e425c67999f_2056049_2000x0_resize_box_2.png 2000w"
                    src="/p/neighbor-sort/71111285_p0_hud2648e021785c2a9f9434e425c67999f_2056049_2000x0_resize_box_2.png" width="1500" height="1142" loading="lazy"
                    alt="Featured image of post 邻项比较排序……" />
            
        </div>
    

    
    

    <div class="article-details">
    
    <header class="article-category">
        
        <a href="/categories/basic/" class="color-tag" data-image="/p/neighbor-sort/71111285_p0_hud2648e021785c2a9f9434e425c67999f_2056049_20x20_fill_box_smart1_2.png"
            data-key="neighbor-sort" data-hash="md5-r334/EVJGtAzPFGKrF0AwQ==">
            基础部分
        </a>
        
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/neighbor-sort/">邻项比较排序……</a>
    </h2>

    
    <h3 class="article-subtitle">
        贪心算法中邻项比较排序的详细讲解……
    </h3>
    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">2020/12/15</time>
    </footer>
    <footer class="article-readingTime-container">
        <div class="article-readingTime-left">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-file-invoice" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M14 3v4a1 1 0 0 0 1 1h4" />
  <path d="M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z" />
  <line x1="9" y1="7" x2="10" y2="7" />
  <line x1="9" y1="13" x2="15" y2="13" />
  <line x1="13" y1="17" x2="15" y2="17" />
</svg>
        </div>
        <div class="article-readingTime-right">
            <div class="char">文章字数：10141</div>
            <div class="time">预计阅读时长： <time>21</time> 分钟</div>
        </div>
    </footer>
</div>

</header>

    <section class="article-content">
    <h1 id="邻项比较排序">邻项比较排序</h1>
<h2 id="定义">定义</h2>
<p>本来的排序型贪心，我们需要<strong>任意两个项都满足决策条件</strong>。<br>
但我们发现，如果数列每对<strong>相邻两项都满足决策条件</strong>，根据<strong>不等式的传递性</strong>，那么也就可以推出任意两项满足决策条件。</p>
<p>于是我们分析决策条件时，就不用分析任意两项，可以就分析邻项然后推出决策条件。</p>
<p>【主要用于如果决策条件复合了其他数据（比如：结果计算为$\sum_{i=1}^na_i$，复合之前的数列），这样分析可以减少分析难度】</p>
<ul>
<li>
<p>典型例题：<br>
P1080 <a class="link" href="https://www.luogu.com.cn/problem/P1080"  target="_blank" rel="noopener"
    >国王游戏</a></p>
<blockquote>
<p>可以见到这题便有一个「排在<strong>该大臣前面的</strong>所有人的左手上的数的乘积」这句话，<br>
如果我们分析任意两项的话，还要考虑两者中间的数据。</p>
<p>所以我们可以指通过分析相邻两项，然后通过传递性，推及任意两项都满足。</p>
</blockquote>
<p>【其实用任意两项分析也完全可以，而且分析也不难_(:з」∠)_……</p>
</li>
</ul>
<p>那么实现的关键就是<strong>找到最终的决策方案</strong>（序列满足的条件），然后根据这个决策<code>sort</code>就行了_(:з」∠)_……<br>
【但是会有注意点后面会讲到……</p>
<h2 id="题目解决方法">题目解决方法</h2>
<h3 id="引例">引例</h3>
<blockquote>
<p>以下以此例题为例具体讲解：<br>
SWJTU OJ——10.31 A <a class="link" href="https://oj.swjtu.edu.cn/contest/23/problem/A"  target="_blank" rel="noopener"
    >排队</a></p>
</blockquote>
<p>题目与国王游戏类似，用邻项交换排序的思想来找<strong>决策条件</strong>。</p>
<h3 id="1找出每种状态的ans选邻项代入">1、找出每种状态的<code>ans</code>，选邻项代入</h3>
<blockquote>
<p>题目描述：<br>
也就是说，请重新给班尼特排队，要求是最大化$\min_{i=1}^n{-h_i+\sum_{j=1}^i v_j}$。</p>
</blockquote>
<p>那么每种状态的<code>ans</code>$=\min_{i=1}^nw_i$。</p>
<p>既然要求$\min_{i=1}^n{w_i}$，所以我们就比较邻项的$w_i,w_j$，比较其两项的$\min(w_i,w_j)$，选择最大<code>ans</code>的状态。</p>
<ul>
<li>为什么我们这样排序，能使<code>ans</code>$=\min_{i=1}^nw_i$取得最小？
<blockquote>
<p>就相当于把比较时候的最小值看成短板，每次比较一次选最高的那个，就会把短板提上去一点，这样最后得到的就是最高的短板，也就是最大的$\min$……</p>
</blockquote>
</li>
</ul>
<h3 id="2假设相邻位置写出两种状态的ans">2、假设相邻位置，写出两种状态的<code>ans</code></h3>
<p>我们首先要把每个位置的<strong>收益表达式</strong>写出来：</p>
<blockquote>
<p>题目描述：治疗第$i$个班尼特的收益$w_i$等于前面治疗的所有班尼特的$v$之和减去$h_i$。
$$
w_i=\sum_{j=1}^iv_j-h_i
$$</p>
</blockquote>
<p>那么我们<strong>假设两个相邻位置</strong>$i,j$。其中$i$在$j$前，即$i=j-1$。【必须先假设一个在另一个前后，否则不可能$i$在$j$前满足，$j$在$i$前也满足】<br>
记：两者之前的$\sum v$为$sum$。【将一些求$w$要用到的比如$\sum$记为其他符号表示，可以简化式子】</p>
<p>然后分别讨论$i$在$j$前和$j$在$i$前的情况：</p>
<ol>
<li>
<p>原本状态：$i$在$j$前</p>
<blockquote>
<p>$$
\begin{matrix}
h &amp; v \<br>
\vdots &amp; \vdots(sum) \<br>
h_i &amp; v_i \<br>
h_j &amp; v_j \<br>
\vdots &amp; \vdots \<br>
\end{matrix}
$$</p>
</blockquote>
<p>对$i$的收益：$w_{i1}=sum+v_i-h_i$<br>
对$j$的收益：$w_{j1}=sum+v_i+v_j-h_j$<br>
此状态的<code>ans</code>=$\min(w_{i1},w_{j1})$</p>
</li>
<li>
<p>如果交换：$j$在$i$前</p>
<blockquote>
<p>$
\begin{matrix}
h &amp; v \<br>
\vdots &amp; \vdots(sum) \<br>
h_j &amp; v_j \<br>
h_i &amp; v_i \<br>
\vdots &amp; \vdots \<br>
\end{matrix}
$</p>
</blockquote>
<p>对$i$的收益：$w_{i2}=sum+v_j+v_i-h_i$，<br>
对$j$的收益：$w_{j2}=sum+v_j-h_j$<br>
此状态的<code>ans</code>=$\min(w_{i2},w_{j2})$</p>
</li>
</ol>
<h3 id="3根据题意写出排序条件并化简得到最终决策方案">3、根据题意写出排序条件并化简，得到最终决策方案</h3>
<blockquote>
<p>题目描述：芭芭拉想让治疗每个班尼特收益的最小值最大。</p>
</blockquote>
<p>题意要求使<strong>最小收益最大化</strong>，<br>
则<strong>最初排序条件</strong>为：$\min(w_{i1},w_{j1})\ge\min(w_{j2},w_{i2})$<br>
【或者说**交换条件**为：$\text{if} \quad (\min(w_{i1},w_{j1})&lt;\min(w_{j2},w_{i2})) \quad \text{swap}(i,j)$】</p>
<blockquote>
<p>*其他例子：国王游戏中，是使<strong>最大收益最小化</strong>。则排序条件为：$\max(w_{i1},w_{j1})\le\max(w_{i2},w_{j2})$*</p>
</blockquote>
<p>然后对这个决策条件<strong>化简</strong>，使得能直接表达出来。<br>
【所谓不能直接表达的，便是条件中含有如$\sum$之类的运算。而我们不可能用循环专门去求，只能通过化简把他消掉】</p>
<blockquote>
<p>化简方法：</p>
<p>下列所提到的化简方法参考<a class="link" href="../../../Part%209%20Others/%e5%90%abmax%e3%80%81min%e7%9a%84%e4%b8%8d%e7%ad%89%e5%bc%8f.md" >含max、min的不等式</a>。</p>
<ol>
<li>
<p>利用“<strong>完全展开法则</strong>”，观察是否含有<strong>恒成立或恒不成立</strong>。<br>
【或者直接观察题目中$w_{i1},w_{j1},w_{j2},w_{i2}$间的关系，找出恒成立或恒不成立，然后利用“**消元法则**”】</p>
</li>
<li>
<p>利用排序规则下特殊的“<strong>相同无关原则</strong>”，结合“<strong>取反性</strong>、<strong>结合性</strong>”等性质，化简并得到最终的最简决策</p>
</li>
</ol>
</blockquote>
<p>则本题中：<br>
展开为$\text{if} \quad ((w_{i1}&lt;w_{i2} &amp; w_{i1}&lt;w_{j2}) | (w_{j1}&lt;w_{i2} &amp; w_{j1}&lt;w_{j2})) \quad \text{swap}$。</p>
<ul>
<li>发现$w_{i1}&lt;w_{i2}$恒成立：
<blockquote>
<p>$\sout{sum+v_i-h_i} \quad?\quad \sout{sum}+v_j\sout{+v_i-h_i}$<br>
$\implies 0&lt;v_j$</p>
</blockquote>
</li>
<li>发现$w_{j1}&lt;w_{j2}$恒不成立：
<blockquote>
<p>$\sout{sum}+v_i\sout{+v_j-h_j} \quad?\quad \sout{sum+v_j-h_j}$<br>
$\implies v_i&gt;0$</p>
</blockquote>
</li>
</ul>
<p>故原式可简化为：<br>
$\text{if} \quad (w_{i1}&lt;w_{j2}) \quad \text{swap}$<br>
$\implies \text{if} \quad (v_i-h_i &lt; v_j-h_j) \quad \text{swap}$<br>
这便是化简后的**决策条件**。</p>
<hr>


<div class="snote info ">
	<div class="snote-content">
		<p><p>注意的点：</p>
<p>不一定要化到最简，只要能在代码里直接表达就行。</p>
<blockquote>
<p>本题中原始条件经过部分化简：<br>
<img src="./pic/raw_case.png" alt="raw_case"><br>
运行结果：<br>
<img src="./pic/raw_result.png" alt="raw_result"></p>
<p>而完全化简后为：<br>
<img src="./pic/process_case.png" alt="process_case"><br>
运行结果：<br>
<img src="./pic/process_result.png" alt="process_result"></p>
<p>可见差异并不大，所以说只要能化简到能表达的地步就可以。<br>
当然如果能化到最简更好，肯定还是比带<code>min</code>的条件快的。</p>
</blockquote>
</p>
	</div>
</div>
<h3 id="4自定义结构体重载运算符使用sort遍历寻答案">4、自定义结构体，重载<code>&lt;</code>运算符，使用<code>sort</code>，遍历寻答案</h3>
<p>这一步就不多说了，重载的时候按自己分析到的最终最简决策重载就行。</p>


<div class="snote warning ">
	<div class="snote-content">
		<p><p><strong>但重点是</strong>：</p>
<p>这样排序出来后<strong>只是最优状态</strong>，<br>
至于<strong>最终答案<code>ans</code>要从头到尾遍历寻找</strong>，即不一定是第一个为最终答案。<br>
可能后面计算结果不是递增或递减，则最终答案不是第一个。【具体题目具体分析】</p>
</p>
	</div>
</div>
<hr>
<h2 id="标程代码">标程代码</h2>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100010</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Data</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Data</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span> <span class="o">-</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">.</span><span class="n">v</span> <span class="o">-</span> <span class="n">t</span><span class="p">.</span><span class="n">h</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//以推出的最终最简决策重载&lt;运算符
</span><span class="c1"></span><span class="p">}</span> <span class="n">d</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>

	<span class="n">sort</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//就一个sort
</span><span class="c1"></span>
	<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mf">1e9</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">tmp</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">h</span><span class="p">);</span> <span class="c1">//从头到尾遍历，res记录最终答案
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h1 id="使用注意事项">使用注意事项</h1>
<p>注意之前我们定义中存在一个推论：</p>
<blockquote>
<p>如果数列每对相邻两项都满足决策条件，<strong>根据不等式的传递性</strong>，那么也就可以推出任意两项满足决策条件。</p>
</blockquote>
<p>所以假如我们所推的某个决策条件，<strong>不满足不等式的传递性</strong>，那么用这个方法就<strong>会造成错误</strong>。</p>
<p>而这种必须要满足不等性的传递性，有个专门术语叫做“<strong>严格弱序</strong>”。</p>
<h2 id="先前知识严格弱序">先前知识——严格弱序</h2>
<blockquote>
<ul>
<li>$X \not&lt; X$（比较条件非自反性）<br>
意思是：$X$与$X$本身，不满足比较条件。
<ul>
<li>反例：比较条件是$a_i \ge a_j$。<br>
那么$X(a_i) \ge X(a_i)$满足比较条件，为$X &lt; X$，故不是严格弱序。</li>
</ul>
</li>
<li>若$X &lt; Y$，则$Y \not&lt; X$（比较条件非对称性）<br>
意思是：$X$和$Y$比较若满足比较条件，则$Y$和$X$比较不会满足条件。
<ul>
<li>反例：比较条件是$a_i \ge a_j$。<br>
那么若$a_i=a_j$，$X(a_i) \ge Y(a_j)$满足条件，<br>
但$Y(a_j) \ge X(a_i)$也满足条件，故不是严格弱序。</li>
</ul>
</li>
<li>若$X &lt; Y,Y &lt; Z$，则$X &lt; Z$（比较条件不等<strong>传递性</strong>）<br>
意思是：$X$和$Y$满足比较条件，$Y$和$Z$满足比较条件，则$X$和$Y$满足比较条件。
<ul>
<li>
<p>反例：比较条件是$\min(a_i,b_j) \le \min(a_j,b_i)$。<br>
那么对于下组数据：</p>
<table>
<thead>
<tr>
<th></th>
<th>$a$</th>
<th>$b$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$i$</td>
<td>$2$</td>
<td>$1$</td>
</tr>
<tr>
<td>$j$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$k$</td>
<td>$1$</td>
<td>$2$</td>
</tr>
</tbody>
</table>
<p>$X(\min(a_i,b_j)=1)&lt;Y(\min(a_j,b_i)=1)$<br>
$Y(\min(a_j,b_k)=1)&lt;Z(\min(a_k,b_j)=1)$<br>
但$X(\min(a_i,b_k)=2) \not&lt; Z(\min(a_k,b_i)=1)$，故不是严格弱序。
【再次提示这里的$&lt;$并不代表小于，而是代表符合比较条件的意思。】</p>
</li>
</ul>
</li>
<li>若$X=Y,Y=Z$，则$X=Z$（比较条件相等<strong>传递性</strong>）<br>
意思同上。<br>
<em>在“ouuan”dalao的讲解种写的是$x\not&lt;y,y\not&lt;x,y\not&lt;z,z\not&lt;y$（不可比性的传递性）。我改成这样更好理解。</em><br>
<em>不过注意判断相等的方法是$x\not&lt;y,y\not&lt;x$这么判断的。</em>
<ul>
<li>反例见下引例的「错误分析」</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>这里的$X$、$Y$、$Z$代表的是取某下标$i$、$j$后的<strong>决策条件的一侧元素</strong>。并不一定是某一具体数据。</li>
<li>这里的$&lt;$并不代表小于的意思，而是代表<strong>满足比较条件</strong>，那么$\not&lt;$则代表不满足比较条件。</li>
</ul>
<h2 id="引例-1">引例</h2>
<blockquote>
<p>P2123 <a class="link" href="https://www.luogu.com.cn/problem/P2123"  target="_blank" rel="noopener"
    >皇后游戏</a></p>
</blockquote>
<h3 id="按照之前的方法尝试解决">按照之前的方法尝试解决</h3>
<ol>
<li>
<p>找出每种状态的<code>ans</code>，选邻项代入</p>
<blockquote>
<p>题目描述：<br>
她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。</p>
</blockquote>
<p>可知每种状态的<code>ans</code>$=\max_{i=1}^nw_i$。</p>
<p>那么比较邻项$i,j$，就是$max(w_i,w_j)$。</p>
</li>
<li>
<p>假设相邻位置，写出两种状态的ans</p>
<p>首先先写收益表达式：<br>
$$
w_i=\max(w_{i-1},\sum_{j=1}^ia_j)+b_i
$$
【第一位的收益可以合并到这个表达式里，令$w_0=0$就可以了。】</p>
<p>假设相邻位置$i,j$。其中$i$在$j$前，即$i=j-1$。<br>
记：之前的$\sum a$为$sum$，前一项的$c_{i-1}$为$pre_w$。</p>
<p>会发现，由于$a,b&gt;0$，整个收益表达式中又没出现会使收益变少的运算，故<strong>收益单增</strong>。<br>
即在<strong>后面的</strong>大臣的收益<strong>一定大于</strong>在<strong>前面的</strong>。<br>
$i$在$j$前时，则$w_j$一定大于$w_i$，所以$\max(w_i,w_j)=w_j$，可以拆开一层$\max$。</p>
<ol>
<li>
<p>原本状态：$i$在$j$前</p>
<blockquote>
<p>$
\begin{matrix}
a &amp; b &amp; c \<br>
\vdots(sum) &amp; \vdots &amp; \vdots(pre_w) \<br>
a_i &amp; b_i &amp; w_{i1} \<br>
a_j &amp; b_j &amp; w_{j1} \<br>
\vdots &amp; \vdots &amp; \vdots \<br>
\end{matrix}
$</p>
</blockquote>
<p>$w_{i1}=\max(pre_w,sum+a_i)+b_i$<br>
$w_{j1}=\max(w_{i1},sum+a_i+a_j)+b_j$<br>
此状态的<code>ans</code>=$\max(w_{i1},w_{j1})=w_{j1}$</p>
</li>
<li>
<p>如果交换：$j$在$i$前</p>
<blockquote>
<p>$
\begin{matrix}
a &amp; b &amp; c \<br>
\vdots(sum) &amp; \vdots &amp; \vdots(pre_w) \<br>
a_j &amp; b_j &amp; w_{j2} \<br>
a_i &amp; b_i &amp; w_{i2} \<br>
\vdots &amp; \vdots &amp; \vdots \<br>
\end{matrix}
$</p>
</blockquote>
<p>$w_{i2}=\max(w_{j2},sum+a_j+a_i)+b_i$<br>
$w_{j2}=\max(pre_w,sum+a_j)+b_j$<br>
此状态的<code>ans</code>=$\max(w_{i2},w_{j2})=w_{i2}$</p>
</li>
</ol>
</li>
<li>
<p>根据题意写出排序条件并化简，得到最终决策方案</p>
<p>题意要求使<strong>最大收益最小化</strong>，<br>
则<strong>排序条件</strong>：$\max(w_{i1},w_{j1}) \le \max(w_{i2},w_{j2})$</p>
<p>开始化简：<br>
$\max(w_{i1},w_{j1}) \le \max(w_{i2},w_{j2})$<br>
$\implies w_{j1} \le w_{j2}$<br>
$\implies \max(\sout{pre_w+b_i+b_j},\underline{sum+a_i}+b_i+\underline{b_j},\underline{sum+a_i}+a_j+\underline{b_j}) \le \max(\sout{pre_w+b_j+b_i},\underline{sum+a_j}+b_j+\underline{b_i},\underline{sum+a_j}+a_i+\underline{b_i})$<br>
【删除线的部分代表根据相同无关原则可以消去；下划线的部分代表根据结合性可以提出来】<br>
$\implies \max(b_i,a_j)+sum+a_i+b_j \le \max(b_j,a+i)+sum+a_j+b_i$<br>
$\implies \max(b_i,a_j)-a_j-b_i \le \max(b_j,a_i)-a_i-b_j$<br>
$\implies \max(-a_j,-b_i) \le \max(-a_i,-b_j)$<br>
$\implies -\min(a_j,b_i) \le -\min(a_i,b_j)$<br>
$\implies \min(a_j,b_i) &gt; \min(a_i,b_j)$</p>
<p>最终的<strong>决策条件</strong>：$\min(a_j,b_i) &gt; \min(a_i,b_j)$</p>
</li>
<li>
<p>那就开写呗……</p>
</li>
</ol>
<p>然后交上去会WA，80分。<br>
证明我们这种方法<strong>有思路缺陷</strong>。</p>
<h3 id="错误分析">错误分析</h3>
<p>这里便不满足严格弱序的<strong>相等传递性</strong>这个性质。</p>
<blockquote>
<p>当取$i,j$时，若$\min(a_i,b_j)=\min(a_j,b_i)$，<br>
当取$j,k$时，若$\min(a_j,b_k)=\min(a_k,b_j)$，<br>
则需要满足：取$i,k$时，$\min(a_i,b_k)=\min(a_k,b_i)$</p>
</blockquote>
<p>反例：</p>
<table>
<thead>
<tr>
<th></th>
<th>$a$</th>
<th>$b$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$i$</td>
<td>$3$</td>
<td>$5$</td>
</tr>
<tr>
<td>$j$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$k$</td>
<td>$7$</td>
<td>$2$</td>
</tr>
</tbody>
</table>
<p>虽然$\min(a_i,b_j)=\min(a_j,b_i)$和$\min(a_j,b_k)=\min(a_k,b_j)$都满足，<br>
但却不满足$\min(a_i,b_k)=\min(a_k,b_i)$。<br>
【只需要让$a_j,b_j$相等，就可以构建众多反例。】</p>
<h4 id="错误根本原因新内容">错误根本原因（新内容！）</h4>
<ul>
<li><strong>为什么不满足严格弱序中传递性就会造成错误</strong>：
<blockquote>
<p>因为<code>sort</code>实现时，采用了<strong>分治</strong>的思想。<br>
会将数据分为两个部分，对两个部分进行排序，然后使数列直接有序。<br>
但问题就刚好出在这个“直接有序”上。</p>
<p>之所以在左右都有序后，会认为整个数列直接有序，<br>
就是因为利用了<strong>严格弱序中的传递性</strong>：<br>
认为$X &lt; Y,Y &lt; Z$，则$X &lt; Z$，<br>
以及$X = Y,Y = Z$，则$X = Z$。</p>
<p>但假如不满足的第一条的话，分治处理过后：<br>
左侧的数是小于中间的，中间的数也是小于右边的，但左侧的是却不一定小于右边的了。<br>
会造成很严重的合并后错误。</p>
<p>但假如不满足的第二条的话，分治处理过后：<br>
如果<strong>都是小于条件</strong>，根据第一条可推合并后也有序，<strong>没有问题</strong>。
<div class="snote info ">
	<div class="snote-content">
		<p> 这也就是为什么我们这个方法还能得部分分的原因——决策判断时没判断出相等。 </p>
	</div>
</div></p>
<p>但一旦<strong>出现等于条件</strong>的情况，则不<strong>能推得左边的也等于右边的</strong>，<br>
同时$X=Y, Y&lt;Z \implies X&lt;Z$、$X&lt;Y, Y=Z \implies X&lt;Z$也无法推得。</p>
<blockquote>
<p>举例：判断条件为$\min(a_i,b_j) &lt; \min(a_j,b_i)$【就本题我们推的条件……
对以下两组数据：</p>
<table>
<thead>
<tr>
<th></th>
<th>$a$</th>
<th>$b$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$i$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
<tr>
<td>$j$</td>
<td>$1$</td>
<td>$2$</td>
</tr>
<tr>
<td>$k$</td>
<td>$2$</td>
<td>$2$</td>
</tr>
</tbody>
</table>
<p>其中$X(i,j)=Y(j,i),Y(j,k)&lt;Z(k,j)$，但$X(i,k) \not&lt; Z(k,i)$，为$X=Z$。</p>
<table>
<thead>
<tr>
<th></th>
<th>$a$</th>
<th>$b$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$i$</td>
<td>$1$</td>
<td>$2$</td>
</tr>
<tr>
<td>$j$</td>
<td>$2$</td>
<td>$1$</td>
</tr>
<tr>
<td>$k$</td>
<td>$1$</td>
<td>$1$</td>
</tr>
</tbody>
</table>
<p>其中$X(i,j)&lt;Y(j,i),Y(j,k)=Z(k,j)$，但$X(i,k) \not&lt; Z(k,i)$，为$X=Z$。</p>
</blockquote>
<p>那么<strong>不满足传递性</strong>，就会导致<strong>虽然序列大部分满足决策条件</strong>，但<strong>并不是任意两项都满足条件的</strong>。<br>
而回到我们贪心的基本要求：需要<strong>任意两个元素都满足决策条件</strong>。<br>
故会造成错误。</p>
</blockquote>
</li>
</ul>
<h3 id="改进方法">改进方法</h3>
<p>其实上述主要问题都归结于我们<strong>对相等状况的定义模棱两可</strong>。</p>
<ul>
<li>对于满足严格弱序中的传递性的数据来说：<br>
出现相等状况，<strong>交换或者不交换都无所谓</strong>，因为可以通过传递性证得交换后对数列无影响。<br>
所以可以保持这种模棱两可的定义。
<blockquote>
<p>也就是说这种数据，我们即使将判断中的不取等判断<strong>改为取等的判断</strong>，也依旧<strong>不会有影响</strong>。只不过会多交换几次，让<strong>状态变得不同</strong>，但最终结果一致。</p>
</blockquote>
</li>
<li>对于不满足严格弱序中的传递性的数据来说：<br>
我们就必须对相等状况作出严格的操作规定了，否则<strong>两种不同的状态</strong>会导致数据<strong>最终结果的不一致</strong>。<br>
也就是说我们要对<strong>相等状况</strong>进行<strong>特判</strong>。</li>
</ul>
<p>那么我们就来考虑在$\max(w_{i1},w_{j1}) = \max(w_{i2},w_{j2})$的相等条件下，又该加什么判断。<br>
也就是说，除了这个很显然的条件在影响<code>ans</code>外，还有没有什么可能影响<code>ans</code>。</p>
<p>根据个人看法不同，会有很多种可能的条件，以下列举两种正确的：</p>
<ol>
<li>
<p>会发现：$a$的前缀和会影响$\max(c_{i-1},\sum_{j=1}^ia_j)$这个的选择，从而影响$w_i$，从而影响<code>ans</code>。<br>
因为要找最小的<code>ans</code>，所以我们**把$a$更小的放在前面**，这样就能让更加保证所得状态是最优的了。</p>
</li>
<li>
<p>会发现：两种状态的前后两项$w$，后者是一样的【我们比较条件就是用的两状态的后者】，因此我们要让前者尽量小，从而确保<code>ans</code>更小。<br>
所以我们<strong>把$b$更小的放在前面</strong>。</p>
</li>
</ol>
<ul>
<li>那么假如这两个条件判断出来也是相等的，需不需要再特判呢？
<blockquote>
<p>假如$\min(a_j,b_i) = \min(a_i,b_j)$和$a_i = a_j$（或者$b_i = b_j$）同时满足，<br>
则可以推出$a_i=a_j,b_i=b_j$，也就是这两项的数据完全一致，并不是比较用数据一致，因此我们这里也可以即交换又不交换，保持模棱两可定义。</p>
</blockquote>
</li>
</ul>
<h3 id="很特殊的hack数据">很特殊的hack数据</h3>
<p>在这里，我们会惊讶地发现，如果<strong>用选择排序的话</strong>，虽然是会<code>TLE</code>，但其<strong>结果是正确的</strong>。<br>
【相关原因请查看后面的「有关排序的深层理解」部分】</p>
<p>个人发现了选择排序答案是正确的后，对各种排序的实现展开了思考和实验。</p>
<p>认为像快速排序或归并排序等，是因为采用典型的分治思想才导致需要满足严格弱序的。<br>
那么对于其他排序方法比如“希尔排序”、“堆排序”、“锦标赛排序”等是否不需要满足严格弱序呢？<br>
【这里没考虑“计数排序”、“基数排序”和“桶排序”这三种非比较式排序算法。因为这里没有关键字，无法使用这三种排序方法。</p>
<p>所以在实验的时候就弄出了一些其他的hack数据，<br>
然后其中发现了一组很特殊的hack数据！<em>(:з」∠)</em>……</p>
<hr>
<p>数据：</p>
<blockquote>
<p>1<br>
5</p>
<p>9 7<br>
1 1<br>
4 5<br>
1 2<br>
6 5</p>
</blockquote>
<p>*以下表格中的option表示$\max(c_{i-1},\sum_{j=1}^ia_j)$选择的哪个*。</p>
<ul>
<li>
<p>标准答案：<code>27</code></p>
</li>
<li>
<p>利用选择排序后的结果</p>
<table>
<thead>
<tr>
<th></th>
<th>$a$</th>
<th>$b$</th>
<th>$c$</th>
<th>option</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>$1$</td>
<td>$2$</td>
<td>$3$</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>$1$</td>
<td>$1$</td>
<td>$4$</td>
<td>$c$</td>
</tr>
<tr>
<td>3</td>
<td>$4$</td>
<td>$5$</td>
<td>$11$</td>
<td>$\sum a$</td>
</tr>
<tr>
<td>4</td>
<td>$9$</td>
<td>$7$</td>
<td>$22$</td>
<td>$\sum a$</td>
</tr>
<tr>
<td>5</td>
<td>$6$</td>
<td>$5$</td>
<td>$27$</td>
<td>$c$</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>特殊性<br>
我们如果排序成：</p>
<table>
<thead>
<tr>
<th></th>
<th>$a$</th>
<th>$b$</th>
<th>$c$</th>
<th>option</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>$4$</td>
<td>$5$</td>
<td>$9$</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>$1$</td>
<td>$2$</td>
<td>$11$</td>
<td>$c$</td>
</tr>
<tr>
<td>3</td>
<td>$9$</td>
<td>$7$</td>
<td>$21$</td>
<td>$\sum a$</td>
</tr>
<tr>
<td>4</td>
<td>$1$</td>
<td>$1$</td>
<td>$22$</td>
<td>$c$</td>
</tr>
<tr>
<td>5</td>
<td>$6$</td>
<td>$5$</td>
<td>$27$</td>
<td>$c$</td>
</tr>
</tbody>
</table>
<p>会发现$1$和$2$（$i=1,j=2$）这两组数据，<br>
<strong>其实是不满足$\min(a_i,b_j) &lt; \min(a_j,b_i)$这个条件的！</strong></p>
<p>故这也告诉了我们：最优解也<strong>可能存在有两项不满足决策条件</strong>的状态。<br>
【更准确叙述请查看后面的「有关贪心决策的满足度影响」部分】</p>
</li>
</ul>
<p><em>有关自己使用其他排序方法验证的代码，以及其他两组hack数据可见<a class="link" href="https://paste.ubuntu.com/p/KjHc2bMCj6/"  target="_blank" rel="noopener"
    >Pastebin</a>。</em></p>
<h2 id="决策条件是否正确的判断方法">决策条件是否正确的判断方法</h2>
<h3 id="1条件检查器">1、条件检查器</h3>
<p>基于以上分析，我们发现：<br>
如果按上述“基本决策寻找方法”得到的决策条件$P$是正确的，必须要满足基本的排序型贪心的条件：</p>
<blockquote>
<p>数列<strong>任意两项满足决策条件</strong>。</p>
</blockquote>
<p>如果决策条件$P$满足以下条件，则可证得排序后一定满足该基本条件：</p>
<ul>
<li>满足严格弱序中的<strong>两个传递性</strong>。</li>
</ul>
<p>根据以上一点，我们可以编写一个条件检查器。<br>
【这个条件检查器的方法是参考自<a class="link" href="%28https://ouuan.github.io/post/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/#%E4%BD%BF%E7%94%A8%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%29" >“ouuan”的博客</a>后了解的，个人在其基础之上有所修改并加入了注释……</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1">//构造第一组a,b数组数据：用来判断自反性
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c1">//不满足自反性。
</span><span class="c1"></span>                           <span class="c1">//分析知这条对于贪心思路并不是很重要，所以注释了。但如果用sort就很重要。
</span><span class="c1"></span>                <span class="c1">//printf(&#34;No irreflexivity: %d %d\n&#34;, a[0], b[0]);
</span><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1">//构造第二组a,b数组数据：用来判断非对称性
</span><span class="c1"></span>                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">cmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c1">//非对称性的判断
</span><span class="c1"></span>                        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;No asymmetric: %d %d %d %d&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                    <span class="cm">/* 这部分原本是判断 我们新的决策条件 与 最开始分析的决策条件 是否判断一致，但其实可以不用判断。
</span><span class="cm">                    //同理，在ouuan所写的判断器中：有一个关于「排序完成后任意交换相邻元素均不会使答案更优」这个的判断，但实际上如果满足了严格弱序一定也会满足这个条件，也不用判断。
</span><span class="cm">                    bool our_judge = cmp(0, 1),
</span><span class="cm">                         real_judge = min(a[0], b[1]) &lt; min(a[1], b[0]),
</span><span class="cm">                         if_equal = min(a[0], b[1]) == min(a[1], b[0]);
</span><span class="cm">                    //注意这里真实判断（以决策条件判断），如果为0：有可能真的不满足，但也有可能是相等情况；如果为1：那就一定是满足
</span><span class="cm">                    //所以我们要加个if_equal，如果是相同状况则不判断是否与真是判断相同
</span><span class="cm">                    if (!if_equal &amp;&amp; our_judge != real_judge) //与真正决策条件判断不同
</span><span class="cm">                        printf(&#34;Not correct(%s): %d %d %d %d\n&#34;, (our_judge == 1 ? &#34;We judge it&#39;s right, but truth is wrong.&#34; : &#34;We judge it&#39;s wrong, but truth is right&#34;), a[0], b[0], a[1], b[1]);
</span><span class="cm">                    */</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="c1">//构造第三组a,b数据：用来判断传递性
</span><span class="c1"></span>                        <span class="k">for</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                        <span class="p">{</span>
                            <span class="kt">bool</span> <span class="n">flag_inequ</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                 <span class="n">flag_equ</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                            <span class="kt">bool</span> <span class="n">cmp_01</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                 <span class="n">cmp_12</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                                 <span class="n">cmp_02</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
                            <span class="c1">//注意我们判断两状态是否是用的!cmp(i,j) &amp;&amp; !cmp(j,i)（非对称性的利用）
</span><span class="c1"></span>                            <span class="kt">bool</span> <span class="n">euqal_01</span> <span class="o">=</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                 <span class="n">euqal_12</span> <span class="o">=</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                 <span class="n">euqal_02</span> <span class="o">=</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
                            <span class="k">if</span> <span class="p">((</span><span class="n">cmp_01</span> <span class="o">==</span> <span class="n">cmp_12</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmp_01</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">cmp_01</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">euqal_01</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">euqal_12</span><span class="p">)))</span> <span class="o">&amp;&amp;</span> <span class="n">cmp_01</span> <span class="o">!=</span> <span class="n">cmp_02</span><span class="p">)</span> <span class="c1">//不符合不等传递性
</span><span class="c1"></span>                            <span class="p">{</span>
                                <span class="cm">/* 怎么才算符合不等传递性：
</span><span class="cm">                                1 1 -&gt; 1
</span><span class="cm">                                1 0 -&gt; ? (2 &lt; 7, 7 \not&lt; 5 ---&gt; 2 &lt; 5)(2 &lt; 7, 7 \not&lt; 1 ---&gt; 2 \not&lt; 1)
</span><span class="cm">                                0 1 -&gt; ? (Same way)
</span><span class="cm">                                0 0 -&gt; 0 //但要注意这里cmp为0：有可能是不满足，也有可能是因为等于的情况。所以要加!euqal来排除等于情况
</span><span class="cm">                                */</span>
                                <span class="n">flag_inequ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                                <span class="n">printf</span><span class="p">(</span><span class="s">&#34;No transitivity of inequivalence: %d %d %d %d %d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
                            <span class="p">}</span>
                            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">euqal_01</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">euqal_12</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">euqal_01</span> <span class="o">&amp;&amp;</span> <span class="n">euqal_12</span><span class="p">)</span> <span class="o">!=</span> <span class="n">euqal_02</span><span class="p">)</span> <span class="c1">//相等传递性
</span><span class="c1"></span>                            <span class="p">{</span>
                                <span class="cm">/* 怎么才算符合相等传递性：
</span><span class="cm">                                1 1 -&gt; 1
</span><span class="cm">                                1 0 -&gt; 0
</span><span class="cm">                                0 1 -&gt; 0
</span><span class="cm">                                0 0 -&gt; ? (2 ≠ 3, 3 ≠ 2 ---&gt; 2 = 2)//这个很好知道吧【…… 
</span><span class="cm">                                */</span>
                                <span class="n">flag_equ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                                <span class="n">printf</span><span class="p">(</span><span class="s">&#34;No transitivity of equivalence: %d %d %d %d %d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
                            <span class="p">}</span>

                            <span class="k">if</span> <span class="p">(</span><span class="n">flag_inequ</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">flag_equ</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//私货：求证如果满足不等传递性，但不满足相等传递性，是否X=Y,Y&lt;Z---&gt;X&lt;Z；X&lt;Y,Y=Z---&gt;X&lt;Z？
</span><span class="c1"></span>                            <span class="p">{</span>
                                <span class="n">printf</span><span class="p">(</span><span class="s">&#34;===In Case===</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
                                <span class="kt">bool</span> <span class="n">euqal_cmp01</span> <span class="o">=</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                     <span class="n">ineuq_cmp01</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                     <span class="n">euqal_cmp12</span> <span class="o">=</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                     <span class="n">ineuq_cmp12</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                                     <span class="n">euqal_cmp02</span> <span class="o">=</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cmp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                     <span class="n">ineuq_cmp02</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">euqal_cmp01</span> <span class="o">&amp;&amp;</span> <span class="n">ineuq_cmp12</span><span class="p">)</span>
                                <span class="p">{</span>
                                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ineuq_cmp02</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">euqal_cmp02</span><span class="p">)</span>
                                        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;---X=Y,Y&lt;Z---&gt;X not&lt; Z: %d %d %d %d %d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
                                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ineuq_cmp02</span><span class="p">)</span>
                                        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;---X=Y,Y&lt;Z---&gt;X = Z: %d %d %d %d %d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
                                <span class="p">}</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">ineuq_cmp01</span> <span class="o">&amp;&amp;</span> <span class="n">euqal_cmp12</span><span class="p">)</span>
                                <span class="p">{</span>
                                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ineuq_cmp02</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">euqal_cmp02</span><span class="p">)</span>
                                        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;---X&lt;Y,Y=Z---&gt;X not&lt; Z: %d %d %d %d %d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
                                    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ineuq_cmp02</span><span class="p">)</span>
                                        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;---X&lt;Y,Y=Z---&gt;X = Z: %d %d %d %d %d %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
                                <span class="p">}</span>
                            <span class="p">}</span>
                        <span class="p">}</span>
                <span class="p">}</span>
        <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 展开式：【用来debug方便watch的……
</span><span class="cm">    int min_ij = min(a[i], b[j]),
</span><span class="cm">        min_ji = min(a[j], b[i]);
</span><span class="cm">    bool ans = 0;
</span><span class="cm">    if (min_ij == min_ji)
</span><span class="cm">        ans = a[i] &lt; a[j];
</span><span class="cm">    else
</span><span class="cm">        ans = min_ij &lt; min_ji;
</span><span class="cm">    return ans;
</span><span class="cm">    */</span>
    <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>                                                    <span class="c1">//Case.1
</span><span class="c1"></span>    <span class="c1">//return min(a[i], b[j]) &lt;= min(a[j], b[i]);                                                   //Case.2
</span><span class="c1"></span>    <span class="c1">//return min(a[i], b[j]) == min(a[j], b[i]) ? a[i] &gt; a[j] : min(a[i], b[j]) &lt; min(a[j], b[i]); //Case.3
</span><span class="c1"></span>    <span class="c1">//return min(a[i], b[j]) == min(a[j], b[i]) ? a[i] &lt; a[j] : min(a[i], b[j]) &lt; min(a[j], b[i]); //Case.4
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>上述提到了：如果满足了严格弱序一定也会满足「排序完成后任意交换相邻元素均不会使答案更优」这个条件。<br>
所以我并没有写上“ouuan”博客中的那个条件。<br>
而且对于严格弱序，我也认为只用判断传递性即可。<br>
【如果这种修改有误，请务必告诉我！……</p>
<p>因为决策条件$P$满足严格弱序后，我们按照$P$排序后，一定会使任意两项均满足$P$，则满足我们的贪心的思想，使得肯定这个状态是最优解状态。<br>
【但这种口头解释没有严格证明可能没有说服力，可以自己在判断器里删掉注释然后验证一下_(:з」∠)_……</p>
<h3 id="2与选择排序对拍">2、与选择排序对拍</h3>
<p>当然，我们发现了：用选择排序的话结果是正确的。</p>
<p>所以我们也可以很快地写个选择排序，然后跟我们新的方法进行对拍。</p>
<h1 id="其他补充点">其他补充点</h1>
<h2 id="有关排序的深层理解">有关排序的深层理解</h2>
<p>我们发现<strong>选择排序用之前的条件</strong>，虽然会TLE，但是是<strong>正确的</strong>。</p>
<blockquote>
<p>洛谷上测试状态【其余未放出的均AC】：<br>
<img src="./pic/Selection_status.png" alt="Selection_status"  /><br>
将其两组数据放到本地测评：<br>
<img src="./pic/Selection_AC.png" alt="Selection_AC"  /></p>
</blockquote>
<p>主要就是因为排序这种绝对的$O(n^2)$的算法，是<strong>严格让所有数据都两两比较</strong>。</p>
<p>正式因为其两两比较，使得不需要利用满足数据严格弱序的传递性。<br>
不会像快排或归并等其他非$O(n^2)$的算法一样，利用严格弱序中的传递性，来对某些情况减少判断，达成了降低复杂度的办法。</p>
<p>也就是说，他们<strong>为了提高速度</strong>，<strong>省略了一些比较</strong>。代价就是数据必须要满足一定的条件，即严格弱序。</p>
<p>同样，就连冒泡排序这种本来也是$O(n^2)$的排序算法【但实际上并不是绝对的$O(n^2)$，其最坏是$\frac{(n-1)n}{2}$次操作】，<br>
因为只是比较相邻的数据，并未严格任意两两比较。也是利用了传递性。</p>
<h2 id="有关贪心决策的满足度影响">有关贪心决策的满足度影响</h2>
<p>之前发现：</p>
<p>让<strong>任意两项都满足决策条件</strong>，是<strong>一定是最优解</strong>的。<br>
但之前发现：如果<strong>存在两项不满足</strong>，也有<strong>可能是最优解</strong>。</p>
<p>也就是<strong>任意两项都满足</strong>决策条件的这种状态，是<strong>最优解状态的一种</strong>，为$∈$关系。</p>
<p>但我们<strong>只能去找任意两项均满足的这种状态</strong>。因为对于存在两项不满足的，也有可能不是最优解，就成了概率问题。<br>
【而这道题概率出来就是80分……</p>
<h2 id="有关排序对严格弱序的不同要求">有关排序对严格弱序的不同要求</h2>
<blockquote>
<ol>
<li>$X \not&lt; X$（比较条件非自反性）</li>
<li>若$X &lt; Y$，则$Y \not&lt; X$（比较条件非对称性）</li>
<li>若$X &lt; Y,Y &lt; Z$，则$X &lt; Z$（比较条件不等<strong>传递性</strong>）</li>
<li>若$X=Y,Y=Z$，则$X=Z$（比较条件相等<strong>传递性</strong>）</li>
</ol>
</blockquote>
<p>前面已经说了，对于1、2点，其实对于贪心的题目要求并不严格。<br>
不满足的话只是会多交换几次，导致状态不同，但最终的<code>ans</code>是一样的。</p>
<p>但某些算法要求必须要遵守1、2点。</p>
<ul>
<li>
<p>对于用STL库的<code>sort()</code>：<br>
其必须还要考虑1、2点<strong>非自反性和非对称性</strong>。</p>
<p>因为内部的算法实现，对下标的判断需要用到这两个性质，否则会越界导致<code>RE</code>。<br>
【不过我没有具体去看函数内部的代码实现，只是根据网上搜的以及自己实验得出来的，不一定准确。但确实不考虑这两个的话会出现<code>RE</code>……</p>
</li>
<li>
<p>对于其他非$O(n^2)$排序方法：<br>
如：归并排序<code>merge</code>：<br>
则不用考虑1、2点。<br>
【当然还是要根据自己的排序写法来判断是否需要满足1、2点……</p>
</li>
</ul>
<h2 id="有关传递性的简单判断">有关传递性的简单判断</h2>
<p>我们排序比较时，只会比较两个元素，也就是两个下标，一般用$i,j$代表。<br>
而<strong>排序（决策）条件</strong>，也一定是与$a_i$和$a_j$的衍生关系。</p>
<p>那么排序条件的下标会有两种情况：</p>
<ol>
<li>
<p>一侧只有一个下标<br>
形如：$cmp(x,y)=A_x?A_y$</p>
<p>当比较条件一侧只有一个下标的时候很好理解，就是普通的数列排序。</p>
<p><strong>单侧下标时</strong>，两个下标的选择<strong>不会影响</strong>其对应的<strong>比较用数据</strong>的值，<br>
故一般能符合<strong>比较条件不等传递性</strong>和<strong>比较条件相等传递性</strong>。</p>
<ul>
<li>举例：</li>
</ul>
<blockquote>
<ul>
<li>条件为$a_i&gt;a_j$<br>
取$i,j$：$a_i=a_j$<br>
取$j,k$：$a_j=a_k$<br>
取$i,k$：$a_i=a_k$</li>
<li>条件为$a_i+a_{i+1}&gt;a_j+a_{j+1}$<br>
取$i,j$：$a_i+a_{i+1}=a_j+a_{j+1}$<br>
取$j,k$：$a_j+a_{j+1}=a_k+a_{k+1}$<br>
【则可直接推得$a_i+a_{i+1}=a_j+a_{j+1}=a_j+a_{j+1}=a_k+a_{k+1}$】<br>
取$i,k$：$a_i+a_{i+1}=a_k+a_{k+1}$</li>
</ul>
</blockquote>
</li>
<li>
<p>一侧两个下标都有<br>
形如：$cmp(x,y)=A_{x,y}?A_{y,x}$</p>
<p>当一侧两种下标都有时，则不同下标的选择<strong>会影响</strong>其对应的<strong>比较用数据</strong>的值。<br>
故需要具体判断是否<strong>比较条件传递性</strong>和<strong>比较条件相等传递性</strong>。</p>
<ul>
<li>举例：</li>
</ul>
<blockquote>
<ul>
<li>条件为$a_i+a_{j+1}&gt;a_j+a_{i+1}$<br>
取$i,j$：$a_i+a_{j+1}=a_j+a_{i+1}$<br>
取$j,k$：$a_j+a_{k+1}=a_k+a_{j+1}$<br>
【不可直接推得$a_i+a_{j+1}=a_j+a_{i+1}=a_j+a_{k+1}=a_k+a_{j+1}$】<br>
但可证得：取$i,k$：$a_i+a_{k+1}=a_k+a_{i+1}$</li>
</ul>
</blockquote>
</li>
</ol>
<h1 id="总结">总结</h1>
<p>有关排序型贪心，最基本的条件：</p>
<blockquote>
<p>数列<strong>任意两项满足决策条件</strong>。</p>
</blockquote>
<p>而我们可以<strong>利用传递性</strong>，只用分析相邻两项，来得到决策条件。</p>
<p>但在找到决策条件之后，要判定其<strong>是否满足</strong>严格弱序中的“<strong>相等传递性</strong>”和“<strong>不等传递性</strong>”</p>
<p>因此题目解决大致思路方法：</p>
<blockquote>
<ol>
<li>找出每种状态的<code>ans</code>，选邻项代入</li>
<li>假设相邻位置，写出两种状态的<code>ans</code></li>
<li>根据题意写出排序条件并化简，得到最终决策方案（不一定划到最简）</li>
<li>判断是否满足传递性</li>
<li>如满足：自定义结构体，重载<code>&lt;</code>运算符，使用<code>sort</code>，遍历寻答案</li>
</ol>
</blockquote>
<hr>
<p><em>以上部分参考自“ouuon”的<a class="link" href="https://ouuan.github.io/post/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/"  target="_blank" rel="noopener"
    >「浅谈邻项交换排序的应用以及需要注意的问题」</a>，以及“Joker&amp;Liar”的<a class="link" href="https://www.cnblogs.com/17134h/p/12706408.html"  target="_blank" rel="noopener"
    >「浅谈邻项交换排序」</a></em></p>
<p>写在最后：</p>
<blockquote>
<p>真的没想到写了这么多orz……弄了整整四天来写这一个东西qwqqq……<br>
写这么长而且也很混乱，估计以后自己或者其他人也根本看不下去吧x【……<br>
不过其实这里面还是有很多新发现的。比如快速排序算法的快速原因，以及最珍贵的就是那个不符合任意两项满足条件但是也对的hack数据什么的……<br>
也算是很深入地去理解贪心中这排序型贪心的本质……并且有一些也是在“ouuan”dalao博客里所没有的新发现，也算是比较安慰了【？……<br>
就这样吧，最近刚好也发生了很多事……<br>
按照自己的步调前行吧……</p>
</blockquote>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/">基础部分</a>
        
            <a href="/tags/%E8%B4%AA%E5%BF%83/">贪心</a>
        
            <a href="/tags/%E9%82%BB%E9%A1%B9%E6%AF%94%E8%BE%83%E6%8E%92%E5%BA%8F/">邻项比较排序</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>采用 CC BY-NC-SA 4.0 许可协议</span>
    </section>
    <section class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span class="article-time--modified">
            最后更新于 2020/12/18 19:29
        </span>
    </section><section class="article-backgroundID">
        <svg t="1608817880971" class="icon" viewBox="0 0 1156 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2026" width="200" height="200"><path d="M1012.973037 122.680889C922.168889 44.885333 795.003259 0 647.205926 0 262.011259 0 0 291.422815 0 291.422815l73.832296 114.877629s40.846222 3.356444 19.218963-64.312888c18.669037-34.569481 55.220148-81.133037 126.58726-134.874075v765.184c-30.767407 8.51437-71.433481 24.519111-43.70963 51.693038h212.091259c27.998815-27.45837-16.109037-43.984593-42.979555-51.693038V791.789037s145.417481 55.959704 302.165333 55.959704c137.737481 0 263.044741-40.173037 356.257185-112.734815 93.202963-72.144593 153.27763-179.873185 152.907852-302.999704 0.274963-120.888889-52.508444-231.831704-143.397926-309.333333zM900.570074 674.616889c-64.455111 62.388148-158.179556 101.840593-266.30637 101.764741-120.623407 0.056889-222.170074-22.840889-289.21363-55.201186V556.743111 147.095704C418.607407 95.857778 537.92237 64.284444 634.263704 64.474074c117.05837 0.085333 208.981333 43.444148 271.122963 109.255111 62.046815 66.199704 95.924148 154.130963 96.227555 256.341334-0.369778 99.602963-36.589037 181.636741-101.044148 244.54637z" p-id="2027"></path></svg>
        <span class="article-background--pixivID">
            文章封面配图Pixiv ID：71111285
        </span>
    </section></footer>

    
        
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/contrib/auto-render.min.js"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
              delimiters: [
                  {left: "$$", right: "$$", display: true},
                  {left: "$", right: "$", display: false}
              ]
          });
    });
</script>

    
</article>
    
    

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/greedy/">
        
        
            <div class="article-image">
                <img src="/p/greedy/80942286_p0_hu1614f1e19d3d1ca6099df8f8b769c088_1500547_250x150_fill_box_smart1_2.png" width="250" height="150" 
                        loading="lazy" data-key="greedy" data-hash="md5-9Kzg8B0Z3M5oH9zlHMl9CA==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">贪心……</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/stl/">
        
        
            <div class="article-image">
                <img src="/p/stl/79059953_p0_hudcdceb022a1e552a3fbecef4125cea72_897862_250x150_fill_box_smart1_2.png" width="250" height="150" 
                        loading="lazy" data-key="STL" data-hash="md5-cv&#43;5BWEAZy9bG4tcU&#43;2P5g==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">STL……</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/sort/">
        
        
            <div class="article-image">
                <img src="/p/sort/86036732_p0_hud48aef1ba1119480544a4ab4b9f32654_3422651_250x150_fill_box_smart1_2.png" width="250" height="150" 
                        loading="lazy" data-key="sort" data-hash="md5-3qBWkZGIt6eBhz2yr3I6HQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">排序……</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>


    
        
    <script src="https://utteranc.es/client.js" 
        repo="supersass/BlogComment"
        issue-term="title"
        theme="preferred-color-scheme" 
        
        crossorigin="anonymous" 
        async>
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

    

    <footer class="site-footer">
    <section class="copyright">&copy; 2020 Super SASS……</section>
    <section class="powerby">Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="1.1.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true" style="display:none">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

        </main>

        
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"
    integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin="anonymous"></script><script type="text/javascript" src="/ts/main.js" defer></script>

<script type="text/javascript" src="/ts/changeScheme.js" defer></script>

<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


</body>

</html>