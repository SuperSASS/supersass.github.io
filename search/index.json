[{"content":"本指南完成于2021年，时效性请根据阅读时间来判断。\n\r 指南篇幅过长，电脑端可点击左侧的“显示文章目录”显示目录。但由于博客主题原因，手机版暂时没有文章目录显示。\n\r 由于本博客评论系统暂未完善，如需要评论但使用不便可以通过QQ联系我。（在“关于”页面中有写）\n\r 由于本人能力有限，本文所述内容可能具有偏差和片面性，同时含有一定作者主观想法，请食用时务必加上自我判断与思考。\n\r 日后个人可能还会在询问其他同学相关经验和意见后，对这篇指南进行完善。\n\r 希望各位有相关经验的同学如果发现文章错误或有想法建议，能及时联系我指正提出。让我们一起完善这篇指南。\n\r 写在最前 写这篇指南的原因，是因为这里一直没找到很成体系的有关本校转专业的相关文章……\n个人所有关于转专业的认识方法等都是从各方打听到的，很零散地拼凑起来，才勉强对转专业这复杂的系统有初步的认识（而且还不保证一定正确……\n趁着这次转专业成功并且刚结束不久，实在是有太多想说的，\n以及为了之后转专业的同学们有条更顺畅明亮的道路，有感而发【闲得无事x】就写了这篇指南……\n个人基本信息 这里先提前说下个人转专业的基本情况：\n 年纪：2020级 原专业与学院：应用心理学 - 心理研究与咨询中心 转入专业与学院：计算机科学与技术 - 计算机与人工智能学院  一些劝诫 当然我相信如果大家有问过其他学长学姐们转专业相关的事的话，或多或少会听到一些警告甚至劝止……\n在开始本篇指南之前，我也一样会先直言转专业的弊端并提出自己的劝诫……\n希望各位能用几天时间，好好深思熟虑、重新审视、综合权衡一下自己转专业的想法……\n这是大学中一个会深刻影响到你的分岔路口，是自己成年后面临的重大抉择之一……\n 总而言之：\n如果不是出于对所转专业极度的向往喜爱，没有强烈的愿望意志，\n而仅是因为对原专业的不了解不喜欢或其它一些功利目的的话，\n是极其不推荐走转专业这条路的。\n\r 几点主要原因如下：\n 转专业的信息匮乏。需要自己花费大量精力去各种打听咨询相关信息，并且所得到的信息也会较为模糊复杂…… 转专业的高指标与硬性要求。需要花费更多时间精力去学习更多内容，使宝贵的大一空闲时间被占用…… 转专业的竞争。尤其是热门专业更为激烈与残酷…… 转专业失败的风险。对体力及精神的打击，需要对所造成后果重新抉择…… 转专业成功后的各种极其繁琐的事务。如对未知新环境的重新适应、补修课程、各项事务申请等……  最终，无论转没转成功，都会极大降低一到两年的大学时间的价值与效率，甚至可以说直接浪费一两年或更多时间也不为过……\n而大学，一共只有四年……\n大学不仅只有学习与绩点，更重要的是社交、兴趣爱好、各项能力、视野拓展，甚至于爱情、娱乐、身体素质等各方各面……\n而这些，在大一大二的时候，才是最好的发现、培养、训练的时间……\n自己在哪天夜晚emo的时候好好想想：自己花这一两年的时间，舍弃了什么，换来了什么？……\n自己愿意为之付出努力吗？……\n这一切，真的值得吗？……\n 当然我知道，对于大部分同学，特别是能找到这篇文章的同学来说，是不可能被我前面简单的几句警告以及黑泥而吓跑的……\n而且个人也并不是对转专业这事持完全的否定与悲观态度，只是告诉同学们需要慎重考虑而已……\n如果真的抱着如此强烈的决心的话，那么还请相信自己并坚持下去，也希望我接下来的内容能对你有所帮助……\n我将会按照以下三个关键时间阶段划分来完成这篇指南……\n 大一上学年早中期 大一上学年末期和大一下 大二上学年  这样可操作性更强，也能更明白每个阶段应当思考、行动、注意的事……\n将大一上末期归到第二个时间节点的原因是因为这个时段要处理的事务很多，与大一下几乎是连着的。\n\r\r个人提前假设各位都是大一开始转专业的同学，若为大二才开始的同学以下指南不一定适用，请按照实际情况行动。\n\r\r\r  以下为正文部分\n  一、思——大一上学年早中期 思 —— 倾听、感受、思考。\n\r 引入 刚来从高中来到大学校园，对于自己的专业，大家肯定都会有自己的想法。\n如果是恰好分配到自己所想的专业，那固然是最幸运的，加油在自己所选的道路上努力前行吧！\n但由于“调剂”这一机制的存在，使得部分同学并没有分配到自己所选的专业，\n甚至可能会调到一个从来都没听过的专业；【比如某“应用心理学”x……\n或者选入的是比较靠后的专业，还是有点稍不满意；\n更或早在选志愿的时候就想到了：先选个好点的学校进个差点的专业，最后再转专业转入自己想去的专业这样的战术。\n 这里并不是恶意拿原专业开玩笑啊！……\n只是因为在偏理工（其实是综合类）的西南交通大学还会存在心理学（其实是理科）也是让我震惊了一下，\n可能很多同学也都没听过西南交大还有这专业所以很适合举例xd……  所以纠正一下西南交通大学其实是综合类大学，文理科“均衡”发展的那种……\n对其“交通”含义不了解的同学好好去校史馆听听！…… 而且心理学也是理学，我认识的人80%都认为是文科orz……   这里再补充一下：个人其实并不是调剂的，我第六专业选的就是应用心理学……\n因为对心理学其实也非常感兴趣的这样(:з」∠)_……\n至于为什么最终还是转了那就是个人事务啦……  \r 一点黑泥……\r其实个人真的很想？这个调剂机制……\n为什么不选调剂就会掉档呢？难道不能不选后如果没有录到所选专业就换下一个志愿吗？……\n也就是选了调剂保学校，不选调剂保专业这样……\n会掉档这一后果肯定就让所有考生都把调剂选上了呀……\n不是很明白这一机制这样设置的原因'_\u0026gt;'……\r 无论如何，这个时候总会在各种地方平台听到“转专业”这一机制的消息，\n对于以上三种情况的同学来说，自然很大部分都会去了解这一机制并且产生尝试的想法了。\n【不然怎么会来看这篇文章呢hhhh……请原谅这一大段废话引入……\n 产生这一想法很正常，用心理学观点就是：\n不满产生矛盾、矛盾产生动机、动机产生意志。【学过一年总要用点来口胡吧xddd……\n但正如最前所说，这一想法事关重大，还是要好好考虑一番。\n所以在大一上刚开始有这一想法的时候，可以问自己一些问题来帮助自己了解判断转专业这一想法的正确必要性。\n接下来就是大一上早中期的时候可以具体做的几件事情。\nStep. 1 - 与自己对话 自己总结了一些可以用来灵魂拷问的问题，\n问题可以但不限于如下：\n 你为什么会选择转专业？  是自己的喜好梦想，还是功利性的好就业、工资高，抑或其他原因？   你对本专业是否有最基本的认识了解？  它真的不适合你吗，对你一点兴趣也没有吗？ 这个专业会学习什么内容，将来的情况如何？   你对目标专业的了解程度如何？  它主要学习什么内容，将来会从事何种活动？ 这个专业的发展前景如何？ 它需要我哪方面的能力，我是否能胜任？ 自己为什么如此偏爱这个专业？   对目标专业的掌握情况如何？  自己是否有提前学习相关内容，是否掌握基本的能力？   是否能承受转专业过程的信息匮乏状态，以及有耐心与能力处理各种琐事？  自己是否能敢于多问，去问转专业成功的前辈，问教务处的老师们，向他们请教经验、获取更多有用信息？ 面对转专业前后各种琐事，有些甚至直接决定是否能转专业成功，自己是否能有精力去处理完成？   如果转专业失败，是否有所应对计划？  自己该如何打算？是中途停止还是继续尝试？ 如果实在不能转专业，是否可以考虑辅修？ 如果最后一次机会（大二转专业）也失败，该如何承受以及补损？   如果转专业成功，自己该如何适应全新的环境？  自己在原专业的一些发展（如班委、建立的关系圈）可能会受到影响，自己是否能承受？ 自己需要补修培养计划中所未修的课程，自己是否有精力能力完成？ 自己可能会从原专业优异成绩的舒适圈中脱离出来，是否能接受这种变化？ 来到全新的班级，在他们已经发展交流了一年的情况，自己是否还能再融入进去？    不要觉得这步骤多余且无用，正相反，它是你转专业道路上最重要的基石与路标，\n多问问自己，在对答案的探寻中，也能逐渐摸索探清出自己的道路，并更加坚定于自己的想法。\n不要在自己还不清楚自己是否要转专业，只是迷迷糊糊有这种想法而进行，这样无论成功与否都只是浪费时间。\n转专业拼的可不仅只有成绩与能力，还有坚强的决心与意志力。\n\r Step. 2 - 了解转专业机制 这可以算是要想转专业的基本要求，\n正如前面所说，转专业的信息较为匮乏且模糊，\n所以需要在这大一上这一年里，花费大量时间去了解什么是转专业、怎么去转专业、各项要求指标、时间流程等等相关信息是非常必要的。\n这里先简单提一点转专业的基本流程：\n转专业正式工作一般在暑假末期开始、上学期初进行并完成，基本流程为：网上申请→审批考核→公示结果。\n正式工作流程\n暑假末期网上申请阶段\n\r该阶段只需要登陆学校的“教学服务网上办事服务平台”提出申请即可。\r\r大二上开学第一周内审批考核阶段\n\r在此阶段各学院会按照转专业实施细则，进行相应的考核，如笔试、机考、面试等。\n到时候会有明确的通知，跟着通知流程进行即可。\r\r大二上开学第一至二周内公示结果阶段\n\r各学院依据考核的最终成绩，公示转专业最终录取名单，并在接下来的时间内逐步完成转专业剩余工作。\r\r\r注意：不同学院的审核和公示速度会有较大差异。\n\r\r\r 而想要稍微全面了解，可以采用以下方法。\n⭐1. 阅读目标专业的“转专业实施细则” 所有学院在转专业的进程当中，基于的规则都是本院所给出的“转专业实施细则”这一文件。\n可以知道仔细阅读分析这一文件对转专业的必要性与重要性了。\n一般对各位第一次转专业时机（也就是你们刚到大二能转专业）的实施细则，会在你们大一上末期发出。\n因此现在可以先提前阅读目标专业的学院近一至三年的转专业细则，尤其是最近的本年细则（即对于现在的大二的细则）。\n文件一般长这样：\n信息科学与技术学院2021年本科生转专业实施细则\n正式文件搜索方法为：\n 进入目标学院的官网（所有学院的官网可在西南交大的首页的“学院设置”中找到） 在搜索栏搜索“细则”一词 如发现标题为“……学院……年转专业实施细则通知”等类似标题，点开此通知。 ​在附件中一般就有当年的转专业细则，下载打开即可。  需要注意：\n2021年起，\n原属于“信息科学与技术学院”的“计算机科学与技术、软件工程、人工智能”三个专业，\n已从原学院分离到新的“计算机与人工智能学院”。\n\r 对于细则的分析，因为是大一上末期公布的，将在后面的详细解读“转专业实施细则”中说明。\n\r ⭐2. 询问目标专业的学院教务处 无论如何，最终转专业的解释权都在目标学院的教务处上面，\n所以遇到问题，尤其是比较冲突矛盾的问题，第一时间询问目标学院的教务处是最保险也是最管用的。\n虽然偶尔教务的回答可能会很模棱两可或态度不佳，\n但根据“西南交通大学本科生转专业管理方法”中第三章第十条——“学院为学生提供转专业咨询”，而学院一般都是以学院教务处提供咨询的。\n所以遇到问题后直接理直气壮去问教务，一定要问出清楚的答案为止。\n一般教务咨询方式都会在“转专业细则”中出现，\n如果没有，一般可以到目标学院官网中的学院概况中查到。\n但也有部分学员官网没有明确写出教务信息，【或者说设置的太神秘我反正是没有找到……\n这个时候可以到校教务处的“信息查询”界面找到各学院的教务办公室和办公电话等信息。 各学院教务信息总览\n3. 咨询同专业转专业成功的前辈 这个方法是最直接也是最可操作的。\n可以先咨询辅导员或者问问认识的学姐学长，问问之前有没有成功转走的直系学长学姐，\n索取到联系方式后，便是克服社恐去多问问了。\n运气好的话一些学院可能还有自己转专业的群，热心学长学姐可能还会在里面直接指导。\n再之后各阶段所遇到的问题，尤其是有关学业方面的问题（会怎么考试、如何复习等），\n找前辈直接问都是很有效的。【如果是比较负责的前辈并且乐于回答的话……\n因为各原专业的所修课程不同，可能对于转专业会有自己不同的处理方式。\n同时在大一下期的选课阶段，问他们也能知道最适合的处理方式。\n总之，问直系学长学姐是很不错的方式，尤其是如果有前辈跟你转同一专业的时候。\n具体问的问题可以参考如下：\n 转专业的大致流程是怎样的？ 我大一下选课的时候应该如何操作？ （如果对方也是转到你的目标专业的前辈）我也准备转到……专业，请问难度大吗，对我的大致要求是什么？ 我现在可以如何准备？ 我还可以询问谁/哪些群或平台还可以帮助我转专业？【多点信息源总是好的……  注意：如果遇到十分矛盾冲突的问题，尤其是在选课方面，请最好去咨询教务并且按照教务的要求来决定。\n\r 4. 阅读学校的“西南交通大学本科生转专业管理办法”文件 各种学院指定的转专业细则，都是以此文件为基础进行编定的。\n文件官网链接：【西南交通大学本科生转专业管理办法】\n\r 其中需要注意的有：第四条、第五条、第十条、第十二条、第十五条、第十六条。\n第四条 第五条 第十条\n第十二条 第十五条 第十六条\n第四和第五条中两条有关课程的明文要求已经用红框标出。\n\r 但具体怎么样，还是要根据各院的“转专业细则”来进行。\n5. 咨询其他认识的学长学姐，转专业相关群 如果有其他认识的学姐学长认识的话，也还是可以去问问的。\n大学主要就是通过问的方式获取各种信息。\n【都是第一次读大学嘛，有不懂的挺正常hhhh……\n而相关群的话，我们学校也有一个转专业交流群：\n群号：423276278\n群聊二维码\n点击此处加入群聊【西南交大转专业交流群】\n\r 平时会发些相关通知在群里，转专业的同学还是加一下很有用的。\n 有关转专业信息的获取方法大致就上面几种。\n但实际上自己多数得到的信息会很模糊甚至自相矛盾，\n这里最好以以上标星的方法为主要判断手段。\n尤其是第二点，如果从教务那里得到准确信息后，请务必按照教务那边的规定来！\n其他建议 当已经下定决心并且了解转专业的基本信息后，在大一上早中期就已经没什么可以做的了，\n剩下的就是制定好计划并开始相应准备，然后等到大一上末期进入下一阶段了。\n不过还有几个建议要提一下。\n1. 学好原专业课程 了解了转专业基本信息后就知道，转专业也是要看原专业课程的分数排名的。\n所以无论你现在对原专业的兴趣怎样态度如何，\n想要转走，就必须要把你现在专业的课程给学好。\n从这学期就开始不要松懈加油吧，\n学得越好，转成功的几率就越大，\n毕竟成绩还是硬性指标嘛。\n2. 课程旁听 虽然大一上是不能自己选课的，但大学的特点之一就是可以旁听。\n如果有时间的话，去旁听一下准入课也是非常不错的选择。\n比起上网课去提前学习，旁听准入课可以更好地适应学校学习的环境以及老师的上课方式，\n否则大一下再去学习，可能会花一段时间去适应老师和课堂，甚至会因此导致一些损失。\n个人就是因为大一下去学高数Ⅱ时，不了解老师的讲课风格和安排……\n在第一次随堂测试的时候甚至不知道交卷时间自己慢慢做，结果要求的做题时间却实际上很紧张……\n直接导致题都没做完就要求交卷了，当时也把我弄得难受焦虑了好一阵子【……\n\r  所有的本学期课程信息都可以在教务处的“课表”中查询得到。\n搜索相关课程后，找一节在你空闲时间的课，记下教室号，\n之后在这节课的上课时间，直接去教室找个地方自己坐下听就行了。\n举个例子\r比如我想在这学期去听一下“高等数学Ⅰ”。\n就先搜索高数Ⅰ的课程信息。 2021年 高数Ⅰ 课程信息 发现B2000那节课，星期二1~2节和星期四3~5节恰好是我的空闲时间，\n后到这两个时间段直接去X1314去听课就行。\n【应该不会有人把九里和犀浦的课弄混吧.jpg……\n\r 3. 准备英语四级 一般来说，许多学院的转专业细则上都有对英语四级的要求，\n所以这个阶段就可以好好准备下四级考试。\n需要特别说明的是：\n大学的四六级考试的听力，和初高中的听力有很大差别！\n四六级的听力是没有题目只有答案，题目是听力里念出来的，\n这个差异会导致很多同学很不适应这种听力方式。\n所以提前去做点相关题目适应一下是很有帮助的。\n\r 4. 提前训练相关能力 对于某些学院，要转入的话除了通常的看成绩以及面试之外，\n可能还会考察你的相关专业能力。\n最典型的就是计算机学院，需要考察程序设计能力，\n会额外地进行一个“C语言程序设计机考”，简称机考。\n如果之前并没有程序设计经验，建议在这时候开始就去训练相关能力，\n训练得越早，自己就越有经验，也会更加熟悉。\n有关机考的详细信息以及题目示例见后面的「机考」部分。\n\r 有关机考准备的个人建议（没有经验的同学可以看看）\r【虽然我觉得既然都有强烈兴趣的话也应该早有所接触有经验了吧.jpg……\n有关学习 机考不会考什么复杂的内容，只考简单的语言掌握情况。\n如果一点经验都没有的话，\n可以先去买《C语言程序设计基础》这本书，然后一直学到链表那里就行。\nC语言程序设计基础\n如果想要更深入，也可以去以竞赛方面的基本内容来学习，\n但如果之前一点经验也没有，直接按竞赛方式学习的话并不是很推荐。\n竞赛跟实际的程序设计差别很大，以程序开发为目的的同学其实并不需要强行涉及竞赛。\n\r\r有关练习 可以购买相关C语言上机实验习题的书，然后从中选题来做，\n这个可能跟实际机考更相近些，优先推荐这样练习。\n样例书籍\n 也可以去洛谷这个练习平台，将他的题单中的【入门】内容做一下，\n因为机考不涉及算法，所以后面的可以当额外拓展去尝试，优先把前面的入门部分给掌握了。\n洛谷 题单内容\n 但听说我们学校专门有“C语言程序设计”的做题平台，但个人并不清楚。\n可以去咨询下计算机系的学长学姐们，\n如果能找到这个平台的话，直接做我们学校的题肯定是最好的。\n欢迎有知道相关信息或者其他适合针对“机考”的做题平台的同学与我联系，我将会将链接添加到这部分。\n\r\r个人经验 编程这东西真的跟真正的语言一样，靠的是熟练度，\n学得越久用得越多就越熟练，而且会逐渐形成一种思维，而不是短时间的刷题能掌握的。\n以我个人来说，是从小学就开始接触程序设计，参加NOIP，到现在几乎是有六七年的经验了，\n所以现在不说很熟练，【当然我水平其实本来就不是很厉害……\n但至少我能理解那个思想，上手起来也能容易很多。\n\r 5. CSP认证 由于个人对这条消息只是听说得来，并没有相关经验，所以具体情况还请问目标学院教务处或其他有经验同学。\n\r 这是对于要参加机考的同学可以关注的。\nCSP认证听说可以替代机考成绩，\n具体聊天记录如下：\n有关CSP认证的聊天记录\n免机考门槛是200分，\n2020年开始试行，之后应该会出正式的相关政策。\n 一般每三到六个月会进行一次认证，\n具体时间请自己记得查看官网。\n点击此处进入CSP认证网站\n\r 点击报名入口，然后勾选CSP认证即可查看。\nCSP认证报名信息\n 可以加入学校的CSP认证报名群，里面会发送通知。\n群号：960670162\n群聊二维码\n点击此处加入群聊【SWJTU-ACM比赛交流群】\n\r 或者加入学校ACM比赛交流群也可以。\n群号：671974794\n群聊二维码\n点击此处加入群聊【SWJTU-ACM比赛交流群】\n\r 二、备——大一上学年末期x大一下学年 备 —— 合抱之木，生于毫末。\n\r 介绍 这个时间段是转专业过程中最关键的时间段，\n因为涉及到选课这个重要操作。\n选课正确与否直接决定能否转专业成功！\n 甚至有因为选课错误，即便后面考核阶段通过，也会被拒的情况。\n详细情况请查看本文后面的「事件一 —— 必修未修完导致转专业被拒」。\n\r Step. 1 - 注意通知——转专业细则 在大一上学年末期，教务处会发布各学院转专业细则的汇总通知，其通知名的格式为： 「关于公布……年各学院转专业实施细则的通知」\n\n以往通知链接：\r 关于公布2021年各学院转专业实施细则的通知 - 2020/12/31 关于公布2020年各学院转专业实施细则的通知 - 2019/12/19 关于公布2019年各学院转专业实施细则的通知 - 2018/12/18  \r 在通知的附件中会有两校区各学院的转专业细则，\n下载后查看目标专业的对应学院细则即可。\n2021年 通知和附件示例\n详细解读“转专业实施细则” 所有的转专业细则都会包含以下三个与转专业有关的内容：\n 转专业工作领导小组 转专业实施细则 转专业咨询方式  个人翻阅了2021年所有转专业细则，都包含以上三个内容。\n\r 1. 转专业工作领导小组 这个对我们的关系不大，\n一般有问题的话是咨询“咨询方式”里留下的联系方式。\n2. 转专业实施细则 这个是文件核心内容，\n其中一般包括了：\n  转专业要求：\n这里都是对转专业的基本要求，一般都是基于《西南交通大学本科生转专业管理办法》所规定的。\n比如“要修完原专业已开设课程”或“预修并通过准入课程”等。\n这一部分请务必仔细阅读并确保理解所转专业的每一条要求！\n\r   计划录取名额：\n写出本次转专业的计划录取名额，看下有个大概印象就行，\n有些学院名额跟申请人数差不多；有些则申请人数远超名额。\n但转专业都遵循的是宁缺毋滥原则。\n  转专业准入课程明细：\n基本的信息如下：\n准入课程 - 信息学院 准入课程 - 交运学院\n 有些可能还会有备注成绩要求，不过普遍在要求上都很低，实际上能成功转入的分数可能远远高于要求分数。 有些准入课可能没标注年纪，这种情况个人认为是大一大二都是这些准入课，但具体情况还请咨询学院教务处。  有些可能是从几个准入课程中选择，这种选课会更加灵活：\n准入课程 - 电气学院 准入课程 - 机械学院 准入课程 - 心理中心 【才发现我们心理中心准入课大一是10选4，大二还要再额外17选10，这也太可怕了吧.jpg……\n有些可能会可以用其他同类型更高级的课程代替：\n准入课程 - 建筑学院\n 这种情况一般是高阶高学分的代替低阶低学分的（如数学分析可以向下代替高等数学、高等数学可以向下代替微积分初步），但具体情况还请咨询学院教务处。  其他还可能有一定程度的不同，但基本上都是以上三类别。 有些细则的准入课程明细可能在最后的附件中。\n\r\n  转专业考核实施方法：\n转专业工作具体要进行哪些方面的考核，如：笔试、机考、英语四六级、面试等。\n到时候最终录取名单会根据这些方面的成绩来综合确定。\n  3. 转专业咨询方式 一般留下的都是各学院教务处的联系方式。\n前文也说过，对于转专业遇到的各种问题，\n尤其是涉及课程的问题，\n最好都咨询这里留下的联系方式！\n 比如在2021年材料科学与工程学院的转专业细则中，没有具体写明考核实施方法，\n对该内容有疑问的同学就可以通过联系方式咨询。\n 举个例子：\r这里假设某同学是2020级，现在为大一上学期，想转入信息科学与技术学院的计算机科学与技术专业。\n在大一上学期末的时候，发布了对应的「信息科学与技术学院2021年本科生转专业实施细则」：\n2021年 信息学院转专业细则 - 1,2页 2021年 信息学院转专业细则 - 3,4页 2021年 信息学院转专业细则 - 5页\n点击此处下载文档\n\r\r转专业要求 2021年信院细则 - 转专业要求说明 在转专业要求中，可以得出如下重要信息：\n 要满足最新的「西南交通大学本科生转专业管理办法」的相关要求 要预修并通过相关专业规定的准入课程 通过大学英语四级 通过信息学院C语言程序设计机考  以及卓越班的选拔工作信息。\n\r转专业准入课程明细 2021年信院细则 - 准入课程说明 查阅对应的2020级的计算机科学与技术的准入课程，要求为三门课程：\n 高等数学Ⅰ 高等数学Ⅱ 线性代数B  则需要在大二转专业之前将这三门课程修完。\n\r转专业考核实施办法 2021年信院细则 - 考核方法说明 这一部分交代了到时候会考核哪些方面。\n可以看出考核内容一共分为5个方面：\n 前一学年（针对2020级大二时）/前两学年（针对2019级大三时）全部必修课程总成绩专业排名 专业准入课程成绩 英语四级成绩 C语言程序设计机考成绩 专家组面试成绩  简而言之就是：（原专业和准入课）成绩+四级+机考+面试。\n最后总成绩是以这5部分综合加权考虑，\n如何考虑也不用太关心，反正在每个部分做到尽量最好就行。\n\r转专业咨询方式 2021年信院细则 - 咨询方式说明 说明了有问题时咨询对象的联系方式和地点。\n有任何问题不确定，优先打电话或者直接去办公室咨询！\n\r\r 有些细则里存在卓越班（詹班、茅班、拔尖班）的增选信息，有关这部分内容个人并不是很了解，\n如有需要可以咨询目标学院以了解。\n\r ⭐⭐⭐Step. 2 - 选课相关 警告：在选课方面如果有任何疑问，请务必咨询目标学院教务处！\n否则因此出现的任何后果需要自负。\n\r\r 在大一下末期的时候，会进行各位第一次的大学选课，\n这时候就需要根据之前细则中“准入课程”的要求，选择对应的准入课了。\n届时教务处会有相关通知指导选课工作的进行，其通知名的格式为： 「关于做好……学年第……学期选课工作的通知」\n\n同时班群、年级群等通知群里也都会通知。\n【如果没有通知那就是班委失职了.jpg……\n教务处的选课工作通知\n年级群的选课工作通知\n有关选课系统的说明\r本校选课一般分为三次：\n 第一次选课在本学期期末（一般为考试周）进行。  第一阶段只能选自己当前专业的优选课（就是按培养计划开设的课）和通识课。 该阶段选课会按照“优选班→权重分→随机序号”的顺序，最终确定选课结果，并统一公布结果。    有关权重分这一分配机制的再说明\r所谓权重分，就是对于一些限修和选修课程，也就是会有很多专业共同可选这门课的课程，\n如果不是优选班，就会根据所有同学投入的权重分排名进行选择（相同的话随机选择）。\n权重分每人总共100分，分配完为止。\n比如我可以对这门课投70分，对另一门课投30分，之后其他课就只能投0分了。\n个人不保证这段说明一定正确，因为个人目前并没有用过权重分机制，如有错误请及时联系我改正。\n\r\r\r\r  第二次选课也在本学期期末（第一阶段结束过几天就是第二阶段）进行。\n 第二次选课可以任意选择所有课程（包括自己的非优选课）。 将取消权重分机制，是实时确定结果的。\n即如果某课有空位且不冲突，选择该课就会立刻生效；退课也是立刻生效。    第三次选课是在下学期开始（一般为第一二周，会先上课几天）进行。\n 该次选课与第二次一致，用于在开学后再根据自己听课情况等具体情况进行课程调整。     同时，选课的上限是由学分来决定的。\n比如我下一学期可以修32学分的课，那么所选的课程加起来最多只能有32学分。\n*补充：一学分就代表一个课时，所交的学费也是根据所选学分来确定的。\n\r 这里针对转专业同学进行几点额外重要说明：\n  正常课程是分学期开设的。比如一般高数Ⅰ只会在上学期开设，而高数Ⅱ则只会在下学期。\n但部分课程存在重修班，其跟平时的班一样也可以作为准入课修读，但重修班一般在第三阶段选课才会出现。\n 比如大一下正常只能修高数Ⅱ的准入课，但在第三阶段选课时会有高数Ⅰ的重修班，这个时候选上就能修高数Ⅰ的准入课了。\n   关于通识课：\n由于要选准入课通常学分比较紧张，并且不同学科的通识课要求可能不同，\n所以最好在转专业阶段不要选择通识课，等转专业完成再选择。\n  一般大一下学期的最高可修学分，会比其他时段都少一些。\n因此可能会造成同时选必修课和准入课则学分不够的情况。\n这一情况可以去尝试申请“超学分”。\n  如果某一门转入课程所开设的所有班级都没有空闲时间去修读。\n这一情况可以去尝试申请“冲突选课”。\n  如果某一门转入课程所开设的所有班级都人数已满，\n这一情况可以去尝试申请“课程扩容”。\n  如果准入课是可选的，最好选择那些比较基础的学科，比如高数等。\n这样即便转专业失败，对自己的影响也是最小的。\n  ⭐需要注意：有些课程可能是针对茅班、詹班等卓越班开设的，\n这类课程的难度会偏大，且听说考试也会增加难度。\n因此在非必要情况下请不要错选到卓越班课程。\n高等数学Ⅰ- 普通班和卓越班区别\n可以看见普通班和茅班的区别只在班级信息上：\n写了(茅班)等注明的为卓越班，没写的为普通班。\n  再次强调：\n如果出现课程问题，并且相应手段（超学分、冲突选课、课程扩容）申请失败的话，请务必咨询目标学院教务处该如何处理！\n比如询问：是否能退掉原课程选择准入课？如果这门准入课无法修读该如何处理？\n\r\r\r 举个例子：\r由于写作时期选课系统已关闭，无法配图以说明，之后会视情况补上配图说明。\n\r\r这里以“2020年第二学期选课”为例进行说明：\n（也就是个人大一下的第一次选课）\n2020-2021学年第二学期选课通知\n2020.12.29 - 2021.1.4第一次选课\n\r这此选课中因为只能选优选班和通识课，\n而前面说过通识课最好不要选择。\n所以这阶段只用把所能选的所有优选班课程选上即可，\n权重分根据自己实际情况投。（这个就是正常选课的操作了，而不是转专业独有的，而且一般大一下选课用不到权重分）\n\r\r2021.1.6 - 2021.1.19第二次选课\n\r这个阶段则需要根据准入课去增选相应课程了。\n如果不会出现学分问题的话，直接增选所有需要修的准入课即可。\n出现超学分或课程冲突问题，且无法用一般方法解决，\n请务必咨询目标学院教务处，不要擅自决定。\n\r\r2021.3.8 - 2021.3.11第三次选课\n\r这个时候就是给自己调整的机会，\n如果发现课程选择有误（没有选齐原专业必修课和准入课），则及时进行调整。\n同时可以根据第一次课听课情况，对讲课老师的第一印象，\n决定是否要更换班级。\n\r\r\r\r 课程相关事务说明 课程扩容 当某课程所有班级都满员后，可以去找任课老师申请课程扩容。\n虽然“课程扩容”并没有明确的通知和文件规定，\n但一般老师都会同意的，所以并不是什么难事请放心。\n【我都忘了我是从哪听到这一操作的了orz，如果有找到明确通知和文件的同学欢迎跟我提出！……\n\r 个人曾就在线性代数课程满员后，向老师提出过课程申请并成功通过……\n\r 申请流程\n1. 找任课老师联系方式\n\r在教务处的“教师信息查询”页面，输入你想要申请扩容班级的任课老师，然后查询，\n教师信息查询结果\n再点击“详细信息”，可以查看该教师的信息。\n教师详细信息\n一般来说信息只会有电子邮箱，\n接下来我们就通过这个邮箱来联系老师。\n如果有手机，也可以发短信提出申请。\n效果可能比邮件好（因为能及时看到）。\n 同时在信息服务平台的“教学邮箱”中，可以直接找到所有老师的教学邮箱。\n信息服务平教学邮箱\n需要注意：这个教学邮箱老师可能不会经常回复。\n\r\r\r\r2. 联系老师，提出课程扩容申请\n\r接下来就用自己的邮箱给老师发送申请了。\n【怎么写就是自己的事了，在表达出自己想要申请课程扩容上随意发挥就行w……\n如果实在不会写这里有段个人的羞耻x示例……\r其实随便写写就行了真的不用看的orzzz……\r悄悄看就行不用仿照着写！……\n最后老师那边也只简单回了「你写申请，我签字，然后交到……那去」这样一句话……\n所以根本不会看你具体写了什么乱编就行！……\n而且之前是先通过教务邮箱给三位老师发了一遍，结果一直没回……\n后面再重新发到“教师信息”所写的邮箱里……\n\r\r\r\r\r\r\r\r3. 等待老师回复，写出书面申请，交给老师签字并交到指定地方\n\r老师如果回复同意后，一般会让你写书面申请然后给他签字，最后再交到指定地方完成课程扩容。\n书面申请一般就简短的写：「因为转专业原因需要学习该课程，但因人数已满故提出课程扩容申请」之类的，\n然后根据老师要求执行就行。\n\r\r4. 课程扩容成功，在“网上选课”中选择课程\n\r注意课程扩容只是扩个容，还是需要自己去选课的。\n交到指定老师处后他会给你说好久扩容成功，到时候注意选择就行。\n【按概率来说应该不会出现刚扩容成功就被别人选走的情况吧【【……\n\r\r 一般老师可能不会及时回复邮件，（特别是教学邮箱）\n【个人这里有位老师在教学邮箱里过了8天才回复……\n所以可以同时找多个老师同时提出申请。（个人就找了三位老师一起提出了申请）\n【不过到时候怎么处理其他老师的答复就看自己的了……\n\r 需要注意：\n整个课程扩容过程必须在选课阶段完成，所以请根据选课时间段进行合理安排。\n避免出现老师回复时间过长导致申请扩容后却不能选课的情况。\n如果所问的老师实在都没回复，可以考虑找对应班级的同学询问老师的联系方式、或去老师所在学院的教务处询问信息等方法。\n【总之办法是自己想出来的，转专业要处理的事可远不止这些啊【拍……\n\r 超学分 需要注意：\n超学分申请并没有明确通知和文件规定其操作流程，\n并且原作者也并没有成功申请超学分。\n所以对该申请项的成功率不予保证。\n\r 针对同时选原专业课和准入课会超过学分上限的同学来说，可以去尝试一下申请超学分。\n申请流程\n1. 下载“超学分选课申请表”\n\r超学分选课申请表在“教务处 - 表格文档”中搜索“超学分”，\n可以找到“超学分选课申请表”。\n超学分选课申请表\n点击此处下载文档\n\r\r 或者在教学服务网上办事平台也可以看到超学分选课的申请，\n【但可以看见这里面相关规章制度都是空的，所以就很迷惑【……\n\r\r2. 填写表格，并找自己学院的班导师和教务处签字\n\r按照表格要求填写好表格后，\n需要在“导师意见”和“院系意见”处分别找班导师和教务处老师进行签字。\n可能部分班级不存在班导师（比如个人原来的班级就没有班导师），这个时候可以去交表的地方（教务处排课中心 - 综合楼222）去询问一下。\n\r\r个人在这一步找教务处签字的时候，被老师告知：\n「大一申请超学分成功几率很小，一般都是给大二大三转专业或其他情况申请用的。」……\n再加上过程很麻烦，所以最终放弃了申请……\n但由于个人也没去最终验证，所以不排除还是有申请成功的可能……\n\r\r\r\r到指定地方呈交表格\n\r填写完毕后，到表格所写的“教务处排课中心综合楼222”交上表格。\n之后的流程请听那边的老师安排或者去询问，个人并不是很清楚。\n\r\r\r\r 因为不存在明确通知，有关超学分申请存在疑惑可以找辅导员、学院教务处或者教务处排课中心咨询一下。\n\r 表格中提到截止时间为“每学期开学第一周周五前”。\n\r 其他建议 1. 英语六级 对于部分要求英语四级的专业，\n其实六级的情况也是会有影响的。（在申请的时候有填写栏，并且面试的时候可能会问）\n所以多准备一下六级考试也是准没错的。\n四级和六级虽然感觉上会难很多，\n但其实差异不是特别大，\n稍微准备一下的话过应该都是没问题的。\n个人准备六级的时候都还没四级一半努力，所以考完试的时候很慌……\n结果成绩下来比四级考得还高，所以大家也不用太担心啦hhhh……\n\r 2. CSP认证 在之前已经讲过了，\n只是再提醒一下大一下一般还有一次考试机会，注意关注。\n二.Ex、大一至大二的暑假 将这个时间段单独提出来说，\n主要是转专业是在这个时间段去申请的。\n需要注意的通知 在暑假的时间里，会发送关于正式开展转专业工作的通知。\n请注意关注教务网或者相关通知群里的消息，避免错过申请。\n\r 当然可申请时间也很长，不用太着急就是。\n1. 「关于……年本科生转专业相关工作的通知」 一般在暑假早期就会发送转专业通知。\n这则通知会介绍的内容有：\n 网上申请方式 时间安排 申请年级及相关要求  2021年 转专业相关工作的通知\n可以看到都有很详细的介绍，所以按照通知流程进行就行，这里就不再详细介绍了。\n\r 以往通知链接：\r 关于开展2021年本科生转专业相关工作的通知 - 2021/7/23 关于2020年本科生转专业相关工作的通知 - 2020/7/15 关于2019年本科生转专业相关工作的通知 - 2019/7/11  \r *2. 「关于……年本科生转专业工作时间调整的通知」 有可能因为疫情等原因，转专业工作时间出现时间变动。\n最主要可能是因为返校延期，所以会导致转专业时间变动，\n如果各位也有延迟返校情况的话注意看教务有没有相关通知就行。\n以往通知链接：\r 关于2021年本科生转专业工作时间调整的通知 - 2021/8/27  \r 三、行——大二上学年 行 —— 尽情展翅高飞吧、姬雏鸟\n\r 进行阶段 转专业进行的过程都会有很明确的通知，\n一般来说会以短信的形式进行通知，同时在目标学院教务处也会发送通知，\n按照通知流程进行就行。\n【如果在哪一阶段没有收到任何通知，那么很遗憾，极大可能是自己已经被刷下来了……\n这里主要把各类考核列举一下，同时提供之前的样例供大家准备。\nStep. 1 - 初审 在暑假提交转专业申请后，会对你个人进行初步的审核，\n具体方式这里也不清楚，估计应该是以原专业课和准入课的成绩来审核。\n这一步中便会筛选出部分同学，再进行之后的考核工作。\nStep. 2 - 各种考核 如果初审通过，则会收到短信通知，代表拥有进一步考核的资格，\n届时便请按照流程，一步步进行考核。\n笔试 由于个人转专业没有笔试环节，正在询问其他转专业同学。此部分待补充……\n\r 机考 机考，全称“C语言程序设计机考”，\n主要考察C语言的掌握情况。\n其考察范围到链表为止，\n并且不涉及对算法的考察，只考察基本的语言熟练程度。\n具体考察范围可以去购买一本《》，从目录里看，一直到链表之前的内容就是考试范围。\n如果之前有程序设计经验，比如参加过NOIP信息学竞赛等，那应该机考问题不大。\n需要注意：\n机考原则上要求的是用C语言编写。\n但大部分之前有经验的同学可能用的都是C++，\n而C++与C还是有一定区别的，\n有些区别甚至很怪，如果不事先去了解的话可能并不会知道错哪了。\n虽然个人在考试过程中，听到老师说“如果实在只会写C++，那就先用C++写着”这一说法，\n但个人还是建议不要冒这个险，或者具体情况请问好老师再决定。\n\r 总结一下C与C\u0026#43;\u0026#43;在机考范围内的常见区别\r注意这里所总结的只能保证对于机考来说尽量全面，如果不放心还请看书去了解。\n\r\r1. 基本数据类型、函数等操作的区别\r在C++中存在，而C没有的机考常用特性：\n 数据类型：bool、string，以及其他的STL库的容器。 输入输出函数：cin、cout 有关内存分配的运算符：new、delete  注：C中内存分配运算符为malloc和free，有关这两个的使用方式请翻阅相关资料。【注意链表会考这两个东西哦！……\n\r\r 引用：\u0026amp;在C中不存在。 有关for循环：C中不能直接在for中定义变量。\n也就是for (int i=1; ...)是不允许的，只能int i; for (i=1; ...)。  2. 头文件的区别\rC++的头文件格式一般为cstdio、cstring、cmath等cxxx，\n而C的头文件格式为stdio.h、string.h、math.h等xxx.h。\n特别提醒：\nC++中的万能头文件bits/stdc++.h，在C里面不存在！\n【所以一直在C++里偷懒没背头文件的同学可要去背一下了xd……\n\r\r3. 结构体的区别\r用strcut {...} typeName定义的结构体类型，\n在C++中可以直接用类型名定义变量；\n而C中前面必须加上struct。\nC struct studentType { int ID, score; char name[10]; }; struct studentType stu; C++\nstruct studentType { int ID, score; char name[10]; }; studentType stu; \n 同时，在C++中strcut内可以带函数，\n而C中的struct仅能有数据。\n\r\r 2021年 信息学院机考例题\r【我知道你们最关心的其实就是有没有样题.jpg……\n个人将我参加机考时的题目稍微记了下，在这里写出来供大家参考。\n顺序并不代表题目难度。\n本来机考是6道题，但个人实在想不起来最后一道题，但难度肯定不会很大。【不然我怎么会想不起来呢2333……\n\r\r第一题 - 成语接龙\r题目 不断输入一个四字成语，判断其首字跟上一个输入的成语的末字是否相同，\n如果相同则一直判断下去，直到判断出不相同则终止判断。\n第一次输入会给出两个成语，判断第二个的首字与第一个的末字是否相同。\n输入输出样例 第一组 输入 国士无双 双立直 直暴雪月花 花风月雪 雪碧 碧蓝幻想 想玩最终幻想十四六点零 铃原露露 输出 正确，请继续输入 正确，请继续输入 正确，请继续输入 正确，请继续输入 正确，请继续输入 正确，请继续输入 错误，游戏结束 \r第二组 输入 情人节什么的没啥兴趣啊 没啥兴趣是骗你的 输出 错误，游戏结束 \r分析与标程 考点：\n 字符串处理  没什么好说的吧，就用两个字符串while判断就行。\n但需要注意的是：\n同时对于中文的处理，一个中文是占两个char空间的（这个题目中提醒了的），\n所以判断条件为str1[len-2]==str2[0] \u0026amp;\u0026amp; str1[len-1]==str2[1]。\n同时C中没有string，要用char []，\n 标准代码：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;int main() { char str1[100], str2[100]; scanf(\u0026#34;%s%s\u0026#34;, str1, str2); while (str1[strlen(str1) - 2] == str2[0] \u0026amp;\u0026amp; str1[strlen(str1) - 1] == str2[1]) { printf(\u0026#34;正确，请继续输入\\n\u0026#34;); strcpy(str1, str2); scanf(\u0026#34;%s\u0026#34;, str2); } printf(\u0026#34;错误，游戏结束\u0026#34;); } 第二题 - 求解立方根\r题目 因为个人记不清这道题原题如何，不保证此题的数学原理一定正确，如有错误请指正。\n\r\r对于一个数$A$，求其立方根，可以用牛顿迭代法算。\n其公式为：\n$$x_{n+1}=x_n+\\frac{1}{3}(\\frac{A}{x_n^2}-x_n)$$\n其中$x_1$可以取任何数（存疑），\n在这里我们规定取为$A$。\n当$x_{n+1}$和$x_n$相差不超过$10^{-6}$时，\n将$x_{n+1}$作为立方根结果输出。\n输入输出样例 第一组 输入 233 输出 6.153449 \r分析和标程 考点：\n 迭代  按照题目要求不断迭代就行。\n需要注意：C中math.h里的abs对于浮点数无效，需要使用fabs来求浮点数的绝对值。\n\r\r 标准代码：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;math.h\u0026gt;double f(double x, double x_old) { return x_old + (x / x_old / x_old - x_old) / 3.0; } int main() { double x; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;x); double x_old = x, x_new = f(x, x_old); while (fabs(x_old - x_new) \u0026gt;= 1e-6) x_old = x_new, x_new = f(x, x_old); printf(\u0026#34;%lf\u0026#34;, x_new); return 0; } 第三题 - 打印字母金字塔\r题目 给定一个字符c，限定为一个大写字母\n打印出一个恰出现该字符的字母金字塔。\n金字塔第$i$层是由以大写字母表顺序第$i$个位的回文串，\n例如第$5$层即为ABCDEDCBA。\n如对题意不了解请看输入输出样例。\n输入输出样例 第一组 输入 5 输出 A ABA ABCBA ABCDCBA ABCDEDCBA \r第二组 输入 8 输出 A ABA ABCBA ABCDCBA ABCDEDCBA ABCDEFEDCBA ABCDEFGFEDCBA ABCDEFGHGFEDCBA \r分析与标程 无分析，直接std。\n#include \u0026lt;stdio.h\u0026gt;int main() { int n, i, j; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (i = 1; i \u0026lt;= n; i++) { for (j = 1; j \u0026lt;= n - i; j++) printf(\u0026#34; \u0026#34;); for (j = 1; j \u0026lt;= i; j++) printf(\u0026#34;%c\u0026#34;, j + \u0026#39;A\u0026#39; - 1); for (j = i - 1; j \u0026gt;= 1; j--) printf(\u0026#34;%c\u0026#34;, j + \u0026#39;A\u0026#39; - 1); printf(\u0026#34;\\n\u0026#34;); } } 第四题 - 数组统计\r题目 用指针的方式来实现动态数组。\n动态数组：即没有事先申明数组大小的数组，根据数组个数动态分配空间来存储。\n\r\r刚开始会先读入数据个数$n$，并读入这$n$个整数，\n请初始化该动态数组，并将数据存入到动态数组中。\n接下来将一直读入整数，直到读入到0为止，\n需将读入的所有有效数据（即除去最后的0）存放到该动态数组中。\n当读入完毕，分别统计该数组大于零和小于零元素的个数，并将其输出。\n输入输出样例 第一组 输入 5 -1 3 2 0 1 1 3 -1 -1 0 输出 大于0的元素有: 5 小于0的元素有: 4 \r第二组 输入 0 4 5 -1 3 6 -1 7 0 输出 大于0的元素有: 5 小于0的元素有: 2 \r分析与标程 考点：\n 内存分配 指针表示数组  主要需要掌握malloc和realloc两个函数来实现动态数组，\n具体使用方法可以看书或其他资料，这里就不再具体讲解了。\n虽然这题可以完全不用数组来做（直接边读入边统计），但听说老师不仅只看机器评分，还会看你的程序实现方式。所以为了保险期间请严格按照题目要求做。\n\r\r 标准代码\n#include \u0026lt;malloc.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;int main() { int n, i, cnt = 0; //cnt统计数组元素个数 \tscanf(\u0026#34;%d\u0026#34;, \u0026amp;n), cnt = n; int *array = (int *)malloc(sizeof(int) * n); //初始化：给动态数组分配n个int类型的内存 \tfor (i = 0; i \u0026lt; n; i++) scanf(\u0026#34;%d\u0026#34;, array + i); //接下来将一直读入到0为止 \tint num; scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); while (num != 0) { array = (int *)realloc(array, sizeof(int) * (++cnt)); //动态数组重新分配内存，增加一个int类型的内存 \tarray[cnt - 1] = num; scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); } //统计大于小于0元素个数 \tint less = 0, great = 0; for (int i = 0; i \u0026lt; cnt; i++) if (array[i] \u0026gt; 0) great++; else less++; printf(\u0026#34;大于0的元素有: %d\\n小于0的元素有: %d\u0026#34;, great, less); } 第五题 - 学生系统\r题目 用链表结构来实现一个学生管理系统。\n该系统需要储存学生的学号和成绩两个信息，\n并支持“创建（初始化）”、“插入”和“删除并清空内存”三个基本操作。\n 刚开始创建学生系统，\n需要读入第一个学生的学号和成绩，\n然后输入Y以继续创建学生，输入其他字符终止创建。\n然后开始插入一位学生。\n先读入插入学生的学号和成绩，\n然后读入插入位置，输入要将其插入到学号为多少的学生之后，其中-1代表插入到最前，\n若插入位置的学号不存在，则插入到最后。 插入完成后输出所有学生信息。\n然后开始删除一位学生。\n输入删除学生的学号，\n若存在该学号学生，则输出该学生成绩并从系统中删除和清空内存，\n否则输出未找到该学生。\n具体输入输出格式看后样例。\n输入输出样例 由于为交互式程序，所以将输入与输出合并，并在输入部分前标上\u0026gt;来表示为输入。\n\r\r第一组 请输入学生学号和成绩： \u0026gt; 1 100 创建成功，请输入\u0026#34;Y\u0026#34;继续创建，输入其他字符进入下一步。 \u0026gt; Y 请输入学生学号和成绩： \u0026gt; 2 98 创建成功，请输入\u0026#34;Y\u0026#34;继续创建，输入其他字符进入下一步。 \u0026gt; Y 请输入学生学号和成绩： \u0026gt; 3 77 创建成功，请输入\u0026#34;Y\u0026#34;继续创建，输入其他字符进入下一步。 \u0026gt; n 请输入插入学生的学号和成绩： \u0026gt; 5 96 请输入要将该学生插入到哪位学生之后（输入其学号，-1代表插入到最前面）： \u0026gt; 2 插入成功。 当前所有学生信息如下： 学号：1 成绩：100 学号：2 成绩：98 学号：5 成绩：96 学号：3 成绩：77 请输入要删除学生的学号： \u0026gt; 2 被删除的学生的成绩为：98 当前所有学生信息如下： 学号：1 成绩：100 学号：5 成绩：96 学号：3 成绩：77 第二组 请输入学生学号和成绩： \u0026gt; 3 199 创建成功，请输入\u0026#34;Y\u0026#34;继续创建，输入其他字符进入下一步。 \u0026gt; Y 请输入学生学号和成绩： \u0026gt; 2 188 创建成功，请输入\u0026#34;Y\u0026#34;继续创建，输入其他字符进入下一步。 \u0026gt; n 请输入插入学生的学号和成绩： \u0026gt; 9 100 请输入要将该学生插入到哪位学生之后（输入其学号，-1代表插入到最前面）： \u0026gt; -1 插入成功。 当前所有学生信息如下： 学号：9 成绩：100 学号：3 成绩：199 学号：2 成绩：188 请输入要删除学生的学号： \u0026gt; 2 被删除的学生的成绩为：188 当前所有学生信息如下： 学号：9 成绩：100 学号：3 成绩：199 第三组 输入学生学号和成绩： \u0026gt; 1 100 创建成功，请输入\u0026#34;Y\u0026#34;继续创建，输入其他字符进入下一步。 \u0026gt; n 请输入插入学生的学号和成绩： \u0026gt; 2 99 请输入要将该学生插入到哪位学生之后（输入其学号，-1代表插入到最前面）： \u0026gt; 233 没有找到该学号学生，将插入到最后。 插入成功。 当前所有学生信息如下： 学号：1 成绩：100 学号：2 成绩：99 请输入要删除学生的学号： \u0026gt; 233 未找到该学生 当前所有学生信息如下： 学号：1 成绩：100 学号：2 成绩：99 分析与标程 考点：\n 链表 内存分配  标准的链表操作。\n有关链表部分可以看书学习，\n这部分考中的比例还是很大的。【因为最难的差不多就这个了……\n提醒：\nfree()后的指针并不会置为NULL，且原地址的数据会保留（只是释放个占用标记而已）\n所以发现free()后数据仍在存在（甚至可以访问），并不是没有成功释放，请不要在这担心。\n\r\r个人考试就在这里？了好久，怎么释放了数据还在甚至还能读取。\n\r\r #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;malloc.h\u0026gt;struct typeStudent { int ID, grade; struct typeStudent *next; } *stu; void create() { stu = (struct typeStudent *)malloc(sizeof(struct typeStudent)); //分配头节点 \tstruct typeStudent *pnt = stu; int _ID, _grade; char cmd; printf(\u0026#34;请输入学生学号和成绩：\\n\u0026#34;); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;_ID, \u0026amp;_grade); pnt-\u0026gt;next = (struct typeStudent *)malloc(sizeof(struct typeStudent)); pnt-\u0026gt;next-\u0026gt;ID = _ID, pnt-\u0026gt;next-\u0026gt;grade = _grade; pnt = pnt-\u0026gt;next; printf(\u0026#34;创建成功，请输入\\\u0026#34;Y\\\u0026#34;继续创建，输入其他字符进入下一步。\\n\u0026#34;); //以下为循环创建 \tcmd = getchar(), cmd = getchar(); //需要注意：回车也算一个字符，所以需要连续两次getchar() \twhile (cmd == \u0026#39;Y\u0026#39;) { printf(\u0026#34;请输入学生学号和成绩：\\n\u0026#34;); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;_ID, \u0026amp;_grade); pnt-\u0026gt;next = (struct typeStudent *)malloc(sizeof(struct typeStudent)); pnt-\u0026gt;next-\u0026gt;ID = _ID, pnt-\u0026gt;next-\u0026gt;grade = _grade; pnt = pnt-\u0026gt;next; printf(\u0026#34;创建成功，请输入\\\u0026#34;Y\\\u0026#34;继续创建，输入其他字符进入下一步。\\n\u0026#34;); cmd = getchar(), cmd = getchar(); } pnt-\u0026gt;next = NULL; //末节点后继设为空 } void insert(int insert_ID, int _ID, int _grade) { if (insert_ID == -1) //插入为第一个节点 \t{ struct typeStudent *ins = (struct typeStudent *)malloc(sizeof(struct typeStudent)); ins-\u0026gt;ID = _ID, ins-\u0026gt;grade = _grade; ins-\u0026gt;next = stu-\u0026gt;next, stu-\u0026gt;next = ins; printf(\u0026#34;插入成功。\\n\u0026#34;); return; } struct typeStudent *pnt = stu-\u0026gt;next; while (pnt-\u0026gt;next != NULL \u0026amp;\u0026amp; pnt-\u0026gt;ID != insert_ID) pnt = pnt-\u0026gt;next; if (pnt-\u0026gt;ID != insert_ID) printf(\u0026#34;没有找到该学号学生，将插入到最后。\\n\u0026#34;); //找到位置，开始插入 \tstruct typeStudent *ins = (struct typeStudent *)malloc(sizeof(struct typeStudent)); ins-\u0026gt;ID = _ID, ins-\u0026gt;grade = _grade; ins-\u0026gt;next = pnt-\u0026gt;next, pnt-\u0026gt;next = ins; printf(\u0026#34;插入成功。\\n\u0026#34;); } void print() { struct typeStudent *pnt = stu-\u0026gt;next; while (pnt != NULL) printf(\u0026#34;学号：%d 成绩：%d\\n\u0026#34;, pnt-\u0026gt;ID, pnt-\u0026gt;grade), pnt = pnt-\u0026gt;next; } void delete (int del_ID) { struct typeStudent *pnt = stu-\u0026gt;next, *pnt_prv = stu; while (pnt != NULL \u0026amp;\u0026amp; pnt-\u0026gt;ID != del_ID) pnt = pnt-\u0026gt;next, pnt_prv = pnt_prv-\u0026gt;next; if (pnt == NULL) printf(\u0026#34;未找到该学生\\n\u0026#34;); else { printf(\u0026#34;被删除的学生的成绩为：%d\\n\u0026#34;, pnt-\u0026gt;grade); pnt_prv-\u0026gt;next = pnt-\u0026gt;next; free(pnt); //释放内存语句 \t} } int main() { //创建操作 \tcreate(); //插入操作 \tint ins_ID, ins_grade, after_ID; printf(\u0026#34;请输入插入学生的学号和成绩：\\n\u0026#34;); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;ins_ID, \u0026amp;ins_grade); printf(\u0026#34;请输入要将该学生插入到哪位学生之后（输入其学号，-1代表插入到最前面）：\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;after_ID); insert(after_ID, ins_ID, ins_grade); //输出信息 \tprintf(\u0026#34;当前所有学生信息如下：\\n\u0026#34;); print(); //删除操作 \tint del_ID; printf(\u0026#34;请输入要删除学生的学号：\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;del_ID); delete (del_ID); //输出信息 \tprintf(\u0026#34;当前所有学生信息如下：\\n\u0026#34;); print(); } \r\r 面试 我相信大部分同学关心的肯定是面试这一环节，\n因为之前肯定面试经验很少，对这一新事物肯定还是充满未知的。\n但其实转专业的面试只算大学众多面试中很平常的一个，放松心态去应对就行。\n大致流程和简单说明如下：\n  自我介绍环节\n对于自我介绍，没有什么特别要求的，\n就简单介绍下自己的情况，然后自己转这个专业的原因，自己在这专业上的特长之类的。\n  面试老师提问环节\n提问的话老师也会根据你的情况问一些相应问题，\n考察你的学习能力、对着专业的适应情况、心理素质等方面 主要还是考自己随机应变【口胡x……】的能力，\n   而每个环节的时间可能会在面试前或当天告知，\n但也可能会根据当时面试人数动态变化。\n个人原来参加面试的时候，就因为人数过多时间太长所以后面缩短了面试时间。\n\r 有提到说自我介绍可能会以英文的形式进行（尤其是计院和信院）。\n不过在2021年信院（之后的计院）面试的时候，却是用的中文进行，\n不明确是因为时间不够还是什么原因。\n但总之有时间的话最好还是准备一下英文自我介绍为好。\n\r 2021年 信息学院面试大致内容\r 用中文自我介绍，时长1min 原专业的相关信息\n例如：我原专业是学心理的，问我能否用所学知识帮助同学。【然而才学一年我也不懂什么啊除了知道几个名词外orzzz…… 英语四六级情况\n这里六级的成绩在填报申请的时候可能还没有出，所以面试的时候可能会额外问一下。 个人能力方面询问\n例如：问我之前参加NOIP竞赛的经历，以及我说我运维过服务器，问我怎么维护的之类的能力问题。 个人其他方面的询问\n可能还会问点其他信息，比如问过我高中是哪的之类的，见招拆招即可x。  大致就这些方面，整个流程还是很简单的。\n最主要的是面试自己是坐着的！就不怎么用怕自己紧张得发抖了。【真是帮大忙了√……\n\r 转后事项 如果看到这里，那就证明你已经收到最终的转专业成功的通知了，恭喜！\n但成功后却千万不能松懈，恰相反，转成功后要注意的事可比转前还多得多。\n如果稍微错过一些重要的事，反而可能对后面的学习生活造成较大的影响。\n所以对于转专业成功的同学来说，请务必注意这一部分的内容。\n转专业成功后的各种事项十分繁琐，\n自己需要花费大量精力去注意这些事，\n否则会对自己今后的学习和心情造成不定程度的影响。\n\r\r  首先对于原专业的一些群先不要退，因为之后可能还会有其他事务在原专业那边处理。\n尤其是评奖评优相关的，是在原专业那边评选。\n一般来说转专业成功后，对应学院都会通知加入“转专业学生群”，用以通知后续的工作安排。\n但老师的负责态度怎么样，这个却有较大差异了。\n不一定所有事项都会通知得到，甚至部分学院只告知一两件事后便杳无音讯，\n个人在这里将能考虑到的转专业后要注意的事项都罗列在这里。\n选课 转专业结果公示时，基本上就是第三次选课已经进行了几天的时候。\n所以请抓紧时间在这次选课机会中选择正确的课程。\n在将本学期的所开设的优选课选完之后，还需要去补修大一学期没修的课程。 这个时候需要自己根据所转入专业的培养方案，\n去找到自己有哪些没修的并在这学期开设的课程，然后选上。\n相信培养方案大家应该都会读了，这里就不再讲解了。\n【实在不会再私聊找我我帮你看吧.jpg……\n需要注意：\n一定要认真看清楚有哪些课程还没修，\n一个个核对一遍，然后记下来。\n最好能大二一年补完就这年补完。\n同时这学期的课程也请认真核对一下，\n有可能会出现感觉自己选齐了但结果少几门课的情况。\n\r 因为个人就在刚转入的学期漏选了大二上开设的“数电实验”，只能拖到大三上的时候再修了orz……\n\r  需要根据自己的时间安排来调整课表，\n由于很大程度存在冲突，所以本学期优选课程选不上优选班也没关系。\n但还是要注意如果不是卓越班最好不要选到卓越班去。\n【别看了那个概率论选到茅班的还是我qwqqq……\n课程代替 课程代替，是指用在原专业学过的一些课程，来代替本专业需要修读的课程，\n代替成功后，便不需要再补修该课程。\n被代替课程分数将以原课程的得分为准，即尊重原始成绩。\n 一般转专业成功后的转专业学生群会通知课程代替的事项和文件，\n请根据各自学院的课程代替情况”来申请相应的课程代替。\n课程代替申请表也应该会发送到群文件中，\n下载后按照情况和要求填写即可。\n课程代替认定表\n点击此处下载文档\n\r 还会有其他注意事项，比如截至时间、只能打印、一式两份等，\n注意看清楚要求。\n举个例子：\r如2021年计算机与人工智能学院的课程代替情况如下图：\n2021年 - 计算机与人工智能学院 - 课程代替情况\n对于个人而言，只能申请一下两个课程代替：\n 原专业的新生研讨课“心里世界探秘” ——\u0026gt; 代替本专业的新生研讨课“计算机学科前沿导论” 原专业的实习课程“工程训练”+“计算机程序设计基础” ——\u0026gt; 代替本专业的实习课程“软件设计实习”  \r 冲突选课 冲突选课，是针对有一门课程因时间冲突的原因实在无法修读（所有该课程开设时间均被其他课程占用），\n可以该课程，和占用该课程开设时间的另一课程进行冲突选课申请。\n冲突选课的课程表可以直接在教务处的“表格文档中”下载。\n课程冲突申请表\n点击此处下载文档\n\r  学院不一定会发冲突选课申请的信息，如没有需要自己去了解。\n各种填写要求表格里会说明，\n同时教务处也会发送关于“冲突选课”的通知，其通知名的格式大致为： 「（……学期）冲突选课流程」\n\n有关冲突选课的通知\n需要注意：\n冲突选课存在截至时间，一般为第三次选课结束后一周内（不一定刚好为一周）。\n同时，该截至时间不一定通知在“冲突选课流程”的通知里，\n也有可能存在于第三次选课的通知内。\n比如2021年的就是这种情况：\n第三次选课通知冲突选课流程通知\r\r 所以个人就以为截至时间如通知上所说的整整一周内，结果恰好28号过去的时候结束不予受理了【……\n\r  个人并无冲突选课申请成功后的经验与信息，以下所述内容可能不准确，如有错误请联系我修改！\n\r 申请成功后，两门课程都会被选择修读（在选课结果中可查看到），\n但只需要选择申请表所选的一门课程进行修读，\n另一门课程则通过自学等方法学习。\n但只是不用参加课堂，可能老师还会有别的要求。\n在期末的时候两门课程都需要参加期末考试，可能会存在冲突。\n有关更多冲突的信息请询问冲突两科（特别是没选上一课）的老师寻求解决方法，\n比如问：\n 申请成功后，没选上的这门课我还要做什么作业，或者有什么要求吗？ 如果期末考试两门课冲突我该如何处理？  等问题。\n宿舍更换 转专业后（其实不转专业也可以）理论上是可以申请调换宿舍的。\n换宿舍一事转专业通知群里应该会通知，\n到之后只需要填写一张表，按照表格操作即可。\n本科生调整宿舍申请表\n点击此处下载文档\n\r 但需要注意：\n犀浦校区宿舍可能比较紧张，\n因此部分学院可能仅支持从九里校区调换到犀浦校区的申请。\n具体调换情况还请询问自己专业的转专业通知群。\n\r 至于表格中的“意向房间号”这一项，由于个人没有申请过不清楚怎么知道还有哪些宿舍有空位，\n估计只能克服社死去问还不认识的班上同学了吧【？……\n评奖评优  评奖：指申请国家奖学金、国家励志奖学金等奖学金项目。 评优：指评选三好学生、优秀学生干部等荣誉称号。  需要注意的是：\n虽然你这年转入到别的学院去了，\n但你的评奖评优还是会在原专业进行。 这点转专业通知群肯定会通知很多次的。\n但你的一些相关材料已经转到新的学院去了，\n也就是说我们会反复在原学院和现学院进行联系，完成评奖评优。\n因此原学院的一些通知群先不要退，\n到时会根据原学院的评奖评优流程和要求进行操作，\n然后有什么问题及时询问现在学院的辅导员，并跟原学院的辅导员进行联系。\n有关步骤可以看下图：\n转专业评奖评优申请流程\n团组织相关 由于自己的团或党组织的一些材料信息还在原专业那边，\n所以还需要自己花时间去转移过来。\n大致为以下两个方面\n1. 团组织关系转接 对于共青团员，自己的团组织还会在原专业班级上的团组织中，\n需要自己登陆共青团的智慧团建系统，\n在“关系转接”中将自己的团组织转接到新班级的团组织。\n需要同时跟两边的团支书说明一下，通过审核后才能成功转接。\n2. 入党材料转移 如果自己在之前向原专业提交了入党申请书并正式进入入党流程，\n需要自己将在原专业入党的材料交到转入的专业中。\n转专业群中应当会通知相关信息，\n不同学院的要求可能不同，请根据本学院的要求来执行。\n 至大二时完整材料如下：\n 入党申请书 思想汇报（递交入党申请书后原则上是三个月一篇，因此应交四篇） 谈话记录表（入党申请书提交后一个月内会进行） 积极分子推荐表（成为积极分子后会有此表） 结业证书（经过党课培训并完成结业考试后会颁发） 积极分子考察登记表（大二的时候会有一本小册子）  根据自己的入党进度以及学院要求，递交自己目前所有拥有的材料。\n课程相关 有些在原专业没有上过的课，可能会有一些特殊要求，\n尤其是一些分Ⅰ、Ⅱ的课程，在大二的时候已经进入Ⅱ的学习了，\n这时班上可能不会再通知相关要求，导致自己并不了解其课程。\n在这里将个人所知道的一些有特殊要求和操作的课程列举出来，避免大家因为不了解而错过很多信息。\n大学物理实验 如果之前没有上过大物实验的话，这门课程需要特别注意的是：\n需要自己额外在其教学网站上选择实验。\n物理实验中心网站链接\n\r 这门课并不是在信息服务平台选好后就按照那个时间去上就行，\n还要自己去选择8个实验。\n并且选课所示的那个时间只是占位用的，并不是真正的上课时间，\n最终的上课时间是根据自己所选实验决定的。\n 在开学日附近，实验中心网站会发布关于实验选课的通知，\n届时教务处也会转发。\n (2021年)关于大学物理实验II课程中心网站选课的通知  这则通知会告诉如何进行实验选课以及相关注意事项，\n但因为时间截至一般会在转专业工作完成之前，所以转专业同学并不能按照正常流程选择实验。\n 对于转专业同学，会额外设置一个时间集中处理。\n转专业工作结束后，中心会再次发布一条集中处理的通知。\n届时教务处也会转发。\n (2021年)关于最后一次集中处理中心系统选课问题的通知  但由于之前对这门课并不了解，自己也不可能整天盯着教务的通知看它一小时……\n所以很容易错过这则消息导致自己并没有选课……\n【别骂了这里的注意事项全是我的血泪史好吧'_\u0026gt;'……\n因此个人决定把这个也特别提醒出来……\n能帮到一位同学是一位……\n\r  但如果也有同学像我一样没有按时选上课，也是可以去单独申请处理的。\n首先需要找樊代和老师说明自己的情况，其办公室在6206。\n然后经过一阵质问【】后，\n樊老师应该会让你写一份情况说明，并找自己学院教务处盖章。（可以打印）\n之后拿去给樊老师看，他应该就会让你带着情况说明到6215b去找马老师，\n到时候去找马老师后，他就会帮你处理了。\n也许可以不用找樊老师，直接写好情况说明盖章后去找马老师即可……\n点名表扬马老师，麻烦了那么多次【后面因为个人原因选课还冲突了又重新去调整……\n依然很热心地帮忙解决处理这样……\n目前大学中遇见的最好的一位老师可以说是了√【称赞……\n\r  正文部分到此结束\n  相关事件 事件一 —— 必修未修完导致转专业被拒 是发生在2021年转专业的一件事件，\n事件本身还是比较迷惑（因为学生和学院两方面其实都挺无奈的），对当事人造成的后果也还是挺严重的，\n并且重新将按照文件规定的重要性凸显了出来（虽然仍会存在很多冲突），\n具有参考警醒价值故将当时事件的聊天记录分享一下。\n已做打码等处理。如仍有记录内同学觉得侵犯隐私请联系我，我会将聊天记录截图删除！\n\r 由于内容较多做折叠处理\r顺序为从左到右，关键信息已经用红框标出。\n事件聊天记录 1 事件聊天记录 2 事件聊天记录 3\n\r 太长不看系列：\n就是一位同学计划转电气，本来都上了转专业的名单了，但最后却电气学院被告知不让转入了。\n原因是电气教务查出来了他有原专业的必修课没修。\n但这位并不是故意不修原专业必修课的，而是因为他如果要修全原专业必修课，就会导致学分不够，修不了准入课。\n 虽然转专业要求中明文规定确实“必须通过原专业已完成学期所学全部课程”，也就是把原专业大一要求的所有必修课修完。\n但这时矛盾就发生了：\n 如果要修原专业所有的必修课，就会导致学分不够，使得修不了准入课。 如果不修准入课，又会根据其第一条“申请者必须预修并通过电气工程学院相关专业规定的转专业准入课程”，很明显又会有原因导致转专业失败。  很明显的死循环了。\n悄悄做了张meme……\r循 环 论 证……\r 但关键是：\n确实部分同学并没有严格按照“西南交通大学本科生转专业管理办法”以及各学院转专业细则的基本要求：通过原专业按培养计划已开设的全部必修课和限选课。\n但最终其实大部分学院都没有对这个要求很严格，大部分该录取的还是录取了。【也许也还有这种事故，但个人没在其他地方发现这种情况的出现……\n最主要的是，个人其实就是如上图同学一样的情况，因为要修准入课学分不够就要退掉原专业的部分课程……\n并且咨询了直系学长学姐，说的就是要退原专业的必修课……\n自己也没有去咨询教务，直接按照学长学姐的方式进行选课……\n各种东选西退，才勉强在保证准入课的情况下选择必修课凑到大一年纪满学分（32学分）……\n但这位同学却被这样处理，确实感觉很恐怖与同情，并且也感觉到了转专业机制的混乱……\n也将之前在“了解转专业机制”中写的主要咨询成功转专业的学长学姐改成了咨询教务处……\n还是人家说了算啊果然.jpg……\n\r 当然这种情况也有解决方法，\n其一是“申请超学分”，但前文中我也提到了有关超学分申请的个人经历，不再重复。\n如果申请超学分失败，那么其二，也是最主要的：那就是以后对于这种冲突情况，无论如何都要去 目 标 学 院 的 教 务 处 问 个 清 楚！即便他们态度有多敷衍多恶劣，因为这完完全全关系到自己切身利益。\n去狠狠地质问他们：\n如果我要选相关专业的准入课，那么我的学分不够，就必定会退掉原专业的必修课。那么在这种情况下，我是保证原专业必修课的学习，还是保证准入课的学习？\n\r 抓住加粗的重点问题，没回答清楚就直接反复询问！【最好再录个音嗷，免得到时候没有证据.jpg……\n如果连这个问题都不能好好回答，学生的基本权益都不能保障的话，我觉得这个学院也大概没什么转入的必要了。\n结束语 以上大概就是个人所想到的有关转专业方面的意见和经验了……\n希望能帮助到在这条十分艰苦的路上前行的各位……\n由于个人之前并没有写过这么长的指南方面的文章，所以在排版、叙述上可能存在很多问题……\n希望各位同学们能谅解……\n同时截至写完时大部分内容都是以自己的主观经验来叙述的……\n所以内容上可能存在很大的主观性以及偏差……\n之后会去询问相关同学，并补充和修正部分内容……\n所以，如果有什么建议和指正的话，非常欢迎向我提出！……\n最后，无论如何，\n保持自己的决心，等待并心怀期望吧！……\n\n碎碎念……\r在这次转专业中，个人最终如愿以偿转到了想要去的专业……\n是最初的目标、最本的初心、最纯真最幼稚最深层最内核的那不容别人评价甚至自己不愿提及的梦想……\n但发现也并没有想象的那么高兴，在刚得知消息的时候也极其平静……\n为什么呢？大概被这一年来各种的琐事冲淡了热情吧……\n一大堆想做的事，却不断地被延期被放弃……\n这一切值得吗？……\n我也不知道……\n但我始终明白，我的人生轨迹将依旧如此……\n周期往返……\n仍在前行……\n\r ","date":"2021-10-01T00:00:00Z","image":"https://blog.supersassw.com/p/univ-exchange_major/LagTrain_hue62f4259dd71d906ab5a0418c7202f20_70113_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/univ-exchange_major/","title":"西南交通大学转专业指南……"},{"content":"该笔记还未完成整理，待日后继续整理……\n\r 博弈论 博弈论简介 在OI中，博弈论一般就是两位玩家玩游戏，游戏有一定规则，双方均在这规则之下进行回合制游戏，并且最终一定会分出胜负。\n同时这两位玩家都是超高校级的游戏玩家x，一定会按照当前最优策略进行游戏（就是想方设法让自己赢）。\n而你任务则为试着分析出这两位最终的输赢情况。\n公平组合游戏 OI中所玩的博弈论游戏，几乎都是“公平组合游戏”(Impartial Combinatorial Games, ICG)。\n也就是说：几乎所有博弈论问题都可以建模为基本的ICG来分析处理。\n满足以下条件的游戏是ICG：\n 竞争性：只有两名玩家，且两名玩家交替行动。 公平性：在游戏进程的任意游戏状态，可以执行的行动只取决于当前局面，而与轮到哪名玩家、以前的任何操作等其他因素无关。\n象棋等常见棋类不属于ICG则正是因为这个原因。\n因为每个人只能移动自己势力的棋子，而不是所有棋子。\n使得自己不能移动对方的棋子而执行某一行动，从而使能执行的行动取决于轮到哪名玩家。\n\r 也就是说，两人都有能力让当前游戏状态行动到可到达的所有状态。 不可回溯性：游戏中的同一个游戏状态不可能再次抵达。\n也就是说，ICG为线性游戏，不可能回到之前经历过的某一游戏状态。 有穷性：游戏以玩家无法行动为结束，并一定会在有限步后以非平局结束。  必胜必败状态 首先对于公平组合游戏，我们需要了解两个奇妙的状态，他们是：\n必胜状态\n必胜状态\n必败状态\n必败状态\n 定义  必胜状态：处于该状态的玩家，至少能有一种行动，让接下来的状态变为必败状态留给另一位玩家，使其面临必败。\n一般称必胜状态为N-Position，简称为N状态。部分也称为非奇异状态、非平衡状态。 必败状态：无论怎么行动，只能使接下来的状态变为必胜状态留给另一位玩家，使其必胜。（或者说不可能走到必败状态，使另一位玩家陷入必败从而扭转局势）\n一般称必败状态为P-Position，简称为P状态，部分也称为奇异状态、平衡状态。  以下为了区分必胜必败状态与场上游戏状态（局面），特将“游戏状态”统称为“局面”。\n\r 性质 由定义，我们可以找到必胜必败状态的基本性质，或者说判别必胜必败状态的基本方式：\n 必胜状态：可以走到某一个必败状态。 必败状态：只能走到必胜状态，或说走不到任何一个必败状态。  性质 对于ICG，存在性质：\n性质1：游戏中每一种局面，对处于该局面的玩家来说，只有可能是必胜或必败状态，并且无法逆转局势（也就是不存在不确定状态）。\n\r\n那么由此可以得到推论：\n推论1-1：游戏的开始局面也处于必胜状态或必败状态，因此对于先手玩家来说，其胜负是一开始就被决定好了的。\n\r\n推论1-2：整个游戏的流程是按照：“A处于必胜状态→B处于必败状态→A处于必胜状态→……→A最终获胜”（或者反之）来进行的。\n\r\n关于终止局面的误区：\n 终止局面：无法行动/没有子状态的游戏状态。  不一定最终局面是必败状态，只是因为一般都规定：终止局面为必败状态——当某一方无法行动宣布败北。\n但也完全可以规定终止局面为必胜状态——当某一方无法行动宣布胜利。\n要根据题目游戏规则，确定终止局面是必败状态还是必胜状态。\n\r 如果只听了结论感觉有点疑惑，可以点开这个看看x……\r其实个人对于这里纠结理解了很久，\n主要疑惑就在于：\n 为什么一定只存在必胜或必败状态，而不存在一个中间或不确定状态，此时玩家的行动不会决定结果？ 这给目为什么一开始就决定好了玩家的胜负，不能靠自己的操作改变命运？ 为什么会有必败状态，处于此状态的玩家为什么不能一转攻势？  等等等等之类的问题……\n其实这种疑问主要来自于我们日常玩的游戏都不是ICG，\n并且我们也不是智械文明，很难保证每次都能找到并选择最优策略。\n 首先，对于最难绕过来的第一个问题，其实可以这样想：\n首先如果某状态不是“不确定状态”，又因为游戏最终只有某方胜或败的结果，\n那么该状态肯定就是必胜或必败状态，\n也就是只可能存在：必胜、必败、不确定三种状态。\n这点是可以肯定的吧！……\n那么排列组合，对于某一状态，其子状态（之后可以到达的状态）只有7种情况：\n 全是不确定状态 全是必胜状态 全是必败状态 既有不确定状态、也有必胜状态 既有不确定状态、也有必败状态 既有必胜状态、也有必败状态 不确定状态、必胜状态、必败状态都有  根据两玩家都总会选择最优策略的思想，以及必胜必败状态的定义可以知道：\n 对于情况②，则该状态一定为必败状态（玩家在这里怎么行动，都会让对方必胜） 对于情况③、⑤、⑥、⑦，则该状态一定是必胜状态（玩家在这里只要走向必败状态，就能让对方陷入必败）   所以只有子状态情况为①和④的状态，才能将该状态称为“不确定状态”。\n下面来分析这两种“不确定状态”中玩家的选择：\n由于玩家都要确保自己尽量能赢，所以自己的回合，除非万不得已只能选择必胜状态行动，将胜利拱手让给对方（即自己陷入了必败状态），否则自己肯定打死不走必胜状态。\n因此对于情况④，处于这种“不确定状态”，当前玩家肯定会选择走“不确定状态”。 对于情况①，没什么说的，只能走“不确定状态”。\n这两情况发现什么没？\n就：若处于“不确定状态”，玩家只会选择继续走“不确定状态”！\n那么场面就会变得奇怪了起来：\n明明ICG的定义就说好最终会分出胜负，但却一直处于“不确定状态”。\n因此直接異議あり！断言不可能存在“不确定状态”。\n可能有人最后这里还有点小疑惑：\n如果就让双方就这样一直在“不确定状态”下反复横跳，直到最终有人只能走那个“必胜状态”输掉游戏怎么样？\n请牢记：如果只能走必胜状态，那么该状态就是必败状态了。\n【感觉有点哲学是吧23333……\n\r\r\r\r那么如果第一个问题明白了，其他问题也就好解决了。\n因为不存在不确定状态，命运就像链条一样被决定好了，不然怎么叫必胜和必败呢？\n\r  注意：对于必胜状态和必败状态，我们统一是针对于先手来分析的。\n\r 由此自然而然我们可以想到一种解决博弈问题的思路：\n由题目要求得到终止局面是必胜状态还是必败状态，\n再由终止局面反推，得到某一局面是必胜状态还是必败状态。\n\r 这种思路也就是搜索解法。\n但需要注意的是有可能不能直接分析出终止局面是（先手）必败状态还是必胜状态，\n需要先倒推到终止局面的前驱局面，分析这一局面是什么状态，才能得到终止局面是什么状态。\n或者不用分析终止局面是什么状态，直接由终止局面的前驱局面来倒推分析。\n如下例中的“皇后问题”。\n博弈状态图 我们将每一个局面视为一个节点**，再从每个局面**向它的后继局面连边**，这样就能得到一个博弈状态图。\n结合上面提到的倒推解题思路，我们可以**从终止局面节点搜索，得到各种局面的状态**。\n可将处于必败状态的节点成为P节点，必胜状态的节点成为N节点。\n引例——挪动皇后游戏 游戏规则：\n将一个皇后放在棋盘（任意$n*n$大小）上某一格子内，皇后只能向左、下、正左下（即同时向左和向下走相同格数）走任意格且至少移动1格，最先到达最左下角的玩家胜利。\n 我们就这个引例来分析其博弈状态图。\n先可将局面抽象为皇后在棋盘上的坐标，如$(2,3)$、$(5,5)$。\n则对于任意局面$(n,m)$，其后继局面为：\n $(n-k,m) (k∈N^+)$ $(n,m-k) (k∈N^+)$ $(n-k,m-k) (k∈N^+)$  我们可以用棋盘本身来代表状态图。\n而对于处于坐标$(n,m)$格子上的皇后，其可移动局面即为横向向左，竖向向下、斜向向左下直线的所有格子。\n当前皇后可移动局面（后继局面）\n 那么对于这个问题来说，其终止局面为$(0,0)$。\n而从$(0,0)$反推，其右方、上方、右上方的节点均对于（先手）必胜状态。\n则由$(0,0)$局面易得出处于N状态（必胜状态）的局面，如下图绿色区域表示：\n第一次倒推 - N节点\n接下来根据必胜必败状态的性质，可以发现有且仅有$(1,2)$、$(2,1)$这两点，无论怎么移动都只能到达必胜状态（如蓝箭头所示）。\n因此这两点即为P节点。\n第二次倒推 - P节点\n接下来我们又可以从找到的P节点倒推，得到新的N节点（其右、上、右上的节点，如蓝箭头所示）。\n（为了区别将第一次倒推出的N节点颜色加深了。）\n第三次倒推 - N节点\n 最终这么分析下去，会得到如下博弈状态图。\n挪动皇后游戏 - 推导过程\n挪动皇后游戏 - 博弈状态图\n其中蓝色节点为必胜节点，白色部分为必败节点。\n图片来自于Matrix67的笔记“捡石子游戏、Wythoff数表和一切的Fibonacci数列”。\n\r 可能有同学就会发现，在这里的P节点有点规律的样子，大致好像连成了一条直线。\n其实这个发现是正确的，这个游戏也叫做“威佐夫博弈”（Wythoff Game），将在后面的部分具体讲解。\n作用 对于任何ICG，其都可以转化为一种“有向图游戏”。\n有向图游戏：\n给定一个有向无环图，图中有一个唯一的起点（初始局面），在起点上有一枚棋子。\n两名玩家需要交替地将该棋子沿着有向边进行移动，每次必须移动一步。\n无法移动者（来到终止局面）将被判负（也有可能判赢）。\n\r 具体转换方法为：\n 将每一种局面看成有向无环图的节点。 对于每一种局面，和能合法到达的下一种局面，将这两节点建立有向边。  这样，我们就能将各种博弈问题转化为统一的一种模型，方便我们思考与解决。\n博弈问题种类 参考资料  《博弈论全家桶》（ACM / OI）（超全的博弈论 / 组合游戏大合集） 捡石子游戏、 Wythoff 数表和一切的 Fibonacci 数列  ","date":"2021-07-17T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-game_theory/71973806_p1_hu8cb585ba1ac5484ad579bc8855a3cf71_269338_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-game_theory/","title":"ACM学习笔记——博弈论……"},{"content":"题目链接 P2034 选择数字\n\r 题目分析 贪心想法及其问题 要使得“不能有超过$k$个连续的数被选中”，\n可以转化为：\n 在$k+1$个连续的数中，选择一个数舍去，断开成两个小于$k$个连续的数。\n再从断开的节点往后$k+1$个连续的数中，再选择一个数断去。\n 刚开始很容易想到一种贪心的思路。 每次选择最小的数舍去。\n\r\n但证明其正确性（是否会反悔）时，\n发现是存在反悔情况的。\n 对于数据：\n8 5\r2 100 ∞ ∞ ∞ ∞ ∞ 1\r若采用上述贪心，则会舍去$2,100,1$三个数。\n但实际最开始的$2$并不用舍去，造成了反悔情况。\n 如果写带反悔的贪心可能过于复杂，\n所以这里直接退用动态规划来写。\n动态规划想法 动态转移方程推导 记：$dp[i]$为前面$i$项最优的解。\n对于$dp[i]$，有以下几种取值情况：\n  不选择第$i$项。\n直接用前面的最优的解。\n即为：$dp[i-1]$。\n  选择第$i$项。\n则需从前面$k$项中，任选第$j$项舍去，\n并取所有选择中的最优情况。\n舍去第$j$项后，值为$\\sum_{t=j+1}^{i-1}a[t]+dp[j-1]+a[i]$（即前面第$j+1 \\sim i-1$项的和，加上$dp[j-1]$）\n最优情况即为：$\\max(\\sum_{t=j+1}^{i-1}a[t]+dp[j-1]+a[i]) (j∈[i-k,i-1])$。\n  综上，动态转移方程为：\n$$dp[i]=\\max(dp[i-1],\\max(\\sum_{t=j+1}^{i-1}a[t]+dp[j-1]+a[i] (j∈[i-k,i-1])))$$\n最后答案即为$dp[n]$。\n单调队列优化 对于方程中的$\\max(\\sum_{t=j+1}^{i-1}a[t]+dp[j-1]+a[i] (j∈[i-k,i-1]))$，\n如果每次都用for遍历$j$来求得，肯定喜得TLE。\n在之前分析过程中，我们就能隐约感觉到：\n这个找前$k$项中的最优情况，\n跟之前做过的滑动窗口这道题有点像！\n题目链接x个人笔记\r题目链接 - P1886 滑动窗口\n\r\r个人极早期笔记【语言和格式可能极其混乱_(:з」∠)_【虽然现在也是x……\n\r\r\r 其思想就是单调队列。\n 用单调队列，来记录前面$k$项中的$\\sum_{t=j+1}^{i-1}a[t]+dp[j-1]$（没包含$a[i]$）的情况。\n窗口移动到$i$时，队列新增(push)的项就为$dp[i-1]$（因为此时$j=i-1$，$\\sum$值为$0$)。\n但这里需要注意：\n当窗口移动时，窗口内所有项的$\\sum$的值会变，\n其均会增加 新移动到的这项$a[i]$。\n\r 但如果直接在单调队列中所有项进行增加，则又会回到$O(n^2)$的复杂度。\n因此可以用个变量$inc$，记录窗口中所有项要增加的值，\n每移动次窗口，就让inc+=a[i]。\n在计算$dp[i]$时，再加上$inc$即可，\n即将动态转移方程变为了： $$dp[i]=max(dp[i-1],top+inc+a[i])$$ 其中$top$表示优先队列中首项。\n然后又要注意：\n在入队push的时候，需要减去$inc$的值，\n即push(dp[i-1]-inc)。\n否则在计算$dp[i]$的$top+inc+a[i]$时，\n会多加$inc$的值。\n\r  然后对于最开始的$1 \\sim k$项来说：\n舍弃第$j$项的最优情况，就是前$k$项的和减去$a[j]$。\n所以可以先让$inc=\\sum_{i=1}^ka_i$，\n则每次push(-val[i])，\n加上$inc$后，即为最开始$k$项的最优情况。\n个人代码 Pastebin链接\n\r //P2034 [选择数字](https://www.luogu.com.cn/problem/P2034) #include \u0026lt;bits/stdc++.h\u0026gt;#define ALL(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026lt;= TO; \\ NAME_i++ using namespace std; typedef long long LL; #define MAX_N 100000  int val[MAX_N + 5]; //*可优化这个空间，因为不用记录读入的值 LL dp[MAX_N + 5]; //dp[i] - 前i个数最优情况  struct windowType { int head = 1, tail = 0; struct lineType { LL val; int index; lineType() : val(0), index(0) {} lineType(LL _val, int _index) : val(_val), index(_index) {} } line[MAX_N + 5]; LL top() { return line[head].val; } void push(const LL \u0026amp;val, const int \u0026amp;index) { while (head \u0026lt;= tail \u0026amp;\u0026amp; val \u0026gt; line[tail].val) tail--; line[++tail] = lineType(val, index); } void update(const int \u0026amp;range) { if (line[head].index \u0026lt; range) head++; } } window; //单调队列——记录前k个中最优的选择（去除某点后的结果） LL inc; //单调队列中每个元素要加的值  int main() { int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (ALL(i, 1, k)) scanf(\u0026#34;%d\u0026#34;, \u0026amp;val[i]), dp[i] = dp[i - 1] + val[i], window.push(-val[i], i); //对最开始k项的处理 - 直接push(-a[i])  inc = dp[k]; //对最开始k项的处理 - 刚开始的inc令为sum(a[1]~a[k])  for (ALL(i, k + 1, n)) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;val[i]); //0. 读入a[i]  dp[i] = max(dp[i - 1], window.top() + inc + val[i]); //1. 动态转移方程计算dp  inc += val[i]; //2. inc += val  window.push(dp[i - 1] - inc, i); //3. 入队  window.update(i - k + 1); //4. 出队 - 维护队首  } printf(\u0026#34;%lld\u0026#34;, dp[n]); return 0; } /* WA 记录： 1st. 单调队列中出队的过程写错了， 不能直接判断窗口是否满了，而要看是否超出窗口范围。 */ ","date":"2021-04-13T00:00:00Z","image":"https://blog.supersassw.com/p/acm-prac-2021_04_13/85627286_p0_hu92d0c517a83d7888dcbf161e9a863ec3_500455_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/acm-prac-2021_04_13/","title":"ACM练习 - P2034 选择数字……"},{"content":"名词解释  树突棘：在树突上布满的一种特殊结构，对突触的活动量以及活动类型敏感。 终扣：由终端的末梢分叉出的结构，能与其他细胞形成密切接触成为突触。 血脑屏障：是血液和脑之间的屏障，能阻隔可能对脑有害的物质进入。 郎飞氏结：相邻髓鞘之间没有被胶质细胞覆盖的轴突中断。 边缘系统：是大脑在演化中最早发展起来的一些皮质结构，尤指位于大脑皮层内侧以及周围的一些较古老的皮质和核团。是低等动物获得应对环境变化经验的最高中枢，控制着与生存有关的一系列本能行为。 网状结构：间脑、中脑、脑桥和延髓的中央区域，一些散在神经细胞或小核团，它们的纤维纵横穿行交织成网，被称为网状结构。 增殖：神经干细胞分裂、转化成神经细胞的过程。 迁移：新生的神经细胞按照一定规则向指定位置迁移的现象。 分化：神经细胞在达到指定位置一定时间以后，开始发生形态上的变化，并逐渐演变成特定的神经元或胶质细胞的过程。 突触发生：在神经生长因子的帮助下，分化后的神经元突起，开始长出轴突和树突，并与其他神经元建立联系的过程。 凋亡：一部分神经细胞受死亡基因控制，在发育的特定阶段发生程序性死亡的现象。 突触重建：凋亡发生后，原来的一些神经元的突触发生死亡，突触联系需要再建的过程。  思考题 4.髓磷脂是什么？有什么功能？中枢神经系统和外周神经系统的髓磷脂有什么区别？\n\r 答：\n髓磷脂是神经胶质细胞将轴突反复包绕所形成的一种脂肪物质。\n其功能是：将轴突与细胞外液隔绝，起到绝缘作用。\n中枢神经系统形成髓磷脂的为少突胶质细胞，而外周神经系统的为施万细胞。\n11.区分酒精在产前和产后造成的影响。\n\r 答：\n酒精在产前能破坏胎儿的脑内胶质细胞的迁移，使神经元失去胶质细胞的骨架引导而不能迁移到准确位置。\n酒精在产后使胎儿大脑皮层变为锥体细胞、星形细胞、粒状细胞混合堆积，导致脑功能发育严重受损，患胎儿酒精综合症。\n","date":"2021-04-11T00:00:00Z","image":"https://blog.supersassw.com/p/univ-psycho_phy-prac-4/pixiv61483143_hu12c1b5a9a5e516caec4f044d40d3022b_1819672_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/univ-psycho_phy-prac-4/","title":"生理心理学 - 第四章作业……"},{"content":"整体框架 PPT演示 演示文稿请在工作群中下载查看。\n\r 影片开头 影片的最开始：可以找一段纪录片、影片。\n来稍微总体描述一下共产党这一百年的发展艰辛而伟大。\n然后过渡到影片的标题——《开路、铺路、通路——共产党的百年之“路”》。\n如果最开头的影片实在不想要，直接开头就展示我们的总主题然后开始也可以。\n不过就会显得很突兀。\n\r 每场的安排 开始部分 每场最开始是一段“由该场主角配音的当时期共产党誓词”。\n在念誓词的时候的画面，有两个选择：\n 可以是那个时代的一些纪录片、电影片段。 如果实在不想弄，也可以就纯黑，只有声音。  对于每场前我们还可以加上每场的背景介绍。\n这里就需要编剧来编写。\n也可以不加背景介绍，\n那么在放入党誓词的时候，就只会有画面（甚至只会为黑幕）。\n\r  誓词念完后，开始黑幕展示每场的标题。\n影片部分 展示完每场标题后，\n就开始放每场按剧本和编剧要求剪辑的拍摄影片了。\n结束部分 拍摄影片结束后，画面就可以淡出。\n然后用相关时代的纪录片做背景。\n由旁白来交代事件的结果、影响。\n当然如果这里时间不够也可以不要，\n直接开始下一场。\n但个人觉得就会缺少一点对每场的一个升华机会。\n\r 影片结束 三个场景都放完后，\n开始放 “讲共产党的最终发展、所做出的贡献成果、对未来的展望” 相关的纪录片、影片。\n达到一种主题升华的效果！\n 然后是我们的谢幕片段。\n 然后是职员表。\n 最后再祝共产党100周年生日快乐，感谢观看。\n就，结束了！……\n","date":"2021-04-04T00:00:00Z","image":"https://blog.supersassw.com/p/univ-activity-summary_2/Yande-303578_hu4ac8284d9d64ce4dd805253e9d934d3e_1697426_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/univ-activity-summary_2/","title":"近代史活动 - 制作阶段安排……"},{"content":"活动形式 微电影——选取多个故事，通过时间维度的不同、事件的发展，来展示共产党的变化与影响。\n内容想法 协作文档链接\n\r 职位名单  总导演——高苇桐 编剧——甘诗源、王一翔、李逸心、汪无隅、喻世广 后期——蒋添爱、曾庆丰、陈薪羽  分组情况 第一组 组长：高苇桐\n成员：\n 曾坭 谭钰程 邱小欢 张永乐 罗晶晶 杨婉欣 蒋馨瑶 解文静  第二组 组长：蒋添爱\n成员：\n 黄锦 裴金铭 寇田婧 李昭燃 陈一鸣 曾庆丰 李玉娇 汪无隅  第三组 组长：甘诗源\n成员：\n 林俊杰 邓芝彤 陈薪羽 邹涛波 王一翔 喻世广 李逸心 李东阳   时间分配 计划表\n3.16~3.221. 剧本编撰\n\r预计天数：7天\n截止时间：3月22日\n任务：\n 按想法形成初稿 全班审阅、提出建议 修成形成终稿  \r\r3.23~4.62. 分组场景拍摄\n\r预计天数：15天（含4天周末）\n截至时间：4月6日\n任务：\n 服装、场地、道具安排 练习准备、试镜、排练 正式拍摄  \r\r4.7~4.113. 视频制作\n\r预计天数：5天\n截至时间：4月11日\n任务：\n 剪辑、合成 配音 字幕  \r\r 其他事项   导演在流程策划的时候，由于我们在拍摄、表演、制作水平等可能不高，所以尽量在情节场景设计方面创新一点。\n比如：情节的串联方式、线索的设计等。\n当然还是要有可操作性，不能太多复杂新颖导致不好实现，最终得不偿失【毕竟时间比较短，还是不要想的太宏大orz……\n就是要记得是给一群没有经验的学生写的方案，而不是职业演员这样。\n可以多去看看别人（最好是学生制作）的微电影，学习参考一下。\n  每组在拍摄的时候，建议这样操作：\n 第一周周末前——选择场地服装、练习台词、找时间试着配合 第一周周末——初次拍摄 第二周周末前——继续练习磨合、注意细节 第二周周末——最终拍摄    最好的情况，是每组拍摄的时候总导演和编剧都在场观看指点。\n所以各组在安排开始拍摄的时候，最好在群里说一下，如果每组能错开时间让总导演和编剧能参加就最好。\n  服装和道具需要注意一下：尽量能简则简。费用的话制作完成后同学们平摊。\n  设备的问题：有专业设备的同学欢迎提供，本地的同学可以询问自己家里能否送过来。如果实在没有就选择手机拍摄。\n   3月23日 第二组讨论结果 演员确定  邓 域才——陈一铭 何 广含——曾庆丰 邹 守简——裴金铭 王 泽川——汪无隅 陈 达——蒋添爱  剧本修改建议  第一场\n王泽川和邹守简的对话过于简单，需要增添修改。 第二场\n摔倒的工兵那段情节，改为：由女兵扶着伤兵下场。同时增添女兵给陈达送水的情节。  结束补充  陈达牺牲的情况。  ","date":"2021-03-15T00:00:00Z","image":"https://blog.supersassw.com/p/univ-activity-summary/Yande-364526_hu060b1d1a848b90f2358cba9689228f00_3707348_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/univ-activity-summary/","title":"近代史活动会议总结……"},{"content":"比赛链接 Codeforces Round #706 (Div. 2)\n\r 总结范围  A B C D E F  A. Split it! 比赛状态：AC\n\r  题目链接  题目大意 问题描述 给定一个字符串$s$和一个数$k$，\n判断字符串是否存在$k+1$个非空子串，满足： $$s=a_1+a_2+\\cdots+a_k+a_{k+1}+R(a_k)+R(a_{k-1})+\\cdots+R(a_1)$$\n其中$R(a_i)$代表倒置字符串$a_i$，\n如$R(nico)=ocin$。\n读入格式 $T$组数据。\n每组第一行为字符串长度$n$和$k$，\n第二行为长度为$n$的字符串$s$。\n输出格式 如满足，输出一行YES，\n如不满足，输出一行NO。\n数据范围 $1\\le t\\le 100$\n$1 \\le n \\le 100$\n$0 \\le k \\le \\lfloor \\frac{n}{2} \\rfloor$\n分析 先假设所有子串$a_i$的长度均为$1$，\n则$R(a_i)=a_i$。\n条件就变成了$s=a_1+a_2+\\cdots+a_k+a_{k+1}+a_k+\\cdots+a_2+a_1$，\n也就是$s$要为回文字符串。\n对于$a_{k+1}$，由于条件中只有一个，\n故这个子串可以为任意字符串，\n所以只需要字符串$s$两边有回文字符即可。\n 如：abc iowfen cba（为了区分$a_{k+1}$和其两边，用空格隔开）\n其中abc便为回文字符，有三个。\n 对于$a_1\\sim a_k$中的一子串$a_i$，如长度为$n$，\n则其可以拆成$n$个长度为$1$的子串，也使得条件满足。\n 如上例中abciowfencba\n可以为$a_1=abc$、$a_2=iowfen$，\n满足$s=a_1+a_2+R(a_1)$，\n也可以拆成$a_1=a$、$a_2=b$、$a_3=c$、$a_4=iowfen$，\n满足$s=a_1+a_2+a_3+a_4+R(a_3)+R(a_2)+R(a_1)$\n 即如果两边有$cnt$个回文字符，\n则可以通过组合，变为$1\\sim l$个满足条件的$a_i$。\n综上：\n即从字符串$s$两边开始找有多少个回文字符，记为$cnt$个，\n如果$k\\le cnt$，则满足条件输出YES，否则输出NO。\n 需要注意的是：\n$a_{k+1}$必须存在（非空），\n所以判断范围为(n - 1) / 2 - 1。\n也就是对于奇数长度字符串abcba，判断范围为$0\\sim1$（字符串下标从$0$开始），\n对于偶数长度字符串abccba，判断范围也为$0\\sim1$。\n\r 代码 Pastebin链接\n\r 代码\r#include \u0026lt;bits/stdc++.h\u0026gt;#define ALL(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026lt;= TO; \\ NAME_i++ #define ALL_invert(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026gt;= TO; \\ NAME_i-- using namespace std; #define MAX_N 100  int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int len, k; char str[MAX_N + 5]; scanf(\u0026#34;%d%d%s\u0026#34;, \u0026amp;len, \u0026amp;k, str); int cnt = 0; for (ALL(i, 0, (len - 1) / 2 - 1)) //注意判断范围  if (str[i] == str[len - i - 1]) //如果头尾字符相等，则为回文字符，cnt++  cnt++; else //如果判断到某处两侧不等，则该处到中间部分均为a_{k+1}，提前退出循环  break; if (k \u0026lt;= cnt) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } \r B. Max and Mex 比赛状态：AC\n\r  题目链接  题目大意 问题描述 对于一个集合$S$，其包含$n$个不同元素$a_i$。\n定义一次操作，为向该集合$S$中添加元素$\\lceil\\frac{a+b}{2}\\rceil$，\n其中$a=mex(S)$、$b=max(S)$。\n对于函数$mex(S)$，其意义为：$S$集合中最小的不存在的非负数。\n对于函数$max(S)$，其意义为：$S$集合中最大的元素。\n e.g.\n$mex(\\{1,4,0,2\\})=3$\n$mex(\\{3,5,6,7\\})=0$\n$max(\\{2,5,1\\})=5$\n 如果该操作添加的元素$\\lceil\\frac{a+b}{2}\\rceil$已存在于集合$S$中，\n则会重复添加。\n e.g.\n$S=\\{1,3,4,6\\}$\n如该操作要添加的元素为$4$，\n则新集合$S'=\\{1,3,4,4,6\\}$。\n  现在要求对某集合$S$进行$k$次操作，\n问：$k$次操作后，集合有多少个不同元素。\n读入格式 $T$组数据。\n每组第一行为集合初始元素个数$n$和操作次数$k$，\n第二行为集合$S$的$n$个元素$a_i$。\n输出格式 输出$k$次操作后集合$S$的不同元素个数。\n数据范围 $1\\le t\\le 100$\n$1 \\le n \\le 10^5$\n$0 \\le k \\le 10^9$\n$0 \\le a_i \\le 10^9$\n保证$n$总和不超过$10^5$。\n分析 易知道：\n$a=mex(S)$结果为集合中不存在的元素，\n$b=max(S)$结果为集合中存在的元素。\n所以一定满足$a \\ne b$。\n记：添加的元素$\\lceil\\frac{a+b}{2}\\rceil$为$x$，\n当$a \u0026lt; b$时，则$a \u0026lt; x \\le b$（且仅当$a=b-1$时，$x=b$）\n因此向$S$添加$x$过后，是不会更改$mex(S)$和$max(S)$的值的，\n所以经过一次操作后，下一次操作添加的元素仍为$x$。\n也就是说：\n$a \u0026lt; b$时，\n若$x \\not∈ S$，则$k$此操作后只会添加$1$个元素，答案为$n+1$。（并且注意$k\\ne0$）\n若$x ∈ S$或者$k=0$，$k$此操作均不会向$S$添加新的不同元素，答案为$n$。\n 但仍存在$a\u0026gt;b$的情况。\n e.g.\n$S=\\{0,1,2,3\\}$\n则$a=mex(S)=4$，\n$b=max(S)=3$。\n 且仅能是这种元素从$0$到$n-1$均存在的集合。\n如中间任意存在一处空缺，则会导致$mex(S)\u0026lt;max(S)$。\n那么这个时候$x=a$，则会向$S$中添加新元素$a$，\n一次操作过后，新的$a,b$则会变化：\n$a'=a$、$b'=a$，\n则又会添加新的元素。\n e.g.\n上例中：添加了$x=4$后，\n$S'=\\{0,1,2,3,4\\}$。\n则新的$a'=5$、$b'=4$，\n$x'=5$。\n$S''=\\{0,1,2,3,4,5\\}$\n 所以对于这种情况($a\u0026gt;b$)，最终$S$中不同元素为$n+k$个。\n 综上： $$ ans= \\begin{cases} n+1 \u0026amp; (a\u0026lt;b \u0026amp; and \u0026amp; (k\\ne0 \u0026amp; and \u0026amp; x\\not∈S)) \\\\ n \u0026amp; (a\u0026lt;b \u0026amp; and \u0026amp; (k=0 \u0026amp; or \u0026amp; x∈S)) \\\\ n+k \u0026amp; (a\u0026gt;b) \\end{cases} $$\n代码 Pastebin链接\n\r 代码\r#include \u0026lt;bits/stdc++.h\u0026gt;#define ALL(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026lt;= TO; \\ NAME_i++ #define ALL_invert(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026gt;= TO; \\ NAME_i-- using namespace std; #define MAX_N 100000  int num[MAX_N + 5]; set\u0026lt;int\u0026gt; s; int mex(int n) { if (num[1] != 0) return 0; for (ALL(i, 2, n)) if (num[i] - num[i - 1] != 1) return num[i - 1] + 1; return num[n] + 1; } int calc(int a, int b) { return (a + b) / 2 + (a + b) % 2; } //计算x  int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { s.clear(); int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for (ALL(i, 1, n)) scanf(\u0026#34;%d\u0026#34;, \u0026amp;num[i]), s.insert(num[i]); //用set集合来方便查找  sort(num + 1, num + n + 1); //先对数据排序，方便求mex(S)和max(S)  int a = mex(n), b = num[n]; if (a \u0026lt; b) if (k == 0 || s.find(calc(a, b)) != s.end()) printf(\u0026#34;%d\\n\u0026#34;, n); else printf(\u0026#34;%d\\n\u0026#34;, n + 1); else printf(\u0026#34;%d\\n\u0026#34;, n + k); } return 0; } \r C. Diamond Miner 比赛状态：未完成（看过题目未在时间内做出）\n\r  题目链接  题目大意 问题描述 平面直角坐标系$xOy$中，\n有$n$个矿工，均在$y$轴上，\n有$n$处矿物，均在$x$轴上。\n其中一位矿工只能挖一处矿物，一处矿物只能被一个矿工挖，\n即$x$和$y$轴上的点要一一配对。\n若每个矿工采矿代价是两点间距离$\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$，\n问：如何安排，使得总代价最小，并输出最小代价。\n读入格式 $T$组数据。\n每组第一行为矿工和矿物个数$n$，\n接下来$2n$行为矿工或矿物的坐标$x,y$（注意是无序的，不一定先全为矿工）。\n输出格式 输出每组数据的最小总代价，精确到$15$位小数。\n数据范围 $1\\le t\\le 10$\n$1 \\le n \\le 10^5$\n$-10^8 \\le x_i \\le 10^8$\n$-10^8 \\le y_u \\le 10^8$\n保证$n$总和不超过$10^5$。\n分析 采用贪心思想中的排序型贪心。\n对于任意两个矿工，其纵坐标分别为$y_a,y_b$，\n假设现在他们分别匹配到横坐标为$x_a,x_b$的两处矿。\n那么现在的代价为$\\sqrt{x_a^2+y_a^2}+\\sqrt{x_b^2+y_b^2}$。\n如果两个矿工匹配的矿对换，\n则代价变为$\\sqrt{x_b^2+y_a^2}+\\sqrt{x_a^2+y_b^2}$。\n那么对换的条件就是： $$\\sqrt{x_a^2+y_a^2}+\\sqrt{x_b^2+y_b^2} \u0026gt; \\sqrt{x_b^2+y_a^2}+\\sqrt{x_a^2+y_b^2}$$\n开始化简：\n$$2\\sqrt{x_a^2+y_a^2}\\sqrt{x_b^2+y_b^2} \u0026gt; 2\\sqrt{x_a^2+y_b^2}\\sqrt{x_b^2+y_a^2}$$ $$(x_a^2+y_a^2)(x_b^2+y_b^2) \u0026gt; (x_a^2+y_b^2)(x_b^2+y_a^2)$$ $$x_a^2y_b^2+x_b^2y_a^2 \u0026gt; x_a^2y_a^2+x_b^2y_b^2$$\n移项消去，可得两条件： $$ \\begin{cases} |x_a|\u0026gt;|x_b| \\\\ |y_a|\u0026lt;|y_b| \\end{cases} $$\n于是这样排序后最终效果，\n就是$|y_i|$越大的，匹配的$|x_i|$也就越大。\n 也就是说，\n我们可以直接对$x$和$y$数组进行排序，\n条件分别为$|x_i|$大小和$|y_i|$大小。\n这样排序后，也就是越大$|y_i|$对应越大的$|x_i|$，\n没要求输出方案，直接遍历计算结果即可。\n代码 Pastebin链接\n\r 代码\r#include \u0026lt;bits/stdc++.h\u0026gt;#define ALL(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026lt;= TO; \\ NAME_i++ #define ALL_invert(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026gt;= TO; \\ NAME_i-- using namespace std; #define MAX_N 100000  struct posType { int X, Y; posType() : X(0), Y(0) {} posType(int _X, int _Y) : X(_X), Y(_Y) {} bool operator==(const posType \u0026amp;a) const { return a.X == X \u0026amp;\u0026amp; a.Y == Y; } bool operator\u0026lt;(const posType \u0026amp;a) const { return X == a.X ? Y \u0026lt; a.Y : X \u0026lt; a.X; } posType operator+(const posType \u0026amp;a) const { return posType(X + a.X, Y + a.Y); } bool inMap(const int \u0026amp;mapX, const int \u0026amp;mapY) const { return X \u0026gt;= 1 \u0026amp;\u0026amp; X \u0026lt;= mapX \u0026amp;\u0026amp; Y \u0026gt;= 1 \u0026amp;\u0026amp; Y \u0026lt;= mapY; } } miner[MAX_N + 5], mine[MAX_N + 5]; inline double dist(const posType \u0026amp;a, const posType \u0026amp;b) { return sqrt((double)(a.X - b.X) * (double)(a.X - b.X) + (double)(a.Y - b.Y) * (double)(a.Y - b.Y)); } bool cmp(const posType \u0026amp;a, const posType \u0026amp;b) { return abs(a.X) == abs(b.X) ? abs(a.Y) \u0026lt; abs(b.Y) : abs(a.X) \u0026lt; abs(b.X); } //这里我将两个cmp合并为一个来写的，觉得不放行可以分开写。  int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, _X, _Y, miner_cnt = 0, mine_cnt = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (ALL(i, 1, 2 * n)) { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;_X, \u0026amp;_Y); if (_Y) miner[++miner_cnt] = posType(_X, _Y); else mine[++mine_cnt] = posType(_X, _Y); } sort(miner + 1, miner + miner_cnt + 1, cmp); sort(mine + 1, mine + mine_cnt + 1, cmp); double ans = 0; for (ALL(i, 1, n)) ans += dist(miner[i], mine[i]); printf(\u0026#34;%.15lf\\n\u0026#34;, ans); //注意小数位数为15位。  } return 0; } \r D. Let\u0026rsquo;s Go Hiking 比赛状态：未完成（时间不足）\n\r  题目链接  题目大意 问题描述 Qingshan和Daniel玩游戏。\n存在任意$n$个数字$p_i$。\nQingshan为先手，其先选择这串数字的一个下标$x(1\\le x \\le n)$，\nDaniel为后手，其再选择一个下标$y(1\\le y\\le n)$，并且$y \\ne x$。\n游戏操作为回合制，两人具体操作为：\n  Qingshan的回合中，其需要选择一个新的$x'(1\\le x' \\le n)$，其要满足三个条件：\n 在$x$附近。($|x'-x|=1$) 不与$y$相同。($x' \\ne y$) 要比原来的数小（下山）。($p_{x'}\u0026lt;p_x$)  当成功选择出$x'$，会把$x'$赋给当前的$x$($x=x'$)。\n  Daniel的回合中，其需要选择一个新的$y'(1\\le y' \\le n)$，其要满足三个条件：\n 在$y$附近。($|y'-y|=1$) 不与$x$相同。($y' \\ne x$) 要比原来的数大（上山）。($p_{y'}\u0026gt;p_y$)  当成功选择出$y'$，会把$y'$赋给当前的$y$($y=y'$)。\n  当某人没法找到新的$x$或$y$（无路可走）时，判这名玩家输。\n 你的任务是：\n判断这组数字$p$中，有多少个$p_i$，使得其作为Qingshan初始选择的$x$时，Qingshan必赢。\n读入格式 第一行为数字个数$n$，\n第二行为$n$个数字$p_i$。\n输出格式 输出有多少种初始的$x$，使得Qingshan必赢。\n数据范围 $2 \\le n \\le 10^5$\n$1 \\le p_i \\le n$\n保证$n$总和不超过$10^5$。\n样例数据 第一组 输入 5 1 2 5 4 3 输出 1  解释：\nQingshan只能选择$x=3$。\n选择此处后，无论Danie选择哪里，之后的行动都总会使Danie被堵死。\n而Qingshan选择其他地方时，Danie总有办法将Qingshan堵死。\n故答案为$1$。\n第二组 输入 7 1 2 4 6 5 3 7 输出 0  解释：\nQingshan无论怎么选择$x$，都总被Danie或边界堵死。\n如$x=4$时，则$y=1$便能使Qingshan一定输掉游戏：\n 当Qingshan选择$x'=3$，Danie选择$y'=2$，这之后Qingshan被Danie堵死，输掉游戏。 当Qingshan选择$x'=5$，Danie选择$y'=2$，\n行动到最后$x=7$，$y=4$，这个时候时Qingshan的回合，但Qingshan被边界堵死，输掉游戏。  如$x=3$时，则$y=4$便能使Qingshan一定输掉游戏：\n Qingshan只能选择$x'=2$，这个时候Danie选择$y'=5$从右侧下山。\n那么到最后，Qingshan会被边界堵死，输掉游戏。  故答案为$0$。\n分析 这串数字可以分成一段段坡路（上坡路和下坡路可以相互转换）和平路。\n首先两人都只能走上坡或者下坡，故只分析坡路。\n对于Qingshan，如果其$x$选择一段不是最长的坡路，从顶往下走，\n那么Danie只用选择最长的那条坡路，从底往上走，\n这样就能把Qingshan耗死，使得最终Qingshan被边界堵死。\n所以Qingshan只能选择最长的坡路开始走。\n 对于最长的坡路，记其数量为$c$条，\n  当$c=1$时：\n则无论Qingshan怎么选择起点（当然不能是最低点），\nDanie都能选择在他旁边低处，使得刚开始就被堵死，Qingshan输掉游戏。\n  当$c\\ge3$时：\n则无论Qingshan选择哪条路，从顶往下走，\nDanie都能选择另外一条与他不会碰见的路，最终把Qingshan耗死，Qingshan输掉游戏。\n  当$c=2$时：\n由$c\\ge3$的情况可知，如果两条路毫不相关（中间被隔开），\nDanie也总能选择一条与他不会碰见的路把Qingshan耗死，Qingshan输掉游戏。\n那么对于不被隔开的两条路，只有形如\u0026quot;V\u0026quot;和\u0026quot;Λ\u0026quot;的两种情况。\n  对于\u0026quot;V\u0026quot;型：\nQingshan无论是选择左边还是右边的顶点向下走，\nDanie只用选择中间的最低点，朝着Qingshan下来的反方向走，就能把Qingshan耗死，Qingshan输掉游戏。\n  对于\u0026quot;Λ\u0026quot;型：\n也就是样例1中的情况。\n  如果路的长度$len$为奇数：\n那么Qingshan能且仅能选择顶点，\n再根据Danie选择的$y$的方向，朝着他走，就能使Danie被堵死，Qingshan赢得游戏，并且只有一种方案。\n  如果路的长度$len$为偶数：\n那么Qingshan选择顶点后： 如果不选Danie上山的方向，就会被耗死；\n如果选Danie上山的方向，就会被堵死。\n最终都是Qingshan输掉游戏。\n       综上：\n只有满足以下四个条件，Qingshan才能赢得游戏，且答案仅能为$1$：\n $c=2$。 两条路无间隔。 两条路为\u0026quot;Λ\u0026quot;型。 $len$为偶数。   可以将每条坡路的信息存下来：\n 记录每条坡路从左到右看，是上坡还是下坡，记为$state$。 记录每条坡路的长度$len$。 记录每条坡路的编号（是第几条路）$index$。  对于$2$号条件，可以判断$index$之差的绝对值是否为$1￥$。如果为$1$证明无间隔。\n对于$3$号条件，可以判断$road[1]$的$state$是否为上坡，$road[2]$的$state$是否为下坡。\n代码 Pastebin链接\n\r 代码\r#include \u0026lt;bits/stdc++.h\u0026gt;#define ALL(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026lt;= TO; \\ NAME_i++ #define ALL_invert(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026gt;= TO; \\ NAME_i-- using namespace std; #define MAX_N 100000  #define NOW_ROAD road[road_cnt] #define NEW_ROAD get_state(_num, num), 2, road_cnt  struct roadType { int state, len, index; roadType() : state(0), len(0), index(0) {} roadType(int _state, int _len, int _index) : state(_state), len(_len), index(_index) {} const bool operator\u0026lt;(const roadType \u0026amp;a) { return len == a.len ? index \u0026lt; a.index : len \u0026gt; a.len; } //重载\u0026lt;为按len降序排序。注意：len相等时，要以index小的在前，防止破坏上坡下坡的顺序。 } road[MAX_N + 5]; int get_state(int _num, int num) { return num - _num \u0026gt; 0 ? 1 : (num - _num == 0 ? 0 : -1); } //state==1为上坡; state==0为平路; state==-1为下坡  int main() { int n, num, _num, road_cnt = 1; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;_num, \u0026amp;num); road[1] = roadType(NEW_ROAD); for (ALL(i, 3, n)) { _num = num, scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); if (get_state(_num, num) != NOW_ROAD.state) //与当前路状态不同，增加新路  road_cnt += NOW_ROAD.state == 0 ? 0 : 1, road[road_cnt] = roadType(NEW_ROAD); //当NOW_ROAD的state为0时，证明当前路为平路。所以road_cnt不++，覆盖掉这段平路。  else //与当前路状态相同，当前路长度++  NOW_ROAD.len++; } if (NOW_ROAD.state == 0) //如果最后一条路是平路，road_cnt--  road_cnt--; sort(road + 1, road + road_cnt + 1); //用排序，方便找最大的len。但注意不能破坏相同len的路的顺序。  int c = road[1].len == road[2].len ? road[2].len == road[3].len ? 3 : 2 : 1, len = road[1].len; //这里如果c\u0026gt;3，统一看成c=3的情况。  if ((c == 2) \u0026amp;\u0026amp; (abs(road[2].index - road[1].index) == 1) \u0026amp;\u0026amp; (road[1].state == 1 \u0026amp;\u0026amp; road[2].state == -1) \u0026amp;\u0026amp; len % 2) //四个括号分别对应四个条件  printf(\u0026#34;1\u0026#34;); else printf(\u0026#34;0\u0026#34;); return 0; } \r ","date":"2021-03-10T00:00:00Z","image":"https://blog.supersassw.com/p/acm-writeup-2021_3_10/Yande-275846_hu5d6f7221a57c96d4dc2f53997133279c_589479_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-writeup-2021_3_10/","title":"ACM比赛总结——Codeforces #706 (Div. 2)……"},{"content":"离散化介绍 离散化，就是将一组离散的数据，映射成集中的数据。【所以个人觉得应该叫集中化【？……\n其思想跟哈希(Hash)类似。\n当有些数据因为本身很大或者类型不支持，自身无法作为数组的下标来方便地处理，\n而影响最终结果的只有元素之间的相对大小关系时，\n我们可以将原来的数据按照从大到小编号来处理问题，即离散化。\n\r 引自：OI-Wiki「离散化」\n常用来离散化类型的是：大整数、浮点数、字符串。\n情况举例 本身很大情况 最常见的题比如： 判断在$N$个数中，某数$a_i$是否存在。\n\r\n很简单的思路就是：\n用个布尔数组bool exist[]来记录某数是否存在。\n但如果数据范围是$1 \\le N \\le 10^5, 0 \\le a_i \\le 10^9$，\n也就是：数的个数$N$远小于数的范围$a_i$时，\n很明显，如果直接用$a_i$作下标来记录，会导致数组开不下。\n 而对于这道题，$a_i$的值是多少，并没有太大意义，我们只用关心它出现没有。\n因此我们可以把这些分散的$a_i$按大小顺序重新编号。\n举例\r5个数，其分别为：\n9463 1 233333333 78 5 此时如果直接以下标来存储，数组就要开为bool exist[233333333 + 5];。\n 将其重新编号（映射）为：\n4 1 5 3 2 此时数组就可以开为bool exist[5 + 5];。\n\r 类型不支持情况 将题改为： $N$个字符串，判断某字符串$s_i$是否存在。\n\r\n这个时候甚至直接不能作为bool exist[]数组下标了。\n 可以将其映射为能作为下标的数字。\n要查找某字符串，用该映射函数将所寻字符串映射为数字ID，\n然后直接看exist[ID]是否为$true$即可。\n实现方法 思路 上面介绍说到：离散化后的数据只与相互间大小关系有关。\n所以对于原数据要先放在另一个容器中排序，得到他们之间的大小关系。\n然后该容器中需要去除重复元素，来最大程度节省空间。\n 比如原数据为$100$个$8$和$1$个$9$。\n如果不去重，离散化后$8$会映射为$1$，而$9$会映射为$101$，\n去重过后，$8$会映射为$1$，$9$则会映射为$2$了。\n 这样过后便得到了原数据与新数据的一一映射关系表。\n这个时候再将原数据按表全部替换，完成离散化。\n 所以离散化一共有三个重要操作：\n 对原数据放到另一个容器，并按大小关系排序。 去除排好序后容器的重复元素，得到一一映射关系。 按照一一映射关系，将原数据替换为新数据。  举例\r原数据为：\n98 783 1 23333 1 57 912 5 1 98 排序后为：\n1 1 1 5 57 98 98 783 912 23333 去重后为：\n1 5 57 98 783 912 23333 则得到一一映射关系表：\n   原数据 新数据     1 1   5 2   57 3   98 4   783 5   912 6   23333 7    替换后，即离散化为：\n4 5 1 7 1 3 6 2 1 4 \r 具体实现 一、大整数离散化 去重操作使用到的是unique函数，\n映射关系表对应，则用lower_bound这个查找函数。\n有关这两个函数的详细信息，可以百度查阅相关资料。\n 代码：\nint raw[MAX_N + 5], //原数据  n, //原数据个数  cont[MAX_N + 5], //临时容器  disc[MAX_N + 5]; //离散化后数据  void discrete() { memcpy(cont, raw, (n + 1) * sizeof(int)); //1. 原数据放入另一容器  sort(cont + 1, cont + n + 1); //1. 排序  int disc_len = unique(cont + 1, cont + n + 1) - cont - 1; //2. 去重，并得到去重后的有效长度（运用的是数组地址相减代表长度）。  for (int i = 1; i \u0026lt;= n; i++) //3. 按照一一映射关系，得到离散化序列  disc[i] = lower_bound(cont + 1, cont + disc_len + 1, raw[i]) - cont; //利用lower_bound找到原数据在cont数组中的地址，减去cont头地址后得到离散结果（即cont中下标） }  运行结果：\n 没有重复数据：\n大整数离散化 - 示例1 有重复数据：\n大整数离散化 - 示例2  二、字符串离散化 【由于暂时没做到相关的题就没做总结2333……\n这里就跟字符串哈希的操作是一样的了，\n可以查看OI-Wiki上的「字符串哈希」。\n其他事项 不去重情况 有时候根据题目要求，相同元素可能会有作用。 如下面的问题： 对于数组$a[i]$，问两区间$(l_1,r_1),(l_2,r_2)$间有多少个相同元素。\n\r\n如要使用较快的：“bitset+取并集”的操作，\n这里离散化的时候就不要去重，\n并采用以下技巧： 用个$cnt[i]$数组，记录$a_i$在bitset数组$bit[]$出现的次数，\n当出现$a_n$时，则使$bit[a_n+cnt[a_n]]++$。\n\r\n这样，出现了几个$a_n$，就会在$bit[]$中存几个，\n取交集的时候就能直接得到个数了。\n 不去重的原因，是使得相邻两元素离散后的值有差距，\n其差距就是该数出现的次数【见上方「本身很大情况」中举的例子】\n而去重后，两值间则不会有差距，\n无法通过这种方法来存储所有出现的$a_n$。\n ","date":"2021-03-04T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-discrete/Yande-312234_hu74e31cf7a8be9f78c1abc828bcffbc8e_3268181_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-discrete/","title":"ACM学习笔记——离散化……"},{"content":"该笔记还未完成整理，待日后继续整理……\n\r 离线和在线区别 指的是对于若干个询问操作的不同处理方式。\n在线 得到一次询问，便回答一次。\n离线 得到所有询问后，再统一回答。\n强制在线 离线算法一般都会对询问用id标记，然后进行排序操作，\n因此会打乱原本的询问顺序。\n e.g.\n对于五个询问$1,2,3,4,5$，\n离线算法可能按$3,1,4,5,2$的顺序进行计算，最后再统一回答询问。\n 因此如果要求：某次询问与之前的询问有复合操作（比如xor上次的询问），\n便使得不能读完所有操作，计算完后再统一回答，\n而只能读一个，计算一个，回答一个。\n这便是强制在线。\n离线算法  CDQ 分治 整体二分 莫队算法  ","date":"2021-03-01T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-offline/75470755_p0_hub4303ba1cffa5ba06cb6a01bf1816187_2872336_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-offline/","title":"ACM学习笔记——离线……"},{"content":"简介 属于离线算法中的一种。\n用来解决离线区间询问问题，\n将其加以扩展后，还可以解决树上路径询问问题和支持修改操作。\n使用条件 须满足以下条件：\n对于区间$[l,r]$，\n其查询后的答案，能够在$O(1)$扩展到其相邻区间的答案。\n 即：\n$[l-1,r]$、$[l+1,r]$、$[l,r-1]$、$[l,r+1]$这四个区间\n 实现 如果满足使用条件后，\n自然而然就能想到这种解题方法：\n根据上一个询问，一步步扩展到当前询问。\n\r 这就是莫队算法中最基本的解题思路，\n这样一直扩展下去，就能得到所有询问的答案。\n 但如果就按照题中给的询问顺序，一个个挨着扩展的话，\n肯定会造成大量的重复移动操作。\n e.g.\n99 100 1 2 99 100 1 2 99 100 每次l和r都会从一端极值移动到另一端极值。\n 不排序直接求解，易得其复杂度为$O(n^2)$。\n 因此莫队算法的核心则是：\n我们应该怎样对询问排序，使得这一步步扩展的操作次数尽量少。\n也就是该如何定义排序算法。\n排序算法 1. 直接排序 首先自然而然想到的排序算法就是：\n直接按照询问的l和r为主次关键字进行排序。\n\r\n结构体的\u0026lt;定义为：\nstruct queryType_direct { int l, r, id; bool operator\u0026lt;(const queryType_direct \u0026amp;a) const { return l == a.l ? r \u0026lt; a.r : l \u0026lt; a.l; } //当l不同时，l小的排在前面； \t//当l相同时，r小的排在前面。 } direct[MAX_M + 5];  但这样排序算法十分粗糙，\n其复杂度仍为$O(n^2)$，仅常数小一些而已，\n很容易TLE。\n 复杂度大致计算方式：\n以这种排序方法，\nl为升序，所以移动次数最坏为$n$，\nr最坏情况为反复在两端点间移动，移动次数为$\\frac{(n-2)n}{2}$（等差数列计算）。\n总移动次数最坏为$\\frac{n^2}{2}$，\n故复杂度为$O(n^2)$。\n 2. 分块排序 为最有效又简单的排序算法。\n具体方法为：\n将$n$个询问分为$M$个块。\n对于同一个块，按照r的大小排序，\n对于不同的块，则按照l的大小排序。\n\r\n结构体的\u0026lt;定义为：\nint BLOCK_SIZE; struct queryType_block { int l, r, id; bool operator\u0026lt;(const queryType_block \u0026amp;a) const { return l / BLOCK_SIZE == a.l / BLOCK_SIZE ? r \u0026lt; a.r : l \u0026lt; a.l; } //当 l/BLOCK_SIZE == r/BLOCK_SIZE 时，为同一块，按照r的大小排序； \t//不为同一块时，按照l的大小排序。 } block[MAX_M + 5]; 而块的大小BLOCK_SIZE，一般取为$\\sqrt{n}$。\n 虽然看起来很粗糙，与直接排序的区别十分小（就多了个/BLOCK_SIZE），\n但其复杂度却能显著的降到$O(n\\sqrt{n})$。\n 复杂度计算方式：\nOI-Wiki上的证明方法太多了懒得看x，这里用另一种很不严谨的方式来说明orz……\n同一块中，询问个数和块的长度均为$\\sqrt{n}$，\nl最坏情况也为反复在两极值端点间振荡，但端点距离变为了$\\sqrt{n}$，移动次数大致为$\\sqrt{n}*\\sqrt{n}=n$，\nr为递增，所以最坏情况移动次数为$n$，\n跨块的时候，\nl最坏移动$\\sqrt{n}$次，\nr最坏移动$n$次，\n所以每一块（同时算上同一块和跨块的移动操作）移动次数大致为$3n+\\sqrt{n}$，\n一共$\\sqrt{n}$块，\n故最坏情况，总移动次数为$3n\\sqrt{n}+n$。\n即复杂度为$O(n\\sqrt{n})$。\n 2.(1). 分块的优化——奇偶化排序 对于这组已排好序的数据： （令：n为100，即BLOCK_SIZE为$10$）\n 1 1 2 100 10 11 11 100  如果就按照这样的顺序进行操作，\n在第二步r为$100$后，\n执行第三步会跳到$11$，执行第四步又会跳到$100$。\n而将顺序改为：\n 1 1 2 100 11 100 10 3  则能减少从一极值跳到另一极值的情况。\n 也就是说，对于第二种“分块排序”方法：\n在执行完某一块跳到下一块的时候，\nr会从当前块的最大值，唐突移动到下一块的最小值，\n从则造成多余的移动操作。\n而如果将奇数块改为从小到大排序，偶数块改为从大到小排序，\n则在跳块的时候，能很平滑的从这一块最大过渡到下一块最大。\n这种优化能使程序快$30%$。\n结构体的\u0026lt;定义为：\nint BLOCK_SIZE; struct queryType_block_pro { int l, r, id; bool operator\u0026lt;(const queryType_block_pro \u0026amp;a) const { return l / BLOCK_SIZE == a.l / BLOCK_SIZE ? (r == a.r ? 0 : (l / BLOCK_SIZE \u0026amp; 1) ^ (r \u0026lt; a.r)) : l \u0026lt; a.l; } //这里运用位运算，实现了当为奇数块时从小到大排序，偶数块时从大到小排序。 } block_pro[MAX_M + 5]; \r注意：需要特判r == a.r的情况！\n否则对于两询问$a,b$，\n其l属于同一奇数块，且r相等的情况，\n排序时会同时满足$a\u0026lt;b$和$b\u0026lt;a$，\n使得sort()出错。\nsort出错原因是因为其要满足严格弱序，\n有关严格弱序的介绍可以看这里写的「ACM学习笔记：邻项比较排序……」文章中有提及。\n\r\r\r 理解不了压行写法的话，也可以看OI-Wiki上的不压行写法。\n\r 3*. 曼哈顿最小生成树排序 其实最优的排序方法，是构造曼哈顿最小生成树。\n一种方法是把所有区间$[l,r]$看成平面上的点$(l,r)$，并对所有点建立曼哈顿最小生成树，\n每次沿着曼哈顿最小生成树的边在询问之间转移答案。\n\r 引自：OI-Wiki。\n但其复杂度其实也是$O(n\\sqrt{n})$，\n故一般都采用最简单的分块排序。\n【个人也完全不会这个排序方法就不写了_(:з」∠)_……\n操作次数比较 以莫队模板题“P1494 小Z的袜子”来进行比较。\n当$n,m$较大时：\n输入数据（$n=50000,m=50000$）链接。\n\r 三种排序操作次数对比 - n,m较大\n \u0026ldquo;Raw\u0026rdquo;：未排序直接操作。 \u0026ldquo;Direct\u0026rdquo;：直接排序。 \u0026ldquo;Block\u0026rdquo;：分块排序。 \u0026ldquo;Block Pro\u0026rdquo;：分块排序+奇偶化。   但注意：\n分块排序的操作次数不一定恒小于直接排序。\n当$n,m$较小时，很有可能反而大于直接排序。\n输入数据（$n=10,m=15$）链接。\n\r 三种排序操作次数对比 - n,m较小\n可以发现反而直接排序操作次数更少。\n但由于当$n,m$较大时，这种情况几乎不存在，\n所以可以不用考虑。\n注意事项 排完序后，会破坏原有询问的顺序，\n故要加个id变量，来存储原询问的顺序。\n\r 移动操作 当排好序过后，关键就是：\n如何通过现在求得的$(l,r)$区间的答案$ans$，\n一步步移动l和r，\n来求得新区间$(l',r')$的答案$ans'$。\n 需要先根据题目分析，\n来计算出增加或删除某个元素，对答案的影响。\n然后用while判断，一步步l++、l--、r++、r--，\n得到新询问区间的答案。\nwhile的位置很重要，不能随意调换他们的位置。\n可以简单记住以下三种正确顺序：\n l--, r--, r++, l++ l--, r++, l++, r-- l--, r++, r--, l++  【l--和--l一样，只要l的加减与r的加减顺序对了就行。\n有关证明，可见OI-Wiki上的「关于四个循环位置的讨论」。\n\r 总模板 int BLOCK_SIZE; struct queryType { int l, r, id; bool operator\u0026lt;(const queryType_block_pro \u0026amp;a) const { return l / BLOCK_SIZE == a.l / BLOCK_SIZE ? (r == a.r ? 0 : (l / BLOCK_SIZE \u0026amp; 1) ^ (r \u0026lt; a.r)) : l \u0026lt; a.l; } //分块+奇偶化 } query[MAX_M + 5]; inline void move(int pos, int sign, int \u0026amp;nowAns) //sign=1代表增加，sign=-1代表减少。 { // update nowAns } void solve() { BLOCK_SIZE = sqrt(n); sort(query + 1, query + m + 1); int nowL = 1, nowR = 0, nowAns = 0; #define L query[i].l #define R query[i].r #define ID query[i].idid  for (int i = 1; i \u0026lt;= m; i++) { while (nowL \u0026gt; L) move(--l, 1, nowAns); while (nowR \u0026lt; R) move(r++, 1, nowAns); while (nowL \u0026lt; L) move(l++, -1, nowAns); while (nowR \u0026gt; R) move(--r, -1, nowAns); ans[ID] = nowAns; } } 例题  P1494 小Z的袜子\n题解可见「ACM练习——P1494 小Z的袜子……」。  ","date":"2021-03-01T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-mo_algo/85829025_p0_hud48d475653a68121c5c5dd4c9c15f623_2139511_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/acm-note-mo_algo/","title":"ACM学习笔记——莫队算法……"},{"content":"题目链接 P1494 小Z的袜子\n\r 题目分析 标准的莫队模板题。\n有关莫队的知识点可以看个人笔记「ACM学习笔记：莫队算法……」\n\r 则分析这道题的具体移动操作。\n对于当前状态$[l,r]$区间，记：\n $cnt[i]$为当前某颜色的出现次数， $ans$为当前答案（抽到两只颜色相同的袜子的情况总数）。   当扩展区间(l--,r++)时，记增加的颜色为$c$，\n那么其跟当前区间$[l,r]$中，颜色相同的袜子都能配对。\n也就是说，其贡献的满足情况数为$cnt[c]$，\n即ans += cnt[c]。\n e.g.\n当前区间为$[1,6]$，袜子颜色分别为$A,A,B,B,B,C$【为了更好区分，将颜色用字母暂时代替】，\n则答案$ans$为$4$。\n若向右扩展区间，新增加的$7$号袜子颜色为$A$，\n袜子变为$A,A,B,B,B,C,A$。\n则其跟之前的$2$个颜色为$A$的袜子均能配对，\n所以贡献答案为$cnt[A]$为$2$，$ans += 2$，\n则新的$ans$等于$6$。\n 然后cnt[c]++。\n 当缩短区间(l++,r--)时，记删去的颜色为$c$，\n那么其跟当前区间$[l,r]$中，颜色相同的其他袜子都不能再配对。\n也就是说，其损失的满足情况数为$cnt[c]-1$，\n即ans -= cnt[c] - 1。\n然后cnt[c]--。\n 再次优化（压行），则可得出最终的两个move操作函数。\n扩展函数：\ninline void add(const int \u0026amp;color, LL \u0026amp;ans) { ans += cnt[color]++; } 缩短函数：\ninline void dec(const int \u0026amp;color, LL \u0026amp;ans) { ans -= --cnt[color]; }  最后在重点注意一下move时：++和--的前后位置（是l++还是++l），\n在草稿本上自己模拟走一遍就能知道了。\n以及再注意下约分的问题，\n无了。\n个人代码 Pastebin链接\n\r //P1494 [小Z的袜子](https://www.luogu.com.cn/problem/P1494) #include \u0026lt;bits/stdc++.h\u0026gt;#define ALL(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026lt;= TO; \\ NAME_i++ #define ALL_invert(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026gt;= TO; \\ NAME_i-- typedef long long LL; using namespace std; #define MAX_N 50000 #define MAX_M 50000  int color[MAX_N + 5], cnt[MAX_M + 5], BLOCK_SIZE; //cnt-当前状态各颜色出现了多少次 LL nume[MAX_M + 5], deno[MAX_M + 5]; //nume-分子，deno-分母  struct queryType { int l, r, id; //bool operator\u0026lt;(const queryType \u0026amp;a) const { return l == a.l ? r \u0026lt; a.r : l \u0026lt; a.l; } //直接排序  //bool operator\u0026lt;(const queryType \u0026amp;a) const { return l / BLOCK_SIZE == a.l / BLOCK_SIZE ? r \u0026lt; a.r : l \u0026lt; a.l; } //分块排序  bool operator\u0026lt;(const queryType \u0026amp;a) const { return l / BLOCK_SIZE == a.l / BLOCK_SIZE ? (r == a.r ? 0 : (l / BLOCK_SIZE \u0026amp; 1) ^ (r \u0026lt; a.r)) : l \u0026lt; a.l; } //分块排序+奇偶性优化 } query[MAX_M + 5]; inline LL C(const int \u0026amp;n, const int \u0026amp;m) //组合数计算函数 { LL ans = 1; for (int i = n; i \u0026gt;= n - m + 1; i--) ans *= i; for (int i = 2; i \u0026lt;= m; i++) ans /= i; return ans; } inline LL GCD(const LL \u0026amp;a, const LL \u0026amp;b) { return b ? GCD(b, a % b) : a; } inline int intRead() { int f = 1, num = 0; char t = getchar(); while (t \u0026lt; \u0026#39;0\u0026#39; || t \u0026gt; \u0026#39;9\u0026#39;) f = t == \u0026#39;-\u0026#39; ? -1 : f, t = getchar(); while (t \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t \u0026lt;= \u0026#39;9\u0026#39;) num = num * 10 + t - \u0026#39;0\u0026#39;, t = getchar(); return f * num; } inline void add(const int \u0026amp;color, LL \u0026amp;ans) { ans += cnt[color]++; } //增加某一颜色的move操作 inline void dec(const int \u0026amp;color, LL \u0026amp;ans) { ans -= --cnt[color]; } //减少某一颜色的move操作  int main() { int n = intRead(), m = intRead(); BLOCK_SIZE = sqrt(n); for (ALL(i, 1, n)) color[i] = intRead(); for (ALL(i, 1, m)) query[i].l = intRead(), query[i].r = intRead(), query[i].id = i; sort(query + 1, query + m + 1); int now_l = 1, now_r = 0; //这里初值l=1,r=0，可以想想为什么。  LL now_nume = 0; #define L query[i].l #define R query[i].r #define ID query[i].id  for (ALL(i, 1, m)) if (L == R)\t//L==R情况的特判  nume[ID] = 0, deno[ID] = 1; else { while (now_l \u0026gt; L) add(color[--now_l], now_nume); while (now_r \u0026lt; R) add(color[++now_r], now_nume); while (now_l \u0026lt; L) dec(color[now_l++], now_nume); while (now_r \u0026gt; R) dec(color[now_r--], now_nume); //注意这里++和--的前后位置！  nume[ID] = now_nume; if (now_nume) { deno[ID] = C(R - L + 1, 2); LL gcd = GCD(nume[ID], deno[ID]); nume[ID] /= gcd, deno[ID] /= gcd; //约分操作  } else deno[ID] = 1; //如果计算出ans是0，需要特判，否则求GCD会出错  } for (ALL(i, 1, m)) printf(\u0026#34;%lld/%lld\\n\u0026#34;, nume[i], deno[i]); } ","date":"2021-03-01T00:00:00Z","image":"https://blog.supersassw.com/p/acm-prac-2021_03_01/87513233_p0_hu1cd82d89b6635953dfff4fbbec4eda5e_886459_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/acm-prac-2021_03_01/","title":"ACM练习——P1494 小Z的袜子……"},{"content":"以下为涅普计划的课程笔记，建议搭配课程视频理解。\n\r 0x00 课程视频 课程视频\r\r\r视频Bilibili链接\r 0x01 什么是密码学 【基本概念与作用应该都知道一点吧，这里不做基础介绍了_(:з」∠)_……\n 古典密码学主要关注信息的保密书写和传递，以及与其相应的破译方法。\n现代密码学不只关注信息保密问题，\n还同时涉及信息完整性验证、信息发布的不可抵赖性、以及在分布式计算中产生的来源于内部和外部的攻击的所有信息安全问题。\n CTF中的古典密码学题目有时也会出现在杂项里面，\n古典加密常常不给出加密算法，需要判断或者尝试一下。\n而CTF中的现代加密常常会给出加密算法，或者以一些形式提示某种常用的加密算法。\n即通过公开的加密算法和题目给的条件来思考解密的算法并加以实现。\n 密码学描述中，对传输者和窃取者有习惯名称。\n什么是密码学 - 名称约定\n 可以用数学中的函数形式来表达加密解密的过程。\n什么是密码学 - 数学表示\n $k$代表密钥，$m$代表明文，$c$代表密文。 $E$代表加密函数，$D$代表解密函数。 加密过程为：$c=E(k,m)$ 解密过程为：$m=D(k,c)$  0x02 凯撒加密 定义 凯撒加密(Caesar Cipher)是一种最简单且最广为人知的加密技术，它属于替代加密，\n明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。\n按密匙进行移位后，可以得到一张一一对应的密码表，\n基本的加密解密过程都可以通过查表来完成。\n凯撒加密 - 密码表\n外圈对应明文，内圈对应密文。\n加密时：将明文字母一一替换成内圈字母，\n解密时：将密文字母一一替换成外圈字母。\n  类型：单表替代加密。 加密对象：一般为字母。 加密方式：字母按偏移量（密钥）移位。 安全性：非常差。\n密钥只有25种情况，很轻易就能枚举出来。  加密脚本 from string import ascii_uppercase Plaintext = \u0026#34;game.granbluefantasy.jp\u0026#34; # 在这里输入明文 Key = 3 # 在这里输入密钥 Plaintext = Plaintext.upper() # 为了加密过程简单，将字符串字母全转换为大写 def Encrypt(Plaintext, Key): # 加密函数，操作为减少偏移量 Ciphertext = \u0026#34;\u0026#34; for i in Plaintext: if i not in ascii_uppercase: Ciphertext += i else: Ciphertext += chr(((ord(i) - ord(\u0026#34;A\u0026#34;) - Key) % 26) + ord(\u0026#34;A\u0026#34;)) return Ciphertext print(Encrypt(Plaintext, Key)) # 直接输出加密结果 运行结果：\n凯撒加密 - 加密示例\n爆破脚本 由于密钥情况很少，可以直接爆破枚举出来，\n观察找出有意义的字符串，则为明文。\nfrom string import ascii_uppercase Ciphertext = \u0026#34;DXJB.DOXKYIRBCXKQXPV.GM\u0026#34; # 在这里输入密文 Ciphertext = Ciphertext.upper() def Decrypt(Ciphertext, Key): # 解密函数，假定加密过程为减少偏移量 Plaintext = \u0026#34;\u0026#34; for i in Ciphertext: if i not in ascii_uppercase: Plaintext += i else: Plaintext += chr(((ord(i) - ord(\u0026#34;A\u0026#34;) + Key) % 26) + ord(\u0026#34;A\u0026#34;)) return Plaintext for Key in range(26): # 爆破密钥，范围为0~26 print(\u0026#34;Key = \u0026#34;, Key, \u0026#34;---\u0026gt;\u0026#34;, Decrypt(Ciphertext, Key), sep=\u0026#34;\u0026#34;) 运行结果：\n凯撒加密 - 解密示例\n可以发现Key = 3时，\n出现了一串有意义的字符串GAME.GRANBLUEFANTASY.JP。\n注意这里的密钥不一定正确，\n因为加密过程可能为增加偏移量，也可能为减少。\n但密钥对我们来说并不重要，所以不用在意其正确性。\n\r 0x03 关键词加密 定义 关键词加密(Keyword Cipher)也是一种单表替代加密，与凯撒加密不同之处在于密钥可以更为复杂。\n加密时需要选择一个关键词，\n如果这个关键词有重复的字母，去除除第一次出现之外的所有的相同的字母。\n e.g.\n如果选定的关键词为“success”，则使用“suce”。\n 将该关键词写在字母表的下方，并用字母表的其他字母按标准的顺序填写余下的空间，\n这样就构建了字母一一对应关系的密码表。\n加密时用下面一行中的字母对应替换上面一行的字母；\n解密时用上面一行中的字母对应替换下面一行的字母。（也可能反过来）\n  类型：单表替代加密。 加密对象：一般为字母。 加密方式：用关键词（密钥）生成密码表，然后按照密码表替换字母。 安全性：一般。\n密钥不能轻易枚举出来，\n但通过密码分析可能破译出密码。  示例 生成密码表 假定关键词为angstromcf。\n则生成密码表如图：\n关键词加密 - 生成密码表\n上面一行为标准的字母表。\n下面一行先将关键词angstromcf填上，\n然后将剩余未出现的字母，按照顺序填入。\n加密 对于明文：actf{yum_delicious_salad}。\n定加密的替换方式为：上面一行替换下面一行，\n即：将明文中的上面一行中的字母，对应替换成下面一行的字母。\n e.g.\n第一个a字母，替换成a，\n第二个c字母，替换成g，\n第三个t字母，替换成q。\n 则得到密文：agqr{yue_stdcgciup_padas}。\n解密 对于密文：agqr{yue_stdcgciup_padas}。\n由于加密时为上面一行替换下面一行，\n所以解密的替换方式为：下面一行替换上面一行，\n即：将密文中的下面一行中的字母，对应替换成上面一行的字母。\n e.g.\n第一个a字母，替换成a，\n第二个g字母，替换成c，\n第三个q字母，替换成t。\n 则得到明文：actf{yum_delicious_salad}。\n0x04 仿射加密 「这个比前面的要稍微复杂一点。」 —— Am473ur\n\r 比较复杂的加密方法，因为涉及到一定的数学知识。\n定义 在仿射加密中，如果只对字母加密（注意这个前提），\n则每个字母都对应一个数字（字母a~z分别对应数字0~25）。\n密钥为：$0\\sim25$之间的数字对$(a,b)$。\n其中$a$与$26$的最大公约数必须为$1$，$\\gcd(𝑎, 26) = 1$\n即$a$与$26$互素。\n e.g.\n$a = 5$就可以，\n因为只有$1$能整除$5$和$26$，$\\gcd(5, 26) = 1$。\n$a = 2$就不可以，\n因为$\\gcd(2, 26) = 2$。\n 记：$p$为明文字母对应的数字，$c$为密文字母对应的数字。\n 加密算法为： $$c \\equiv a \\cdot p + b \\pmod{26}$$ 需要注意是计算完$a \\cdot p + b$再取模。\n也就是代码为(a*p+b)%26，而不是a*p+(b%26)。\n\r 解密算法为： $$p \\equiv a^{-1} \\cdot (c-b) \\pmod{26}$$ 其中$a^{-1}$代表$a$的逆元。  特别的：当$a=1$时，这种加密方法就是凯撒加密，其中$b$就是偏移量。\n 需注意这种方法的加密对象也可能包括数字等其他符号。\n 其实前面的加密方法也可以包括其他字符。\n比如凯撒加密，只需要把012接在xyz后面参与加密即可。\n 如加密方式为+2，\n则明文abc xyz 012 789，加密为cde z01 234 9ab。\n 不过前面的加密方式一般均为字母，\n而仿射加密则有可能包含数字（如后面的例题）。\n 只需要把其他字符也对应一个相应的编号即可。\n甚至可以就用ASCII码表，就可以加密所有ASCII表中的字符了。\n e.g.\n对于a这个字符，转化为数字97，\n假设通过加密算法运算，得到结果为33，转化为字符!。\n则将a加密为!。\n对于7这个字符，转化为数字55,\n假设通过加密算法运算，得到结果为83，转化为字符S。\n则将7加密为S。\n那么对于字符串Nico2333...，\n其中所有的字符都可以加密，而不只是针对字母加密，\n加密结果如6$Ja8www(((。\n 然后对于要加密的字符表中，总字符个数为$m$个，\n那么$a$和$b$的取值范围$0 \\sim (m-1)$，满足$\\gcd(a,m)=1$\n同时模数为$m$。\n因此真正加密算法应该是： $$c \\equiv a \\cdot p + b \\pmod m$$ 其中$m$代表字符个数，\n$a∈(0,m-1), b∈(0,m-1)$，且需满足$\\gcd(a,m)=1$。\n  类型：单表替代加密。 加密对象：字母、数字等均可。 加密方式：将每个符号转换为数字$p$后，通过公式计算$c \\equiv a \\cdot p + b \\pmod{26}$，再将$c$转换为对应符号。 安全性：较差。\n若加密对象只为字母，且为一层仿射加密，则情况数为$12\\times26 - 1 = 311$种，也可以枚举得到。\n若情况种数较多，仍可能通过密码分析破译出密码。  方法原理 以下部分设计较多的数论知识，如只用来做题可以不必详细了解原理。\n\r 仿射加密原理\r对于这些古典加密方法，\n最重要的就是加密函数需要满足一一对应关系，即为双射函数，\n这样才能保证加密后可以正确解密。 【如果为一对多或多对一，那么加密后解密则会造成混乱，因为不存在反函数。\n首先将符号映射成一个唯一数字（编号），\n经过加密算法运算后，\n因为这个加密算法为线性方程$ax+b$，并且最终会对字符个数$m$取模，\n这样可以保证运算后的结果仍在字符集编号范围中，可以转换为对应符号。\n但注意这样运算后，并不能确保为一一对应关系，\n e.g.\n字符集只有四个，即$m=4$，编号为$0,1,2,3$，\n取$(a,b)=(2,1)$，\n经过加密算法$c \\equiv a \\cdot p + b \\pmod m$\n对于$0$，运算后为$1$，\n对于$1$，运算后为$3$，\n对于$2$，运算后为$1$，\n对于$3$，运算后为$3$。\n则并不为一一对应关系，通过密文无法得到明文。\n 而要确保为一一对应，即使加密算法为双射函数，\n则需要满足$\\gcd(a,m)=1$，即$a,m$互质。\n对于以下证明，可能需要先了解有关同余和线性同余方程的相关知识，\n可以查看本博客的文章ACM学习笔记：线性同余方程……中的“前提知识”和“初步认识”章节。\n 证明：\n要证明当$\\gcd(a,m)=1$时，函数$E(p)=(a \\cdot p + b) \\bmod m$为双射函数，\n可以采用反证法。\n  反证多对一不成立：\n假设存在$p_1,p_2 \\in [0, m-1]$，且$p_1 \u0026lt; p_2$，\n满足$a \\cdot p_1 + b \\equiv C \\pmod m$，$a \\cdot p_2 + b \\equiv C \\pmod m$，\n即：$a \\cdot p_1 + b \\equiv a \\cdot p_2 + b \\pmod m$。\n则有： $$a \\cdot p_1 + b + m \\cdot n = a \\cdot p_2 + b (n \\in N^+)$$ $$a \\cdot (p_2 - p_1) = m \\cdot n (n \\in N^+)$$ $∵p_2 - p_1 \\in N^+$ $$p_2 - p_1 = a \\mid (m \\cdot n)$$ 由定义可知：\n$∵\\gcd(a, m) = 1$\n即$m$不能被$a$整除，\n所以只能是$n$为$a$的整数倍，才能使得$a \\mid (m \\cdot n)$。\n$∴n / a \u0026gt;= 1$\n$∴p_2 - p_1 \u0026gt;= m$\n$∴p_1$和$p_2$不可能同在$[0,m-1]$范围内，与假设矛盾，故不成立。\n  反证一对多不成立：\n假设存在$C_1, C_2 \\in [0, m-1]$，且$C_1 \u0026lt; C2$，\n满足$a \\cdot p + b \\equiv C_1 \\pmod m$，$a \\cdot p + b \\equiv C_2 \\pmod m$，\n即：$C_1 \\equiv C_2 \\pmod m$。\n则有：\n$$C_1 + m \\cdot n = C_2 (n \\in N^+)$$\n$∴C_2 - C_1 \u0026gt;= m$，\n$∴C_1$和$C_2$不可能同在$[0,m-1]$范围内，与假设矛盾，故不成立。\n  由此可知，该函数只能为一一对应，即为双射函数。\n 参考自\u0026quot;hahastudio\u0026quot;在V2EX上对 「数论，加密，仿射变换后唯一性问题」问题的回答。\n 满足了为双射函数，还有一个重要的点就是：\n该函数的反函数容易求得。\n否则也不能轻易地解密。\n而这个求余操作的反函数，需要用到一个叫“逆元”的东西。\n加密算法为：$c = (a \\cdot p + b) \\bmod 26$，\n则解密算法为：$p = (c - b) \\cdot a^{-1}$\n对于逆元的了解，\n可以查看本博客的文章ACM学习笔记：线性同余方程……中的“2. 线性同余方程的反函数”章节。\n 证明：\n【看了上面链接文章里的内容后，这里就应该很好理解了吧应该……\n$$c \\equiv a \\cdot p + b \\pmod{m}$$ $$c - b \\equiv a \\cdot p \\pmod{m}$$ $$(c - b) \\cdot a^{-1} \\equiv a \\cdot p \\cdot a^{-1} \\pmod{m}$$ $$(c - b) \\cdot a^{-1} \\equiv p \\pmod{m}$$\n因为$p \u0026lt; m$，\n所以$p = (c - b) \\cdot a^{-1}$，得证。\n \r 逆元求解 对于逆元的求解，Python中有两个函数可以求解。\n  可以用Python的第三方库gmpy2的invert函数。\nfrom gmpy2 import invert ans = invert(5, 26) # 表示求5对模数26的逆元。ans = 21 print(ans) # 21 gmpy2包的安装方法可查看\u0026quot;osc_e45irv7l\u0026quot;的「python3安装gmpy2」文章。\n  可以用Python的第三方库Crypto的inverse函数。\nfrom Crypto.Util.number import * ans = inverse(5, 26) # 表示求5对模数26的逆元。ans = 21 print(ans) # 21 Python3中Crypto库安装可以输入命令pip install pycryptodome\n  两者区别在于：\n对于逆元的求解，两数必须互素。\n如果输入的两参数不互素，\ngmpy2的invert函数会使程序报错，\n而Crypto的inverse不会，其会返回一个很怪的结果【是先将两参数除掉一个最大公约数让其互素，再返回结果……\n加密脚本 from string import ascii_lowercase table = ascii_lowercase # 定义字符集 MOD = len(table) # 确定模数m def Encrypt(Plaintext, A, B): # 加密函数 Ciphertext = \u0026#34;\u0026#34; for i in Plaintext: if i not in ascii_lowercase: Ciphertext += i else: rawIndex = table.find(i) # 先将字符转换为数字编号 cipherIndex = (rawIndex * A + B) % MOD # 加密函数计算 Ciphertext += table[cipherIndex] return Ciphertext 爆破脚本 首先由于状态数少，所以可以枚举爆破。\n并且我们知道答案格式的开头为flag，\n所以可以只查找爆破结果为flag开头的字符串输出，得到正确答案。\nfrom Crypto.Util.number import * from string import ascii_lowercase table = ascii_lowercase # 定义字符集 MOD = len(table) # 确定模数m def crack(): # 爆破a、b函数 for A in range(MOD): for B in range(MOD): if (A*table.find(\u0026#34;f\u0026#34;)+B) % MOD == table.find(Ciphertext[0]): # 按当前a、b加密f字符后，与密文第一位相同 if (A*table.find(\u0026#34;l\u0026#34;)+B) % MOD == table.find(Ciphertext[1]): # 按当前a、b加密l字符后，与密文第二位相同。【后两句if类推 if (A*table.find(\u0026#34;a\u0026#34;)+B) % MOD == table.find(Ciphertext[2]): if (A*table.find(\u0026#34;g\u0026#34;)+B) % MOD == table.find(Ciphertext[3]): # flag均匹配，证明就为当前a、b return (A, B) def Decrypt(Ciphertext, A, B): # 解密函数 Plaintext = \u0026#34;\u0026#34; inv = inverse(A, MOD) # 求得A对Mod的逆元 for i in Ciphertext: if i not in table: Plaintext += i else: rawIndex = table.find(i) # 先将字符转换为数字编号 plainIndex = (rawIndex - B) * inv % MOD # 解密函数计算 Plaintext += table[plainIndex] return Plaintext 如果为其他格式开头，相应修改即可。\n例题 对于字符串vjsg{dckvzksr}，\n其采用了单层仿射加密，字符集为小写字母，\n请解密出flag。\n已知最终flag为纯数字。\n加密过程 可以先尝试解题，\n没有思路再根据加密过程得到思路。\n加密过程\rfrom string import digits, ascii_lowercase from secret import numbers, A, B table = ascii_lowercase # 定义字符集 MOD = len(table) # 确定模数m assert min([i in digits for i in numbers]) # 验证flag格式正确，不用管 print(\u0026#34;numbers =\u0026#34;, numbers) flag = \u0026#34;flag{\u0026#34;+\u0026#34;\u0026#34;.join([ascii_lowercase[int(i)] for i in numbers])+\u0026#34;}\u0026#34; print(\u0026#34;flag =\u0026#34;, flag) assert numbers == \u0026#34;\u0026#34;.join([str(ascii_lowercase.find(i)) for i in flag[5:-1]]) # 验证flag格式正确，不用管 def Encrypt(Plaintext, A, B): # 加密函数 Ciphertext = \u0026#34;\u0026#34; for i in Plaintext: if i not in ascii_lowercase: Ciphertext += i else: rawIndex = table.find(i) # 先将字符转换为数字编号 cipherIndex = (rawIndex * A + B) % MOD # 加密函数计算 Ciphertext += table[cipherIndex] return Ciphertext print(\u0026#34;Ciphertext =\u0026#34;, Encrypt(flag, A, B)) 运行结果：\n仿射加密 - 例题 加密运行结果\n其中的最终flag为flag{18453407}。\n 由代码分析可知，\n程序先从secret库中得到flag的数字部分。\n然后把数字按照位置转换为字母。\n e.g.\n将数字0转换为a。\n将数字1转换为b。\n将数字2转换为c。\n 最后再用secret库中的A和B，\n对flag进行仿射加密，得到密文。\n\r 解题过程 知道加密方式为一层仿射加密，且字符集为小写字母。\nflag的开头格式为flag。\n则可使用爆破脚本。\nfrom Crypto.Util.number import * from string import ascii_lowercase Ciphertext = \u0026#34;vjsg{dckvzksr}\u0026#34; # 在这里输入密文 table = ascii_lowercase # 定义字符集 MOD = len(table) # 确定模数m def crack(): # 爆破a、b函数 for A in range(MOD): for B in range(MOD): if (A*table.find(\u0026#34;f\u0026#34;)+B) % MOD == table.find(Ciphertext[0]): # 按当前a、b加密f字符后，与密文第一位相同 if (A*table.find(\u0026#34;l\u0026#34;)+B) % MOD == table.find(Ciphertext[1]): # 按当前a、b加密l字符后，与密文第二位相同。【后两句if类推 if (A*table.find(\u0026#34;a\u0026#34;)+B) % MOD == table.find(Ciphertext[2]): if (A*table.find(\u0026#34;g\u0026#34;)+B) % MOD == table.find(Ciphertext[3]): # flag均匹配，证明就为当前a、b return (A, B) def Decrypt(Ciphertext, A, B): # 解密函数 Plaintext = \u0026#34;\u0026#34; inv = inverse(A, MOD) # 求得A对Mod的逆元 for i in Ciphertext: if i not in table: Plaintext += i else: rawIndex = table.find(i) # 先将字符转换为数字编号 plainIndex = (rawIndex - B) * inv % MOD # 解密函数计算 Plaintext += table[plainIndex] return Plaintext A, B = crack() print(\u0026#34;A = {}, B = {}\u0026#34;.format(A, B)) flag = Decrypt(Ciphertext, A, B) print(flag) print(\u0026#34;\u0026#34;.join([str(ascii_lowercase.find(i)) for i in flag[5:-1]])) 运行结果：\n仿射加密 - 例题 爆破运行结果\n得到最终flag为flag{18453407}。\n0x05 单表替代密码分析 定义 之前的三种加密算法，均为单表替代加密。\n也就是一个字母与一个字母一一对应的关系。\n单表替代加密无论过程如何，\n最终都形成了一张密码表，\n加密解密都通过查表来进行。\n因此如果我们不知道具体采用什么加密方法，\n就只需要知道哪个字母对应哪个字母，\n分析出一张“密码表”，\n就能对单表替代加密的密文进行解密了。\n这种分析过程就是单表替代密码分析。\n采用分析，甚至可以不用知道密钥是什么，就可以直接得到明文。\n分析方法 如果暴力枚举分析得到密码表，\n则情况数为$26\\times25\\times24\\times\\cdots\\times2\\times1 = 26! = 403291461126605635584000000$。\n因此除非加密方法简单，否则几乎不可能通过枚举得到密码表。\n 基本分析方法有三种：\n 词频分析 双联分析 模式匹配  将三种分析方法综合运用，找出可能性最大的结果。\n词频分析 下图为单个英文字母在文章中出现的频率：\n词频分析 - 词频表\n我们对于一串较长密文（如对文章加密），统计每个字母出现的频率。\n如果发现某一字母与上表字母的频率接近，\n则两字母应该是对应关系。\n e.g.\n分析后若得到密文中字母X的频率接近为$10.39%$，接近$10.47%$。\n因此可以推测密文X对应明文T。\n 双联分析 词频分析是针对单个字母进行分析，\n同时英语单词中也有很多连续的两字母出现频率很高，\n称作双联字母(bigrams)。\n因此可以用双联分析来辅助我们进行分析。\n下表为1000个单词中，各双联字母出现次数。 双联分析 - 次数表\n模式匹配 另外，如果有一个较大的单词库，\n还可以通过单词的格式，进一步帮助我们缩小可能的范围。\n e.g.\n单词happy，为12334格式，\n单词success，为1233411格式。\n 那么被进行单表替换后，它的格式并不会发生改变。\n这种模式匹配的优点在于：\n即使密文长度较短，也能尽可能找到接近真相的结果。\n如果密文长度较短，则词频分析和双联分析很可能不正确。\n\r 工具：\n利用模式匹配尝试解密单表替代加密的网站。\n0x06 维吉尼亚加密 维吉尼亚密码是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码。\n为了生成密码，需要使用密码表。\n这一密码表包括了26行字母表，每一行都由前一行向左偏移一位得到。\n维吉尼亚加密 - 密码表\n具体使用哪一行字母表进行加密是基于密钥进行的，\n在过程中会不断地变换。\n  类型：多表替代加密。 加密对象：一般为字母。 加密方式：根据密钥依次查表替换，得到密文。 安全性：较强。\n多表加密中，对于两个相同的字符，并不一定都会加密为两个相同的字符。\n如第一个a可能加密为g，但第二个a可能加密为o。\n所以能避免直接的词频分析攻击。\n必须要知道密钥才能得到明文。  加密过程 首先有一串明文和一串密钥，\n其中密钥长度要小于明文。\n e.g.\n明文为SUPERSASSW，\n密钥为NICO。\n  将密钥调整到跟明文一样的长度。\n操作方法为不断重复密钥。  调整后密钥为NICONICONI。\n  通过等长的明文和密钥，\n将明文作为列标，密钥作为行标（也可能反之），\n依次查表，得到密文。  如第一位：\n明文为S，密钥为N，\n对应表的N行S列，则密文为F。\n    一位位查表完成后，\n得到密文为：FCRSEACGFE。\n可以明显发现：\n明文中四个同样的S，\n被分别加密为不同的F、A、G、F。\n由于明文与密文并不为一一对应关系，\n所以可以避免直接的词频分析攻击。\n 解密过程 解密的过程就是加密过程反过来。\n e.g.\n密文FCRSEACGFE，密钥为NICO。\n调整密钥为与密文等长字符串为NICONICONI。\n根据密钥第一个字母F所对应的N行字母表，\n发现密文第一个字母F位于S列，\n因而明文第一个字母为S。\n密钥第二个字母C对应I行字母表，\n而密文第二个字母C位于此行U列，\n因而明文第二个字母为U。\n以此类推便可得到明文。\n 破解方法 1. 分析长度 为了传输方便，一般来说密钥都很短小，\n所以密钥会重复，以达到明文的长度。\n首先提出破解方法的\u0026quot;Frederick Kasiski\u0026quot;是基于这样一个简单的观察：\n“密钥的重复部分与明文中的重复部分的连接，在密文中也产生一个重复部分”。\n如果一个字符串在明文中重复，并且被密钥相同的部分加密，那么在密文中也会出现重复的字符串。\n密文中出现的重复字符串的前后长度，则是关键词长度的倍数。\n密文中出现足够多次，就可以根据这几个长度的倍数，来确定真实的长度。\n直接看文字可能难以理解，结合下面的例子更好理解。\n\r  e.g.\n维吉尼亚加密 - 破解例子\n$(9,6)$的公约数只有$1$和$3$，\n而$1$不可能为密钥长度（否则变为单表加密），\n故密钥长度则为$3$。\n 2. 转化为单表加密问题 找到密钥的长度$n$后，\n则多表加密的问题便可以转化为$n$个单表加密的问题。\n e.g.\n如上例。\n找到长度为$n=3$后，\n则对于从左往右第$1$、$4$、$7$、$\\cdots$位，运用的都是同一种单表加密方式。\n同理：对于第$2$、$5$、$8$、$\\cdots$位，和$3$、$6$、$9$、$\\cdots$位，也是另一种单表加密。\n对每一种单表加密逐个分析，得到部分明文，\n最终就能得到整个明文。\n 0x07 替换和编码 古典加密还包含很多种形式的简单替换和编码。\n这些替换也常常出现Misc中，如：\n Morse电码 敲击码 福尔摩斯跳舞的小人\n替换和编码 - 福尔摩斯跳舞的小人 表 培根密码\n替换和编码 - 培根密码  有关编码内容可以阅读Misc部分的数据编码笔记。\n类型和编码 替换和编码 - 类型和编码\n 密码学中数字主要研究整数。  类型转换 整数进制转换 x = 123456 # 十进制整数 x_hex = hex(x)[2:] # 十进制转十六进制 print(\u0026#34;hex:\u0026#34;,x_hex) # hex: 1e240 x_bin = bin(x)[2:] # 十进制转二进制 print(\u0026#34;hex:\u0026#34;,x_hex) # bin: 11110001001000000 # x_hex与x_bin均为字符串类型 x_a = int(x_hex, 16) # 十六进制转十进制 print(x_a) # 123456 x_b = int(x_bin, 2) # 二进制转十进制 print(x_b) # 123456 字符串类型转换 字符串(str)类型和字节(bytes)类型相互转换。\n 字符串类型是纯文本类型。\n而字节类型是二进制数据。\n表示为b'...'，其中...为可读表示方法。\n s = \u0026#34;flag{qwqqqOrzzz}\u0026#34; # 字符串类型 s_bytes = s.encode() # 字符串类型转字节类型 print(s_bytes) # b\u0026#39;flag{qwqqqOrzzz}\u0026#39; s_str = s_bytes.decode() print(s_str) # flag{qwqqqOrzzz} 整数和字节类型转换 这种类型转换在密码方向题目中很常见。\n【但个人刚入门，暂时不知道转换为整数类型有什么用，等以后见识到了再补充_(:з」∠)_……\n整数类型可以直接参与数学计算，\n字节类型会展示可读的字符。\nfrom Crypto.Util.number import * s = b\u0026#39;flag{this_is_flag}\u0026#39; # 字节类型 s_int = bytes_to_long(s) # 字节类型转为整数 print(s_int) # 8922333133093133239960474404255406756030333 s_bytes = long_to_bytes(s_int) # 整数转字节类型 print(s_bytes) # b\u0026#39;flag{this_is_flag}\u0026#39; 编码 Base64编码 import base64 s = b\u0026#39;flag{this_is_flag}\u0026#39; # 字节类型 s_encode = base64.b64encode(s) # 进行base64编码 print(s_encode) # b\u0026#39;ZmxhZ3t0aGlzX2lzX2ZsYWd9\u0026#39; s_decode = base64.b64decode(s_encode) # 进行base64解码 print(s_decode) # b\u0026#39;flag{this_is_flag}\u0026#39; 0x08 写在最后 以上大部分为个人总结，由于这里也刚入门，很多地方可能存在错误。如发现错误请及时指出，谢谢！……\n\r 由于目前博客不支持附件上传下载，所以如果需要上述中的文件，可以联系我分享文件【联系方式在关于页面中有……\n\r 如对以上内容存在疑惑不解的地方，也可以询问我。如果我了解的话会尽力解答；不了解的话可以一起努力弄明白hhh……\n\r\n这部分涉及到数论的知识，故可能会感觉有点难……\n个人刚好为了学ACM数论知识点，补了ACM方面的笔记，算是一举两得2333……\n感谢Am473ur师傅的辛勤付出！……\n以上……\n","date":"2021-02-04T00:00:00Z","image":"https://blog.supersassw.com/p/ctf-note-crypto_1/85100927_p0_hu5c6c9f4da506a8b7dfcc39af1be1b7cf_10213578_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/ctf-note-crypto_1/","title":"Crypto - 古典密码……"},{"content":"以下为涅普计划的课程笔记，建议搭配课程视频理解。\n\r 流量分析：\n利用流量分析工具，抓取网络请求中的各种流量数据包，\n分析其中的信息，并得到自己所需要的有用信息（如flag）。\n0x00 课程视频 课程视频\r\r\r视频Bilibili链接\r 0x01 所需工具  Burp Suite Nmap Packet Tracer Wireshark  0x02 互联网五层模型 基本介绍：\n互联网五层模型 - 基本介绍 1\n实际上互联网应该是七层模型，但因为具体实现上大部分只实现了五层，所以这里只介绍五层模型。\n\r 这五层并不是层次关系，而是一种包含关系，\n也就是说：物理层中包含了一个数据链路层、数据链路层包含了一个网络层，以此类推。 互联网五层模型 - 基本介绍 2\n当信号传导对应层时，该层的信息就会被切去。\n e.g.\n当信息通过物理层传输完成后，其物理层的信息就会被切去，\n这之后信息通过数据链路层，其数据链路层的信息就会被切去。\n 个人没有详细去了解以下部分（互联网五层模型），\n只是大致写了课程中所讲到的内容。\n但其知识点又较为复杂，\n如需更深入了解可自行查阅相关资料。\n\r 物理层 物理层就是在现实世界中数据的传输方式。\n其有很多传输方式，不同方式的原理不同。\n比如：\n Wi-Fi无线通信——通过电磁波来进行传输。 千兆网线——通过其中八根金属芯进行传输。 百兆网线——通过其中四根金属芯进行传输。   物理层在传输到一个信息后，\n会被计算机将其中的物理信号，调制解调成数据链路层的一个信号，\n也就是一个以太网帧格式的信号。\n数据链路层 在数据链路层中，每台设备都被分配了对应的且独一无二的MAC地址（物理地址）。\n MAC地址：\n每个网卡都有个独一无二的MAC地址，\n当网卡被厂家生产出来的时候，就已经有一个确定的MAC地址。\n 以太网协议属于数据链路层，\n其协议主要体现在以太帧上。\n以太帧中的网络数据包分为两个主要地址：\n一个是源地址的MAC地址，\n一个是目的地址的MAC地址。\n当某台计算机想给另外一台计算机发送消息时，\n需要在以太帧头中指明发送方和接收方的MAC地址。\n网络层 当我们计算机的网络较为大且复杂的时候，\n我们使用简单的MAC地址并不能很好的管理网络。\n因为MAC地址是和硬件绑定的，\n因为假如我们更换了计算机设备，那么就需要重新配置网络的信息。\n这个时候IP地址网络协议就诞生了。\n 在网络层中，每台设备都被分配了一个虚拟的且独一无二的IP地址（网络地址）。\nIP地址与MAC地址的关系：\n可以是一对多，也可以是多对一。\n也就是说一个MAC地址可以分配给多个IP，\n同一个IP也可以被多个网卡（MAC地址）所使用。\n根据ARP协议，可以将物理地址和网络地址相互转换。\n网络层 - ARP举例\n子网与网段的概念 通过与子网掩码的与运算，可以从逻辑上把一个大网络划分成一些小网络。\n 子网掩码：\n是由一系列的1和0构成，通过将其同IP地址做“与”运算来指出一个IP地址的网络号是什么。\n对于传统IP地址分类来说：\nA类地址的子网掩码是255.0.0.0；\nB类地址的子网掩码是255.255.0.0；\nC类地址的子网掩码是255.255.255.0。\n  e.g.\n将一个B类网络166.111.0.0划分为多个C类子网来用的话，\n只要将其子网掩码设置为255.255.255.0即可。\n这样166.111.1.1和166.111.2.1就分属于不同的网络了。\n 像这样，通过较长的子网掩码将一个网络划分为多个网络的方法就叫做划分子网。\n一般来说，对于192.168.1.x与192.168.2.x，其属于不同的网段，\n要通过路由器，使得不同网段能相互访问。\n传输层 在网络层的基础上，我们完成了数据通过IP地址的传送，\n但是我们仍然要确保数据传输的可靠性。\n这里便产生了许多协议，如：\n UDP协议 TCP协议  UDP协议 是不可靠连接。\n因为不能确定对方是否收到数据包。\nQQ通讯使用的OICQ协议，也是基于UDP协议。\nTCP协议 要点为三次握手和四次挥手。\n总览图：\nTCP - 过程总览\n三次握手 流程：\n SYN\n客户端向服务端发送一个请求连接包，\n标识符为SYN J。 SYN, ACK\n服务端收到请求连接包，并对SYN J进行确认，\n然后发送一个回复包，标识符为SYN K, ACK J+1。 ACK\n客户端向服务端发一个确认收到回复包，\n标识符为ACK K+1  抓包如图：\nTCP - 三次握手抓包\n四次挥手 流程：\n FIN M ACK M+1 FIN N ACK N+1  应用层 基本协议：\n HTTP SSH SFTP  都是基于UDP或TCP等传输层的协议来实现的。\nHTTP报文 应用层 - HTTP请求和响应报文\n请求报文：\n应用层 - HTTP请求报文\n响应报文：\n应用层 - HTTP响应报文\nHTTP与HTTPS协议区别 HTTP是未加密的，可以直接被Wireshark截获；\n而HTTPS是加密的，请求的路径和内容是不能被直接截获的。\n将这些加密的协议统一称为\u0026quot;TLS\u0026quot;或\u0026quot;SSL\u0026quot;加密协议。\n0x03 流量分析工具 Wireshark 用于流量数据包的抓包、记录、分析等。\n开始界面 Wireshark - 开始界面\n其中显示的是捕获到的各种本地接口。\n 以太网：表示的是用网线进行上网的物理接口。 WLAN：表示的是用Wi-Fi进行上网的物理接口。 VMware：虚拟机上网使用的虚拟接口。 VPN：使用VPN上网的网络接口。 USBPacp：USB的接口。   当同时连接以太网和WLAN时，\n决定使用哪个接口的是跃点数。\n跃点数越低，优先级越高。\n对于计算机来说，默认情况下：\n物理网口往往比无限网口跃点数低。\n所以默认使用以太网接口。\n打开网络接口 可以在这里截获这个接口上传输的流量包。\n例一——HTTP 以国家企业信用信息公示系统网页为例：\n刚访问网站时，我们会向网站服务器发送一个GET类型的request数据包，\n作用是得到刚进入网站的首页index.html这个网页文本。 截获流量包 - GET的request内容\n根据这个request数据包，网站服务器会返回一个response数据包，\n当前这个请求的response数据，包就是网页的内容。 截获流量包 - response返回内容\n 使用浏览器访问页面后，发现其使用的是不安全的HTTP协议。\n截获流量包 - 不安全图示\n因此用过滤器过滤出HTTP，然后寻找GET /index.html。 截获流量包 - 过滤HTTP\n这个数据包就是网络中负责请求的request数据包。\n其必然对应于一个返回的response数据包，\n查看下方\u0026quot;Hypertext Transfer Protocol\u0026quot;中的\u0026quot;Response in frame\u0026quot;，\n可以得到返回的数据包在所截获数据包中的编号\u0026quot;No.\u0026quot;。（双击即可跳转到该response数据包）\n e.g.\n上面GET的request数据包中，\n截获数据包 - response数据包所在帧\n发现在编号No.174处。\n截获数据包 - response数据包 即对应这一数据包\n 查看response数据包中的\u0026quot;Line-based text data: text/html\u0026quot;，\n可以看到相同的HTML内容。 截获数据包 - response数据包内容\n例二——HTTPS 以国家税务总局四川省税务局网页为例：\n可以发现其使用的是安全的HTTPS协议。\n截获流量包 - 安全图示\n此时单纯过滤HTTP数据包，\n无论怎么刷新网页，都是无法过滤出这个网站所产生的数据包的。 截获流量包 - HTTPS\n 此时数据包采用了TLS协议加密，\n所以我们无法直接截获。\n数据导出 可以使用如下方法导出Wireshark中所有的HTTP包的数据。\n 选择\u0026quot;File - Export Objects - HTTP\u0026hellip;\u0026quot;\nWireshark - 数据导出 方法1 1 Wireshark - 数据导出 方法1 2 也可以在某个TCP包上面选择\u0026quot;右键 - Follow - TCP Stream\u0026quot;，从而获取一整个TCP连接的数据。\nWireshark - 数据导出 方法2 1  保存 点击菜单栏中的“文件 - 保存”，\n能将所有截获的流量包，保存为pcapng格式文件。\n以供今后分析使用。\nCTF应用  给个流量包，从中找到flag。\n简单的题目可以直接字符串查找flag。  Cisco Packet Tracer 网络拓扑模拟的软件。\n网络连线  不同设备用直连线（实线） 相同设备用交叉线（虚线）  当两台计算机直接连接通信的时候，发挥主要作用的是物理层。\n计算机将信号发送到网线上，另外一台计算机负责接收。\n网络设备 集线器 Hub 应用于物理层。\n集线器对接收到的信号进行再生整形放大，以扩大网络的传输距离，\n同时将所有结点集中在以它为中心的节点上。\n采取广播式发送，而不是针对式发送。\n会将数据包发送至与集线器相连的所有节点。\n相当于多台计算机同时连接在一根导线上。\n 优点：\n 便宜。  缺陷：\n 不安全。 如果有黑客成功将自己电脑接线于集线器上，\n那么其就能监听截获其他设备所发送给另外设备的数据包。 可能信号冲突。  交换机 Switch 应用于数据链路层。\n利用以太网协议，\n主要体现在以太帧上。\n交换机在接收到信号之后，\n会告知交换机要发送的设备的网卡的MAC地址是多少。\n于是交换机会根据这个地址正确将信号转发至某一端口（即网线），\n从而避免了网络内所有计算机都能收到信号。\n起到了信号隔离的作用，也成为隔离冲突域。\n 同时支持分别发送和广播式发送。\n将目的地址写为0.0.0.0，便能广播式发送。\n 优点：\n 安全性高。  缺点：\n 如果网卡坏了，MAC地址需要更改，则不能用之前的MAC地址。\n需要刷新记录的MAC表。  路由器 路由器能使设备之间跨网段访问。\n相当于一个网关。\n如图所示网络\n路由器 - 网络举例\n两个网段分别是192.168.0.0/24和192.168.1.0/24。\n网关则是路由器连接每个网段的接口。\n e.g.\n192.168.0.2想与192.168.1.4跨网段通信，\n则需要把消息转发给路由器上的网关，\n路由器再根据IP地址转发。\n Nmap/NetCat 有关这两个工具师傅并未很详细讲到具体作用和与CTF有关联系，\n于是个人写的很简略，并且可能存在错误。\n但稍微查询感觉这两个工具作用很大，\n需要深入了解可以自我查询相关资料。\n\r 基于TCP协议的监听或发送数据的命令。\nNetCat用netcat或nc；\nNmap用ncat。\n两者使用方法差不多。\n 输入ncat (地址) (端口)，\n可以连接上该地址，并发送简单的TCP数据包。\n参数  -lk (端口)：监听某一端口。 --chat：在服务器中启动聊天服务。  e.g.\nncat -lk (端口) --chat。\n   0x04 课堂练习与个人解析 1. 上课认真听了吗 题目描述 flag在三种不同的流量中。\n 附件：\n udphttptcp.pcapng\n本题所需分析的流量包  解题方法 三种流量分别对应今天所学的TCP、HTTP、UDP。\n下载流量包后用Wireshark打开。\n 首先尝试直接搜索关键字flag{。\n按Ctrl+F打开搜索栏，\n第一个选项栏选择“分组字节流”，\n 有关第一个选项栏中三个选项的解释：\n 分组列表：代表的是最上面的窗口，在Info栏中进行搜索。 分组详细：代表的是中间的窗口。 分组字节流：代表的是最下面的窗口，在十六进制文件中搜索。 第三个选项栏选择“字符串”，\n搜索框中填写flag{。\n第一题 - 搜索栏设置   一直搜索，会分别搜索到三个flag。\n第一个flag\rUDP帧：\n第一题 - UDP帧\nflag内容：\n第一题 - UDP flag\n第二个flag\rTCP帧：\n第一题 - TCP帧\nflag内容：\n第一题 - TCP flag\n第三个flag\rHTTP帧：\n第一题 - HTTP帧\nflag内容：\n第一题 - HTTP flag\n 之前提到过，HTTP协议也是基于TCP协议实现的，\n所以这里现实的类别也是TCP协议。\n在详细窗口中，可以发现\u0026quot;Reassembled PDU in frame: \u0026hellip;\u0026ldquo;这样一个超链接字段，\n第一题 - HTTP帧 - Reassembled PDU in frame\n双击后，便可以找到最开始的HTTP数据包。\n第一题 - HTTP帧 - 跳转回HTTP帧\n \r 对这三个flag排列组合测试，得到最终的flag：flag{25434026}。\n2. 我是间谍 题目描述 我是间谍，我在干什么呢？\n 附件：\n imaspy.exe\n需要分析的“恶意软件”，分析其发送流量的数据包。  解题方法 首先需要注意的是：\n对于恶意软件，我们应该在一个隔离的环境中运行，\n也就是应该在一台虚拟机或沙盒中运行该软件。\n【虽然这道题中的程序并不是真的恶意程序……\n并且由于宿主机中流量很多，不好轻易找出恶意软件的流量，\n所以更应该在虚拟机中运行。\n 但这里还是直接在宿主机中运行并抓取流量的。\n虽然流量很多不好直接找到，\n但我们仍可以用万能的搜索。\n 启动Wireshark监听并运行程序。\n待程序执行完成并关闭窗口后，\n跟上道题一样，直接在分组字节流中搜索字符串flag{。\n可以直接得到flag。\n第二题 - 搜索内容\n这里只写了课堂上的两道习题。\n有关课后的两道习题，在视频最后部分师傅有所解答，\n可以去视频中查看。\n\r  0x05 写在最后 因为个人水平原因，这篇笔记可能写的很简略不清晰或存在很多错误，请见谅！……\n\r 这部分有点不知道怎么做笔记……\n只可意会不可言传的那种感觉_(:з」∠)_……\n而且很多知识（比如网络方面）如果要真去弄懂，又要学很多方面的东西……\n想了好久才最终把这个整理完成orzzz……\n写得好乱【……\n以上大部分为个人总结，由于这里也刚入门，很多地方可能存在错误。如发现错误请及时指出，谢谢！……\n\r 由于目前博客不支持附件上传下载，所以如果需要上述中的文件，可以联系我分享文件【联系方式在关于页面中有……\n\r 如对以上内容存在疑惑不解的地方，也可以询问我。如果我了解的话会尽力解答；不了解的话可以一起努力弄明白hhh……\n\r\n感谢fjh1997师傅的辛勤付出！……\n以上……\n","date":"2021-02-03T00:00:00Z","image":"https://blog.supersassw.com/p/ctf-note-misc_3/57890506_p0_hu20a1b54dc3f8ad2cd21d3e328c8fd47f_537572_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/ctf-note-misc_3/","title":"Misc - 流量分析……"},{"content":"以下为涅普计划的课程笔记，建议搭配课程视频理解。\n\r 0x00 课程视频 课程视频\r\r\r视频Bilibili链接\r 0x01 常见进制与进制转换 常见进制 计算机领域中，常用进制有：\n 二进制(Binary、bin) 八进制(Octal、oct) 十六进制(Hexadecimal、hex)  有关这几种进制的优缺点、用处分析，可见“六六”在知乎问题“二进制，十进制，十六进制各有什么优缺点？”中的回答。\n\r 而在计算机中，存储信息归根到底都是以二进制存储的。\n八进制和十六进制，只是为了简化二进制的表达，方便观察记录。\n 如将1010 0101 1100 1011这复杂的一串二进制，转化为十六进制就为A 5 C D，更方便记录和观察。\n 进制转换 因为信息都是以二进制的形式存储，所以二进制可以转换为各种信息。\n进制转换类别\n1. 二进制转ASCII码 每八位为一个整体，将其转换为十进制后，对应ASCII码表查询得到对应的字符。\n e.g.\n一串二进制串01101110 01101001 01100011 01101111，\n将其按每八位一节转换为十进制后为110 105 99 111，\n查询ASCII码表，得到字符串nico。\n 2. 二进制转Morse码 跟二进制转ASCII码一样，\n将一串二进制转化为ASCII码中的.和-和␠(空格)，来表示摩尔斯码。\nMorse码中：\n . 对应的ASCII码为46、二进制为0010 1110。 - 对应的ASCII码为45、二进制为0010 1101。 ␠ 对应的ASCII码为32、二进制位0010 0000。   e.g.\n一大串二进制数据：\n00101101 00101110 00100000 00101110 00101110 00100000 00101101 00101110 00101101 00101110 00100000 00101101 00101101 00101101\n发现其中仅由00101101、00101110、00100000三种二进制节构成，对应于-、.、␠，故可知应为Morse码的二进制。\n使用二进制转Morse转换工具，得到-. .. -.-. ---，\n在使用Morse转文本转换工具，得到nico这个文本。\n 3. 二进制转二维码 对于一二进制字符串，转成十进制、十六进制后分析不出有用信息，\n若其长度$n$，满足$n=a^2(a∈Z)$，也就是这个长度是个完全平方数(如$625$），\n可以考虑转换为二维码。\n其中0则代表白色，1则代表黑色。（也可能为反过来）\n转换方式使用Python中的PIL(Pillow)库，按上述规则将二维码绘制出来。\nPython代码：\nfrom PIL import Image MAX = * # 在这里输入二维码的长宽（为二进制字符串长度开根） str = \u0026#34;...\u0026#34; # 在这里输入二进制字符串 pic = Image.new(\u0026#34;RGB\u0026#34;,(MAX, MAX)) i = 0 for y in range(0, MAX): for x in range(0, MAX): if (str[i] == \u0026#39;1\u0026#39;): pic.putpixel([x,y], (0, 0, 0)) # 为1，填充黑色 else: pic.putpixel([x,y], (255, 255, 255)) # 为0，填充白色 i += 1 pic.show() # 打开生成的二维码 pic.save(\u0026#34;flag.png\u0026#34;) # 保存二维码为flag.png  e.g.\n例题中所生成的二维码：\n进制转换 - 二进制转二维码例子\n 4. 二进制转图片 先将二进制字符串转换为十六进制，\n再用十六进制编辑器，将转换后的十六进制数据，写入到新的文件中。\n e.g.\n对于例题所给的长串二进制，\n先使用工具将其转换为十六进制，\n进制转换 - 转图片 转十六进制\n然后打开十六进制编辑器，新建十六进制文件（不是文本文件），\n将转换后的十六进制结果，粘贴到新文件中。\n注意：010 Editor粘贴十六进制文本的快捷键位Ctrl+Shift+V，并非Ctrl+V。\n\r 进制转换 - 转图片 写入十六进制文件\n可以发现文件头尾分别为FF D8和FF D9，可知为JPG文件，\n保存为JPG格式文件，可得到转换后的图片。\n进制转换 - 转图片 转换得到图片\n 0x02 常见编码 ASCII 【应该都很熟悉这个ASCII码了……\n把常用的字符（如a ~ z、A ~ Z、0 ~ 9、常用符号等），以一个特定的数来表示。\n则可以将常用的字符，转化为二进制数并且直接存储到计算机中。\n标准的ASCII定义了128个字符，刚好为$2^7$个，所以部分ASCII码以每7位二进制为一个组合，来表示这128种字符。\n但通常来说，为了统一，都是以每8位二进制为一个组合，最高位补0。\n以下为ASCII码表可显示字符部分：\nASCII码表 - 可显示部分\n控制字符部分(0 ~ 31)可查看ASCII编码对照表。\n\r Base家族 base64 为最为常见的编码。\n编码原理 把3个8位的字节转化为4个6位的节，\n之后在每个6位的节的前面补两个0，重新形成8位（一字节）形式。\n6位的二进制最大容量为$2^6 = 64$，故其字符集只有64个字符，\n分别为A ~ Z、a ~ z、0 ~ 9、+、/。\nbase64编码表\n e.g.\nbase64转换例子\n  虽然=是不存在于编码表的，但其可能会出现在base64编码后的字符串中，\n其作用是：\n当字符不为$3$的倍数个时，会先用0将末尾补全，再用=表示填补了多少字节(8bits)的0。\n e.g.\nA的ASCII是0100 0001，只有8位，\n则会用0补成24位，变成0010 0001 0000 0000 0000 0000，\n然后划分成4个6位后高位补0，即为00010000 00010000 00000000 00000000， 对照表编码后即为QQ，补了$2$个字节的0，所以最终为QQ==。\n注意：不能将末尾补的00000000看作A。\n\r\n 但为了避免=在URL和Cookie中产生歧义，部分base64编码也会把=去掉。\n作用 可能有人会不懂发明这个base64编码有什么作用（比如我），\n为什么不能直接传输原来的文本数据，而要通过这个base64编码后再传，\n甚至编码后占用空间还变大了.jpg……\n个人查阅学习了以后稍微有所理解，这里稍微写下来记录一下。 【以下为个人理解，很有可能有错误，仅供参考！……\n个人理解的base64作用\r首先对于各种文本的编码，如果只是简单的西欧文本（也就是ASCII码中包括的东西，如字母），处理就相对统一。\n但对于其他文本（如中文、俄文等），简单的ASCII码不能满足，于是会有各种其他的编码方式来处理这些文本（如GBK、JIS等）。\n需注意这里的文本编码方式，都是怎么将我们这些各种字符，转化为数字（二进制）运用到计算机中。\nASCII码也是，就是将“a”字符传化为二进制0110 0001来处理。\n\r\r这些编码方式，普遍与ASCII码的编码方式有区别。\n其中最突出的就是：\n ASCII码的一字节8位中，最高位是0的， 其他编码方式，很可能会使最高位位1。  比如对于汉字“你”，\n以UTF-8方式编码后，为111100100 10111101 10100000（hex: E4 BD A0)\n可以发现与标准的ASCII码对比，最高位是1。\n   注意标准ASCII码与扩展ASCII码的区别：\n标准的ASCII码最高位是0，也就是范围为0 ~ 127。\n而对于那些最高位是1的ASCII码，是之后扩充的，其属于不可见字符，\n对这些不可见字符，不同国家的处理方式也会不同。\n所以只有最高位是0（范围为0 ~ 127）的ASCII码为真正的统一标准。\n\r\r 这样的后果就是：\n一些设备，对于传输过来的标准ASCII码中字符数据，处理方式都是一样的没问题。\n但对于那些不可见字符的处理方式，就很可能不一样。\n 比如传输了一个“a”过来，其以ASCII码传输为0110 0001，\n对于这个，所有设备都知道它是个“a”这个字符，所以能正确传输，\n而对于“你”这个汉字，如果直接UTF-8编码后传输过来为111100100 10111101 10100000，\n不同设备的处理方式就会不同了。\n 比如有些可能强行将最高位变为0，传输成011100100 00111101 00100000，就完全不同了，\n有些可能把这个当成个控制命令，而不是继续传输这个数据。\n   所以经过bse64编码后，将所有字符转化为标准ASCII码，\n就能有效地避免在传输过程中的歧义操作了，\n传输完成后再解码回来就可以了。\n\r 以下base编码方式大部分与base64相同，唯一区别只是字符集不同，故不再给出编码原理。\n\r base36 字符集 0 ~ 9、A ~ Z(或a ~ z)\n包含$0 \\sim 9$的数字，加上所有$26$个字母（不区分大小写，即大写或小写均可）。\n不包含任何标点。\n特点  加密仅支持整数数字。 解密仅支持字符串。 不支持中文。  base58 字符集 123456789、abcdefghijk、mnopqrstuvwxyz、ABCDEFGH、JKLMN、PQRSTUVWXYZ。\n仅包含部分数字和部分字母，\n其中不包含：\n 0（数字0） l（小写L） O（大写o） I（大写i）  特点 为base64的字符集中，\n去掉了四个容易引起视觉混淆的字符(0、l、O、I)，和两个符号(+、/)。\n$9$个数字$+49$个字母$=58$，所以称为base58。\nbase62 区别于base64的地方只是去掉了+和/。\nbase85 base85不太常用。\n类似于base64的二进制文本编码形式，\n通过使用$5$个ASCII字符来表示四个字节的二进制数据。\n 这个base85个人暂时不是很理解，\n因为大于了$2^6=64$，所以跟base64的编码原理应该是不一样的，\n字符集也不清楚。\n【但网上也很少关于base85的资料orz……\n目前只找到一份图，看样子应该是将4个字节划分为$6+7+6+7+6$这种划分形式转换为ASCII码的。\nbase85 - 例子\n来源于Base系列编码浅析。\n因为说不常用就没深入去了解，\n想要了解可以到google查阅英文文档看看吧。\nbase91、92 base91的字符集为：0-9、a-z、A-Z、!#$%\u0026amp;()*+,./:;\u0026lt;=\u0026gt;?@[]^_`{|}~\u0026quot;（就是你键盘上除了\\、-、'能打出来的所有符号）\nbase91 - 字符集\nbase92比base91多一个〜（注意不是~）\n 这两个编码方式相关资料很少，\n只用了解并且会使用转换工具应该就可以了，不需要太深入掌握吧应该【……\n转换工具  网络上各种base编码转换工具。 CyberChef中Magic模块。\n特点：可自动识别为哪种base编码。 CyberChef中的 \u0026ldquo;From base \u0026hellip;\u0026rdquo; 模块。  Morse电码 【简介略……\nMorse电码表\n计算机中表示方法：\n 用.来表示点 -来表示划 常用空格␠来表示分割  shellcode shellcode是一段用于利用软件漏洞而执行的代码。\nshellcode为16进制的机器码，因为经常让攻击者获得shell而得名。\n 在这里其实就是一串16进制数据，\n先转换为10进制，然后解码成ASCII即可。\n e.g.\n一串shellcode\\x54\\x68\\x65，\n转换为10进制为84 104 101，\n对照ASCII码则为The。\n urlencode url编码又称百分号编码，是统一资源定位(URL)编码方式。\nURL地址（网址）中规定：\n数字、字母和特定字符（/、,、:、@等）可以直接使用，\n其余必须通过%xx来编码。\n（其中的xx代表ASCII的十六进制。）\n也就是说编码形式上跟shellcode差不多，不过把\\x换成了%而已。\n e.g.\nThe编码成urlencode就是%54%68%65\n 关于urlencode的拓展\r经常可以见到，在地址栏中，一些汉字就会变成%xx这样的编码形式。\n也就是这些汉字先以UTF-8编码变成16进制，然后又按urlencode加上%。\n e.g.\n萌娘百科中童田明治的页面URL为：https://zh.moegirl.org.cn/%E7%AB%A5%E7%94%B0%E6%98%8E%E6%B2%BB，\n“童田明治”以UTF-8编码成十六进制数据后，分别为：\n E7 AB A5（童） E7 94 B0（田） E6 98 8E（明） E6 B2 BB（治）  对应到上方的URL中，就是%E7%AB%A5等。\n \r Unicode 中文又称国际码、万国码等。\n表示形式：\n 十六进制表示  \\u**** \u0026amp;#x****;   十进制表示  \u0026amp;#****;    Unicode与UTF-8等的区别与联系 个人在学习的时候发现这两类东西很迷惑，网上各种说法也很混淆。\n通过查找资料加上自我脑补x后，对这两类稍微明白了一点。\n于是这里顺带提一下UTF-8、UTF-16等UTF-*编码，及其与Unicode编码的关系。\n【内容太多故做折叠处理……\n两类的区别联系\r首先对于Unicode编码，\n其跟ASCII码一样，是一种对字符的编码方式，\n或者以术语来称呼，是一种“字符集”。\n其完成的是一种“字符—数字”的一一映射的转换。\n 比如ASCII码中，对于A这个字符，对应的数字（十进制）为65，也就是将字符A映射到数字65，\nUnicode编码中，对于A这个字符，对应的数字（十进制）为41，也就是将字符A映射到数字41。 而Unicode编码中，对于\n Unicode其实也有个跟ASCII码一样的表，不过太大了所以一张图放不下x……\n 其实Word中的“插入字符”，其就是按照Unicode的编号顺序来排列的，\n可以看作一张跟ASCII码表一样的Unicode码表：\nWord中的Unicode码表\n下方的字符代码，则是这个符号在Unicode这个映射表中对应的数字的十六进制形式。\n  Unicode本身是不断在扩充的，\n最初它只选择了2个字节(16位)，最多能表示$2^{16} = 65536$个字符。\n但这里说选择2个字节实际上不恰当，因为Unicode并不是一种存储方式，而只是一种字符与数映射关系。存储方式由后面讲的UTF-8来决定\n\r\r后面发现$65536$个也不够，所以又在前面加了8位，称为“扩展位”，\n一共24位，最多能存$2^{24} = 16777216$个了。\n【但这样扩展后又太多了，目前扩展位最多只用到了10(hex)，也就是Unicode范围为000000 ~ 10FFFF。\n【【等到以后发现外星语后就可能再扩充，一直用到FFFFFF这样吧233333……\n这里可以牢记两个对应思想：\n $1$位十六进制对应$4$位二进制 $1$字节对应$8$位，也就是$2$位十六进制。  \r\r 请注意：上面所说的Unicode只是一种字符集，一种对应方式，并没有涉及到怎么存储。\n这里就可能会感到奇怪：明明通过Unicode，都对应成了数字，为什么不能直接像ASCII码一样把数字存下来就好了？\n对啦！这种想法就是Unicode的存储方式之一——直接把序号存下来，跟ASCII码一样。\n这种存储方式就叫做UTF-32。\nUTF-32编码方式：\n将Unicode中的序号转换为16进制，再最高位补0至32位。\n e.g.\n对于“🀀”这个符号来说，【不要管为什么要举麻将啦2333【因为这个序号大一些这样……\n其Unicode序号是126976，\n也就是在Unicode这张表中，将字符🀀映射成了数字126976，\n转换为16进制为1F000，\n那么按我们想的，直接把这个序号数字存储下来，\n但注意计算机中最好按$2^n(n∈N^+)$个字节来存储，【具体原因好像是因为内存对齐？……\n这里已经是$5*4=20$位了，2个字节不够，\n所以只能选择4个字节，也就是32位来存。\n那么跟很多编码操作一样，最高位补0， 于是变成了001F 0000。\n那么也就是按UTF-32编码后🀀则被编码成001F 0000。\n  可以发现，\nUTF-32好处就是非常直观，\n但缺点也很明显：太浪费空间了。\n原本用ASCII编码，1个字节就能存储表示的英文字母，\n到UTF-32编码，就要用4个字节了。\n这在当时昂贵的存储代价和极扣x的程序员们的眼中是不能忍受的！\n于是他们又机智地创造出别的编码方法，\n也就是UTF-8和UTF-16。\n这两种编码方法具体怎么实现这里就不讲了，有兴趣可以自己查阅。\n但可以知道的是：\nUTF-16用$2$或$4$字节，\nUTF-8用$1\\sim4$字节。\n无论怎样，都比UTF-32纯用$4$字节好多了。\n 那么对于以上，可以总结出以下说法：\n  Unicode只是一种字符集，是一种字符对应数字的映射，并不能说是一种编码。\n  各种UTF-*才真正实现了Unicode在计算机上的存储，才能说是编码。\n  Unicode可以对字符进行“初步编码”，然后用\u0026amp;#、\u0026amp;#x、\\u来表示。\n 真，Unicode序号为30495(hex:771F，可以表示为\u0026amp;#30495;、\u0026amp;#x771F;、\\u771F。\n   UTF-*是对Unicode编码后的数字进行的的一种“再编码”。\n   更多扩展\r对于网络上各种Unicode编码工具，\n如果只是简单的对中文编码是不存在问题的。\n而对版本较新，序号较大（16进制用了5位及以上）的字符，则会出现问题。\n 仍以序号比较大的🀀为例：\n首先通过网站查询，得到以下信息。\nUnicode - 符号🀀信息\n将重要信息已经用红线划出。\n查询地址\n则Unicode编码结果应该为\u0026amp;#126976;、\u0026amp;#x1F000;、\\u1F000\n 站长工具\n站长工具 - Unicode编码结果\n发现与推断出的不符合。 SOJSON在线解析\nSOJSON在线解析 - Unicode编码结果\n点击HTML预览后，很明显看到左上角为两个乱码。   如果需要正确转换，可以使用千千秀字中的HTML字符实体转换工具。\nHTML字符实体转换工具\n 刚接触Unicode时，总会将其与ASCII比较，\n但现在可以发现：\nASCII编码，实际上是字符集和编码方法的整合。\n字符集就是基本的ASCII码表，\n不过其编码方法十分简单粗暴，字符集对应的序号是多少，编码后就是多少。\n而Unicode中，字符集有了后，\n本来也有跟ASCII一样简单粗暴的编码方法，就是UTF-32，\n但当时的储存代价很高，于是人们将扣的艺术运用到机制，\n创造了UTF-16、甚至UTF-8这些编码方式，减小了储存消耗。\n这也产生了现在的歧义。\n 假想一下：\n如果当时技术力就很高，储存代价极小，\n有可能像ASCII那样，就用UTF-32存，\n不用再去想UTF-8这种抠门方式，\n那应该今天就不会有这种Unicode于UTF-8是什么关系的迷惑了_(:з」∠)_……\n \r\r\r aaencode 使用颜文字进行的编码。\n特点：\n可以将JavaScript代码编码，并且可以直接执行。\n也就是常说的颜文字js加密。\n e.g.\n一段js代码，\nalert(\u0026#34;nico\u0026#34;) 将这段js代码用aaencode编码后，\nﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [\u0026#39;_\u0026#39;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: \u0026#39;_\u0026#39; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ \u0026#39;_\u0026#39;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;)[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +\u0026#39;_\u0026#39;) [c^_^o];(ﾟДﾟ) [\u0026#39;c\u0026#39;] = ((ﾟДﾟ)+\u0026#39;_\u0026#39;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [\u0026#39;o\u0026#39;] = ((ﾟДﾟ)+\u0026#39;_\u0026#39;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [\u0026#39;c\u0026#39;]+(ﾟДﾟ) [\u0026#39;o\u0026#39;]+(ﾟωﾟﾉ +\u0026#39;_\u0026#39;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +\u0026#39;_\u0026#39;) [ﾟｰﾟ] + ((ﾟДﾟ) +\u0026#39;_\u0026#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [\u0026#39;c\u0026#39;]+((ﾟДﾟ)+\u0026#39;_\u0026#39;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [\u0026#39;o\u0026#39;]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ];(ﾟДﾟ) [\u0026#39;_\u0026#39;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+\u0026#39;_\u0026#39;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +\u0026#39;_\u0026#39;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +\u0026#39;_\u0026#39;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=\u0026#39;\\\\\u0026#39;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +\u0026#39;_\u0026#39;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=\u0026#39;\\\u0026#34;\u0026#39;;(ﾟДﾟ) [\u0026#39;_\u0026#39;] ( (ﾟДﾟ) [\u0026#39;_\u0026#39;] (ﾟεﾟ+/*´∇｀*/(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+(ﾟｰﾟ)+(ﾟΘﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟｰﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+(ﾟｰﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((o^_^o) +(o^_^o))+((o^_^o) - (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((o^_^o) +(o^_^o))+(ﾟｰﾟ)+(ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+(c^_^o)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+((o^_^o) - (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+((o^_^o) +(o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟΘﾟ)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+(ﾟｰﾟ)+(o^_^o)+(ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+((ﾟｰﾟ) + (ﾟΘﾟ))+((ﾟｰﾟ) + (o^_^o))+(ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+((o^_^o) - (ﾟΘﾟ))+(ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+(ﾟΘﾟ)+(ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (\u0026#39;_\u0026#39;); 使用开发者工具中控制台执行这段编码后的代码效果：\naaencode - 效果\n可以看到效果确实同alert(\u0026quot;nico\u0026quot;)。\n 【这是什么稀奇古怪又可可爱爱的编码方式啊.jpg……\njjencode 用途等同\u0026quot;aaencode\u0026quot;，\n不同在于jjencode使用$、=、+、_、[、]等符号进行编码。\n e.g.\n同上例，\nalert(\u0026#34;nico\u0026#34;) 将这段js代码用jjencode编码后，\n$=~[];$={___:++$,$$$$:(![]+\u0026#34;\u0026#34;)[$],__$:++$,$_$_:(![]+\u0026#34;\u0026#34;)[$],_$_:++$,$_$$:({}+\u0026#34;\u0026#34;)[$],$$_$:($[$]+\u0026#34;\u0026#34;)[$],_$$:++$,$$$_:(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$],$__:++$,$_$:++$,$$__:({}+\u0026#34;\u0026#34;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+\u0026#34;\u0026#34;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+\u0026#34;\u0026#34;)[$.__$])+((!$)+\u0026#34;\u0026#34;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$.__$])+($._=(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!\u0026#34;\u0026#34;+\u0026#34;\u0026#34;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+\u0026#34;\\\u0026#34;\u0026#34;+$.$_$_+(![]+\u0026#34;\u0026#34;)[$._$_]+$.$$$_+\u0026#34;\\\\\u0026#34;+$.__$+$.$$_+$._$_+$.__+\u0026#34;(\\\\\\\u0026#34;\\\\\u0026#34;+$.__$+$.$_$+$.$$_+\u0026#34;\\\\\u0026#34;+$.__$+$.$_$+$.__$+$.$$__+$._$+\u0026#34;\\\\\\\u0026#34;)\u0026#34;+\u0026#34;\\\u0026#34;\u0026#34;)())(); 运行后一样的效果。\n uuencode 是二进制信息和文字信息之间的转换编码。\n常用于电子信息的传输。\n 具体编码过程没有去了解。\n【能够了解并使用工具转换就可以了x……\njsfuck 跟\u0026quot;aaencode\u0026quot;和\u0026quot;jjencode\u0026quot;差不多。\n区别是：用六个字符[]()!+来重新编码。\nbrainfuck 跟\u0026quot;jsfuck\u0026quot;、\u0026ldquo;aaencode\u0026quot;和\u0026quot;jjencode\u0026quot;差不多。\n【你呀，总能给我玩点新花样【指js……\n区别是：用八个字符[]\u0026lt;\u0026gt;+-.,来重新编码。\nOok 比赛中常见。\n有两种形式。\n1. \u0026ldquo;Ook!\u0026rdquo; 由Ook.、Ook!、Ook?三个字符串组成。\n2. \u0026ldquo;Short Ook!\u0026rdquo; 只有.、!、?三个字符组成。\n 经典例题：\n在图片的lsb隐写中，藏有ShortOok!。\nOok - 经典例题\n 敲击码 是一种很简单的对文本信息进行编码的方式。\n基于$5\\times5$的方格（波利比奥斯方阵）来实现，\n区别在于：K字母被整合到C中。\n敲击码\n e.g.\nF，对应位置为$(2,1)$，所以可以编码为21。\n 二维码 用某种特定的几何图形按一定规律，在平面分布的黑白相间的图形，来记录数据符号信息。\n种类：\n 堆叠式/行排式（堆积式或层排式） 矩阵式  常见的二维码：\n Code 16K Code 49 PDF417 QR Code  二维码 - 常见形式\n矩阵式二维码 最流行的就是QR Code，\n也就是我们常说的二维码。\n其是在一个矩阵空间通过黑、白像素在矩阵中的不同分布进行编码。\n用点（方点、圆点或其他形状）的出现表示二进制1，\n不出现表示二进制0，\n点的排列组合确定了矩阵式二维码所代表的意义。\n矩阵式二维码是建立在计算机图像处理技术、组合编码原理等基础上的一种新型图形符号自动识读处理码制。\n代表性的矩阵式二维码：\n Code One MaxiCode QR Code Data Matrix Han Xin Code Grid Matrix  QR Code 特点  储存大容量信息。\n传统的条形码只能处理$20$位左右的信息量，QR码可以处理条形码几十到几百倍的信息量。 支持所有类型的数据。（如：数字、英文字母、日文字母、汉字、二进制、控制码等） 在小空间内可打印。\n使用纵向和横向两个方向处理数据，所以相同信息量，QR码所占空间为条形码十分之一。（Micro QR码可以更小） 解码速度快。  基本结构  格式信息：纠错等级 版本信息：即二维码规格（QR码符号共有$40$种规格的矩阵）  二维码 - 基本结构\n考点  将定位点拿掉，需要自己去补充定位点。 修复二维码。\n基于纠错等级，只给部分信息，需要自己补全。\n可以使用工具：QRazyBox。\n解题方法：使用工具先调整纠错等级，使得跟残缺二维码一致；然后再手动填充。\n\r  稀奇古怪的编码 以下编码由于特点明显，故不详细介绍。均可以直接搜索相关编码解码工具。\n\r 社会主义核心价值观编码 特点：由社会主义核心价值观十二个词构成。\n与佛论禅 特点：开头为“佛曰：”。\n与熊论道 特点：开头为“熊曰：”。\n 0x03 写在最后 以上大部分为个人总结，由于这里也刚入门，很多地方可能存在错误。如发现错误请及时指出，谢谢！……\n\r 由于目前博客不支持附件上传下载，所以如果需要上述中的文件，可以联系我分享文件【联系方式在关于页面中有……\n\r 如对以上内容存在疑惑不解的地方，也可以询问我。如果我了解的话会尽力解答；不了解的话可以一起努力弄明白hhh……\n\r\n感谢1cePeak师傅的辛勤付出！……\n以上……\n","date":"2021-02-02T00:00:00Z","image":"https://blog.supersassw.com/p/ctf-note-misc_2/87075144_p0_hu955303b5c4388e9f242f6715e6abbbd5_906682_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/ctf-note-misc_2/","title":"Misc - 数据编码……"},{"content":"以下为涅普计划的课程笔记，建议搭配课程视频理解。\n\r 图片隐写：\n将一些不可告人x的东西（如flag）以各种方式隐藏在图片中。\n自已需要分析出隐写方法，并找出隐藏的信息。\n0x00 课程视频 课程视频\r\r\r视频Bilibili链接\r 0x01 准备工具 十六进制编辑器  \u0026ldquo;010 Editor\u0026rdquo;\n优点：有模板（需要安装）\nTip: 复制16进制的快捷键为Ctrl+Shift+C。 \u0026ldquo;WinHex\u0026rdquo;  其实也称二进制编辑器，因为文件都是以bin二进制来存储的，不过为了阅读方便，将8位2进制串转化为2位16($2^4=16$)进制串。\n虚拟机——\u0026ldquo;Kail\u0026rdquo; 相关命令   strings\n打印文件中可打印的字符。\n作用：可找出图片中隐写的字符串。\n例子\r在终端中输入strings strings.jpg后\nKali - strings\n可以看见\u0026quot;Nepnep{welcome}\u0026ldquo;和\u0026quot;print(hell oworld)\u0026ldquo;这两条信息。\r   grep\n用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。\n输入grep -a \u0026quot;flag\u0026quot; xxx.jpg\n则会把文件中含\u0026quot;flag\u0026quot;字符串部分前后显示出来。\n例子\r如图：\nKali - grep\n可以看见\u0026quot;BJD{haokanma_xjj}\u0026ldquo;这个flag。\r   file\n用于辨识文件类型。\n可以显示文件的格式，属性等信息。\n例子\r对\u0026quot;strings-file\u0026quot;这个无后缀名文件进行分析。\nKali - file\n可以看见文件的基本信息，为JPEG文件。\nTip: JPEG和JPG是同一个格式。\n\r\r\r      binwalk\n用于搜索给定二进制镜像文件以获取嵌入的文件和代码的工具，即可以查看文件中含有的其他文件。\n在CTF中binwalk常用于分析隐藏文件。\n参数：\n -e 分离出文件到新文件夹中（但可能不全）。  例子\r输入binwalk xxx.png\nKali - binwalk\n输入binwalk -e xxx.png 得到新文件夹，里面有提取出的文件。\nKali - binwalk -e Kali - binwalk -e\n\r   foremost\n注意：需要使用apt-get install foremost安装。\n也可以提取文件（也不一定能提取所有文件）。\n比较于binwalk，binwalk更加强大，速度也快。但是有时候如果不能分离出来，就可以试试看foremost。\n例子\r输入foremost xxx.png后，得到output文件夹，其中目录树如图。\nKali - foremost\n其中png文件夹中为原图片，而jpg文件夹中则为分离处的新图片。\naudit.txt则为所分离文件的信息。\n\r   dd 搭配binwalk分析后，指定提取文件。\n命令为dd if=xxx.png of=out.jpg bs=1 skip=***\n 参数解释：\n if=xxx.png为要分离的文件名。 of=out.jpg为输出的文件名。 bs=1为每次读取几个块（一般为1）。 skip=***为从哪里开始读入（搭配binwalk分析后确定）。\n如上面输入binwalk命令后，可得知内含的JPEG文件从271007开始，则此处skip=271007。     0x02 知识点 文件头文件尾 每个文件格式有相应的文件头和文件尾，可通过十六进制编辑器查看。\n e.g.\n.jpg：开头——FF D8，结尾——FF D9。\n 重点：超过文件尾的部分不会被读取。\n文件模板 以十六进制查看方式打开后，若存在对应模板，\n则会将整个十六进制划分成一个个部分，每部分会有各自的作用。\n可根据模板的划分，快速确定某一部分十六进制代表什么意思，有什么作用，储存什么信息等。\n如图：\n文件模板\n可见通过PNG文件模板将十六进制分为了许多部分。\n最常用的信息如告知图片长宽、属性。\n文件属性 就是文件的属性【？……\n点击右键属性，可查看文件的一定属性信息。\n如图：\n文件属性\n0x03 图片隐写分类 图片隐写分类\n1. 属性隐写 【就单纯在文件属性（标题、作者等）中写东西，很少用……\n2. 16进制隐写 一般在文件的16进制格式中增添或修改，达到隐写字符串的目的。\n常见形式：\n 在文件尾后直接隐写内容。  原理：文件不会读取超过文件尾的部分。   e.g.\n16进制隐写 - 文件尾\n可以发现文件尾后还有niconiconi这个字符串。\n  在中间部分隐写内容。  原理：有些时候在中间处修改添加内容，是不会或略微影响文件正常读取的，从而达到隐写的效果。 判断方法：图片可能会有所怪异，如中间有条线。  e.g.\n16进制隐写 - 例题\n可以发现黑丝【？】那有明显的一条线。\n     对应方法：使用Linux命令中的strings或grep。\n使用例见上方虚拟机——\u0026ldquo;Kail\u0026quot;的命令部分\n 不给出文件后缀名，不能直接判断出这个文件是什么格式。\n可以通过16进制编辑器，查看对应的文件头，从而找出是什么格式。\n3. 文件包含 隐写的内容可能为简单的字符串，也可能为若干个新的文件。\n解决方法：\n 通过Linux命令binwalk来分析或binwalk -a尝试分离。 通过Linux命令foremost来尝试分离。 通过Linux命令dd来尝试分离。  以上三种命令的使用例见上方虚拟机——\u0026ldquo;Kail\u0026quot;的命令部分。\n 直接以16进制编辑器\u0026quot;010 Editor\u0026rdquo;，将所隐藏的文件16进制部分写入到一个新的文件后并打开。  4. 文件头修改隐写 将文件头修改或删除，文件将不能读取。\n但破坏文件尾可能不会影响读取。\n需要通过16进制编辑器查看文件头尾部分，分析出该有的文件头。\n5. gif 特殊帧 隐藏在帧中的信息。\n e.g.\ngif - 特殊帧\n【需要点击图片才能查看动图】\n可以明显看见图中会闪过一些东西。\n 一般选择逐帧分析的方法。\n【当然可以选择用手速来截图查看【b站视频闪过图片的常用方法x……\n 逐帧分析工具：\n PhotoShop\n会将每帧分为一层图层，即可查看。 Stegsolve.jar\n打开图片后，点击\u0026quot;Analyse\u0026quot;中的\u0026quot;Frame Browser\u0026quot;也可以逐帧查看。 Ulead GIF  帧的时间间隔 信息也可能隐藏在帧时间间隔中。\n e.g.\n很多帧都是$0.1$s，但某几帧是$0.2$s，就很有问题.jpg……\n 采用\u0026quot;Ulead GIF\u0026quot;来查看帧时间间隔。\n6. png(bmp) 长高修改(IHDR) 可能通过修改宽高，隐藏了某些信息，\n通过16进制编辑器来修改查看。\n其中宽高信息则在模板中IHDR部分里可查看。\n一般是修改高，因为修改宽会导致不能正常显示。\n并且修改得大一点更好，避免重复修改。\n e.g.\n长高修改 - 修改高\n长高修改 - 发现隐写信息\n将该图片的高增大后，则可发现隐藏信息。\n  判断是否高被修改的方法：\n  通过检验CRC32确定。 当用\u0026quot;010 Editor\u0026quot;打开图片后，若输出窗口中会报错，显示CRC32有问题，证明这张图片的属性（如本类中的高）被篡改过。\n e.g.\nCRC32错误显示\n 也可以手动计算校验和来比对。\n手动计算方法\r 先选中IHDR到crc之前的部分。\n选中部分\n对应模板中的\u0026quot;union CTYPE type\u0026quot;和\u0026quot;struct PNG_CHUNK_IHDR_ihdr\u0026quot;两个部分。\n模板对应处 然后点击“工具”中的“校验和”，选择“CRC-32”。\n计算校验和 得到计算结果后与crc部分比对即可。\n计算出的校验和 文件中的校验和\n注意文件中的检验和是1FCF9E8E，没有那个h。  \r\n  脚本爆破来得到真实高度。\n就是暴力的意思，不断修改高度并比对校验和，如果一致则为正确高度。\n爆破python代码：\nimport os import binascii import struct misc = open(\u0026#34;***.png\u0026#34;,\u0026#34;rb\u0026#34;).read() # 请在这里填写要爆破的文件名 # 爆破高 crc32_bytes = misc[0x1d:0x20 + 1] # 文件IHDR块的crc32的bytes crc32_hex_eval = eval(\u0026#39;0x\u0026#39; + crc32_bytes.hex()) # 将crc32的bytes串 -\u0026gt; hex串 -\u0026gt; 值  for i in range(4096): data = misc[0x0c:0x0f + 1] + misc[0x10:0x13 +1 ] + struct.pack(\u0026#39;\u0026gt;i\u0026#39;, i) + misc[0x18:0x1c + 1] # 爆破IHDR数据 crc32 = binascii.crc32(data) \u0026amp; 0xffffffff # 计算当前crc32 if crc32 == crc32_hex_eval : print(\u0026#34;height:\u0026#34;, i) print(\u0026#34;height_hex: \u0026#34; + hex(i))   数据块IDAT修改 本来IDAT数据块是写满当前块后再换下一个块，\n但用\u0026quot;010 Editor\u0026quot;查看后发现有IDAT块有异常（不满足上述规律），故这个数据块可能藏有信息。\n检测方法：\n 使用pngcheck.exe来查看IDAT数据块情况。  e.g.\n输入pngcheck.exe -v ***.png后，\npngcheck\n发现最后部分有异常。\n    将该数据块十六进制提取出来后，用脚本或其他方法得到信息。\n得到信息方法：\n \u0026ldquo;010 Editor\u0026rdquo; + \u0026ldquo;zlib.py\u0026rdquo;\n用010查看后得到异常部分的16进制，复制后放入脚本运行可得到信息。\nzlib得到信息 用binwalk -e提取，直接得到信息。 binwalk得到信息  lsb隐写 为贝塔姐姐强调的部分。\n「接下来我们讲一个大头er~」 —— 贝塔\n\r 又称“最低有效位隐写”。\n将隐写内容转换为2进制，整合修改到图片2进制形式的最低位，使得颜色被修改程度极小，肉眼无法分辨。\n但可以通过某些命令或脚本来分辨出。\n不带密匙   通过\u0026quot;Stegsolve.jar\u0026quot;分析。\n用\u0026quot;Analyse\u0026quot;的\u0026quot;Data Extract\u0026rdquo;，一个个选项测试得到文本串或者新的文件。\n可参考\u0026quot;cat47\u0026quot;的文章stegsolve使用方法。\n  zsteg（很好用）\n使用命令zsteg xxx.png来查看各种方式下的文本串或者文件（如果这个命令中没有发现，则可以用zsteg -a xxx.png），\n然后用命令zsteg -e ...(分析的通道) \u0026gt; ***.xxx得到文件\n e.g.\n对某图片使用命令zsteg lsb.png后，\nzsteg - 分析\n发现b1,rgb,lsb,xy这个方式存在一个PNG文件。\n则使用命令zsteg -e b1,rgb,lsb,xy \u0026gt; ans.png得到文件。\nzsteg - 提取\n 可参考\u0026quot;β-AS\u0026quot;姐姐的文章隐写工具zsteg安装+使用教程。\n   带密匙 带密钥的可以用\u0026quot;cloacked-pixel\u0026quot;脚本。\n该脚本为python2环境，并且需要numpy、matplotlib、Pillow、pycrypto库的支持。\n由于为过气python2环境（且并无python3版本），所需配置较为复杂，所有注意事项已写在下方折叠栏中。\n\r cloacked-pixel脚本的各种注意事项\r同时安装python2和python3方法：\r请参考文章如何设置python2，python3，并添加环境变量。\r\rpython2库本地安装方式：\r感觉pip2现在好像不能在线安装库了【？……\n所以只能在pypi中将库下载到本地安装。\n选择合适的版本，下载到本地。\n下载完成后在cmd中，输入pip2 install ...(本地路径)。\n路径快速输入方法：输入pip2 install后，将文件直接拖入cmd窗口中即可。\n\r\r即可成功安装。\n参考自文章Python2.7本地安装numpy包\n\r\r上述库的下载地址：\r以下库为个人挨个查询并对应版本后下载，均为Python2.7所能支持的最新版本，可直接下载后按上述安装方法安装。\n\r\r numpy six cycle（需要先安装six） pytz kiwisolver python-dateutil backports.functools-lru-cache pyparsing matplotlib（需要先安装cycle、pytz、kiwisolver、python-dateutil、backports.functools-lru-cache、pyparsing） Pillow pycrypto（安装方法有所不同，请见python2.7 安装pycrypto库中“下载压缩包解压到本地”部分）\n同时安装时还需要\u0026quot;vcvarsall.bat\u0026quot;，方法为两步：   下载\u0026ldquo;Microsoft Visual C++ Compiler for Python 2.7\u0026rdquo;并安装。\n  按照完美解决“Unable to find vcvarsall.bat”错误中配置注册表。\n【其中路径为C:\\Users\\SuperSASSw\\AppData\\Local\\Programs\\Common\\Microsoft\\Visual C++ for Python\\9.0】\n不确定是否还需要配置环境变量（个人为配置了的），如果仍有问题，请点击开始菜单中的\u0026quot;Microsoft Visual C++ Compiler Package for Python 2.7\u0026quot;这个文件夹中，自己对应平台的\u0026quot;Visual C++ 2008 xx-bit Command Prompt\u0026quot;这个快捷方式。\n    以下折叠部分为安装crypto库所需库，但安装这个后发现不对（有个Random不存在orz……），\n查询后发现为上面那个\u0026quot;pycrypto\u0026quot;库。\n\r\rcrypto所需库\r shellescape PyYAML chardet certifi urllib3 idna requests（需要先安装chardet、certifi、urllib3、na） Naked（需要先安装YAML、requests）  \r\r 【弄了我好久啊这些库qwqqq太累了……\n\r\r\r 命令：\npython2 lsb.py extract ***.png *** KEY\n ***.png为源文件名。 ***为输出文件名。（由于不确定什么格式，可以先不加扩展名，用010查看后再加上对应扩展名） KEY为密匙。   e.g.\n输入命令python2 lsb.py extract lsb（123456）.png ans 123456\n带密匙的lsb - 使用脚本后结果\n打开ans后，发现直接为flag。\n带密匙的lsb - 打开ans文件\n bmp 用\u0026quot;wbStego4.3open\u0026quot;工具对bmp或pdf等格式文件进行加密解密。\n e.g.\n打开工具，按照步骤来执行就可以得到文件了。\nwbStego4.3open - 步骤2 选择方式 wbStego4.3open - 步骤3 选择文件及类型\nwbStego4.3open - 步骤4 输入密匙 wbStego4.3open - 步骤5 输入输出文件名\nwbStego4.3open - 结果\n Tip: 这个软件不能直接关闭，需要用任务管理器结束orz……\n\r  0x04 写在最后 以上大部分为个人总结，由于这里也刚入门，很多地方可能存在错误。如发现错误请及时指出，谢谢！……\n\r 由于目前博客不支持附件上传下载，所以如果需要上述中的文件，可以联系我分享文件【联系方式在关于页面中有……\n\r 如对以上内容存在疑惑不解的地方，也可以询问我。如果我了解的话会尽力解答；不了解的话可以一起努力弄明白hhh……\n\r\n剩余部分因为时间原因没有继续讲啦_(:з」∠)_……\n看好久有时间自学一下【？……\n再次感谢贝塔姐姐的详细讲解！【第一节课真的超不容易的……\n之前没有接触过CTF，不过了解后对其兴趣很高……\n希望经过这次涅普计划的系统学习能有很大的收获吧√……\n以上……\n","date":"2021-02-01T00:00:00Z","image":"https://blog.supersassw.com/p/ctf-note-misc_1/86016044_p0_hu66f5a9c42e7a0ea12354f65ca719fe6e_1732854_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/ctf-note-misc_1/","title":"Misc - 图片隐写……"},{"content":"题目链接 P4863 JerryC Loves Driving\n\r 题目分析 对于一层求和，其实就是一层for，那么两层求和就是两层for，也就是二维的。\n而对于求和O(n)的优化计算方法，最基本的就是转换为等差数列O(1)计算。\n我们将两层求和的每一项列表观察（看是否有等差数列），得出下表：\n求和表\n图片来自于「Insouciant21」的题解。\n观察发现，对于每一列，是类似呈等差数列的形式的，\n对于第$i$列，是由$i$个$0 \\sim n$的等差数列组成。\n 如第四列：为$4$个$0,1,2,\\cdots,n$的等差数列组成。\n 因此我们就可以O(1)计算出每一列的和，那么就只用按列循环依次求和，O(n)的时间内求出结果。\n 想到求解方法后，我们来确定求和计算范围。\n 以下以$A=2, B=7$来举例。\n 求和表范围1\n对于题上给出的两个界：上界$A$和下届$B$，\n按照题中所给公式，最初始的范围，则对应图中红色框选内容。\n由于0部分不影响，所以也可以看成蓝色矩形部分。\n但如果直接这样进行计算，会发现会有很多要考虑的地方，或说运用等差数列时有很多边界的处理。\n 如图中所给例子：\n对于$2$这一列，则上方的$1$并不完全属于$n$个等差数列中，要排除。\n对于$3$这一列，则下方的$-2$并不完全属于$n$个等差数列中，要排除。\n 于是我们可以想到对于求$f(A \\sim B)$这一范围，可以转化为求$f(B)-f(A-1)$这两范围的差。\n如图所示：\n求和表范围2\n则可以只用考虑下界的不符合。\n 这是一个很重要的方法：\n将两个不确定的界的函数($f(x \\sim y)$)，转化为两个有一个确定的界的函数之差（$f(C \\sim x)-f(C \\sim y)$）。（如定积分中经常运用）\n 解题方法 O(n)方法 对于每一列$i$：\n其和（的绝对值）为：$i$个$1,2,3,\\cdots,n$的等差数列的和，加上剩余非等差数列的部分。\n每一列均为$n - 0 + 1$即$n + 1$项。\n等差数列部分：\n首项——$a_1 = 0$；\n末项——$a_n = (n + 1) / i - 1$；【原因是：首先项数有$n+1$项（包括0行），整除$i$，则得到等差数列的项数，那么末项$a_n = a_1 + (n-1)*d$，即为项数$-1$。\n项数——$n = (a_n - a_1) / 1 + 1$（公差为1），即为$a_n + 1$。\n非等差数列部分：\n每一项均为$a_n + 1$；\n前面已经计算了$cnt * i$项，所以剩余部分的项数为$n + 1 - (cnt * i)$。\nO(√n)方法 首先根据上述的规律可以发现：\n 每一个数重复次数是按列递增的。  第$1$列是$1,2,3,\\cdots,n$，每个数出现$1$次；第$2$列是$1,1,2,2,3,3,\\cdots,n,n$，每个数出现$2$次。\n  奇数行和偶数行的符号是一样的。  基于以上两点，我们发现：\n如果存在间隔的几列（使符号相同，能合并处理），满足他们有的数字为一样的（比如都只有$1,2,3$，只是出现次数不同）。\n 如求$f(33)$中\n 例一：\n第$9$列为$0,0,\\cdots,0;-1,-1,\\cdots,-1;-2,-2,\\cdots,-2;-3,-3,-3,-3,-3,-3,-3$（$9$个$0$，$9$个$-1$，$9$个$-2$，$7$个$-3$）\n第$11$列为$0,0,\\cdots,0;-1,-1,\\cdots,-1;-2,-2,\\cdots,-2;-3$（$11$个$0$，$11$个$-1$，$11$个$-2$，$1$个$-3$）\n为下图中蓝色两列。\n  例二： 第$12$列为$0,0,\\cdots,0;1,1,\\cdots,1;2,2,\\cdots,2$（$12$个$0$，$12$个$1$，$10$个$2$）\n第$14$列为$0,0,\\cdots,0;1,1,\\cdots,1;2,2,2,2,2,2$（$14$个$0$，$14$个$1$，$6$个$2$）\n第$16$列为$0,0,\\cdots,0;1,1,\\cdots,1;2,2$（$16$个$0$，$16$个$1$，$2$个$2$）\n为下图中橙色三列。\n 举例求和表\n 那么这几列的等差数列，是可以合并为一个更大的等差数列一起求和的。\n 上例一中：\n第$9$列中的有$9$个$-1$、$9$个$-2$；\n第$11$列中的有$11$个$-1$、$11$个$-2$；\n于是这两列便可合并为$20$个$-1$，$20$个$-2$一起用高斯求和（等差数列求和）。\n 但对于最后的一项数（如上例一中的$-3$），因为出现次数不一致，不能很好的直接合并，需要单独处理计算，\n所以我们只能合并倒数第二项用高斯求和，然后对剩下的最后一项单独处理。\n这样就可以在计算的过程中合并几列同时计算，达到减少操作降低复杂度的效果。\n【不过至于是否为O($\\sqrt{n})$的复杂度我就没证了_(:з」∠)_……\n 那么重点就是：\n  怎么分奇偶，找到哪几列出现数字相同。\n 先算出这一列能出现的最大数，然后再用$n$除以这个数，得到只能出现到这个数的最大列。\n 比如求$f(33)$，处理第$9$列时，\n第$9$列能出现最大的数是$33/9$为$3$，但只能出现到$3$的最大列为$33/3$为第$11$列（可以配合上面给出的图来理解）。\n    怎么处理计算不能合并的最后一项。\n 首先最后一项这个数我们知道是好多（为$n/i$），所以关键是求他有多少个。\n由第一点发现可知，对于下一个间隔列，前面的项出现次数均多了$2$次，\n或者说最后一项出现次数依次减$2$。\n所以其实对于最后一项的出现次数，也是个等差数列。\n找到等差数列的几个参数求和，得到有多少个。\n 首项：对应最后一列$i$，总项数为$n+1$个，前面项每个数均出现了$i$次，一共有$N$个数（计算方法就是等差数列求项数）。 末项：对应第一列，计算方法同首项。 项数：就是合并了几项。   比如求$f(33)$，处理第$12$列时，最大列到$16$列\n 首项——第$16$列中：前面的项（$0$和$1$）均出现了$16$次，所以这一列最后一项（$2$）出现次数为$2$次。 末项——第$12$列中：前面的项均出现了$12$次，所以这一列最后一项出现次数为$10$次。 项数——合并了$12$、$14$、$16$列，项数为$3$. 则可求得最后一项$2$一共出现了$(2+10)*3/2=18$次。      怎么处理计算合并后的等差数列。\n 方法就同$O(n)$方法中求等差数列了，\n只是在最后一项（an）和乘的次数（由乘i变成了乘cnt）变了一点。\n对于合并后的出现次数，也是个高斯求和。\n 比如求$f(33)$，处理第$9$列时，最大列到$11$列\n第$9$列每一项出现次数为$9$次，\n第$11$列每一项出现次数为$11$次，\n所以一共出现$9+11 = 20$次，\n    个人代码 Pastebin链接\n\r //P4863 [JerryC Loves Driving](https://www.luogu.com.cn/problem/P4863) #include \u0026lt;bits/stdc++.h\u0026gt;#define ALL(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026lt;= TO; \\ NAME_i++ #define SGN (nega ? -1 : 1) typedef long long LL; using namespace std; LL solve(int n) { LL ans = 0; bool nega = 1; for (ALL(i, 1, n)) { LL a1 = 0, //首项  an = (n + 1) / i - 1, //末项  cntSeq = an + 1; //项数  ans += i * ((a1 + an) * cntSeq / 2) * SGN; //先求等差数列的和  ans += (n + 1 - (cntSeq * i)) * (an + 1) * SGN; //再计算剩下的部分  nega = !nega; //变符号  } return ans; } LL solve_Odev(const int \u0026amp;n, bool odd) { LL ans = 0; int maxColumn; bool nega = odd ? 1 : 0; for (int i = odd ? 1 : 2; i \u0026lt;= n; i = maxColumn + 2) //注意赋值语句为maxColumn + 2，也就是合并处理完几列后，直接跳到处理完的列后面。  { //1. 怎么分奇偶，找到哪几列出现数字相同。  LL maxNum = n / i; //当前列能出现的最大数（或最后一项）  maxColumn = n / maxNum; //只能出现到这个数的最大列  if (odd \u0026amp;\u0026amp; !(maxColumn \u0026amp; 1)) //本来处理奇数列，但算出来最大列为偶数情况  maxColumn--; if (!odd \u0026amp;\u0026amp; (maxColumn \u0026amp; 1)) //本来处理偶数列，但算出来最大列为奇数情况  maxColumn--; /* 对应于上图中，当n = 33, i = 12时： maxNum = 2 maxColumn = 16\t【对应为 合并12~16列。 */ //2. 怎么处理计算不能合并的最后一项。  int minCnt = (n + 1) - maxColumn * maxNum, //首项——这几列中，最后一项出现最少的次数（为最后一列，用maxColumn）  maxCnt = (n + 1) - i * maxNum, //末项——这几列中，最后一项出现最多的次数（最当前列，用i）  cntColumn = ((maxColumn - i) \u0026gt;\u0026gt; 1) + 1; //项数——合并了几列  /* 注意的点： 1. 总项数为n+1个，因为0也算！ 2. 不为maxNum - 1，因为0也算！【前面项的项数为((maxNum-1) - 0) / 1 + 1，即maxNum */ int cntNum = ((maxCnt + minCnt) * cntColumn) \u0026gt;\u0026gt; 1; //求得关键——最后一项有多少个（高斯求和）  ans += maxNum * cntNum * SGN; /* 对应于上图中，当n = 33, i = 12, maxColumn = 16时： minCnt = 2\t【对应为 最后一列有2项 maxCnt = 10\t【对应为 第一列有10项 cntColumn = 3\t【对应为 合并了3列 cntNum = 18\t【对应为 最后一项由18个 */ //3. 怎么处理计算合并后的等差数列。  LL a1 = 0, //首项  an = maxNum - 1, //末项  cntSeq = an + 1; //项数  /* 以上跟O(n)方法的几乎一样。 区别在于当这一列完全为等差数列时（不存在不为等差数列的部分）： O(n)方法计算等差数列和，会包括最后一项； O(sqrt(n))方法计算等差数列和，不会包括最后一项。 */ int cnt = ((i + maxColumn) * cntColumn) \u0026gt;\u0026gt; 1; //合并后出现次数（高斯求和）  ans += cnt * (((a1 + an) * cntSeq) \u0026gt;\u0026gt; 1) * SGN; //（高斯求和）  } return ans; } LL solve_block(const int \u0026amp;n) { LL ans = 0; ans += solve_Odev(n, 0) + solve_Odev(n, 1); return ans; } /* LL slove_original(int A, int B) //最原始的做法，但考虑的会更复杂所以未完成为错误的 //错误点为为考虑开始部分为非等差数列 { LL ans = 0; bool nega = 1; for (ALL(i, 1, B)) { int seqBgeinIndex = A + max(i - A, 0), cnt = (B - seqBgeinIndex + 1) / i, seqEndIndex = seqBgeinIndex + cnt * i - 1; LL a1 = max(A / i, 1), an = a1 + cnt - 1; ans += i * ((a1 + an) * cnt / 2) * SGN; ans += (B - seqEndIndex) * (an + 1) * SGN; nega = !nega; } return ans; } */ int main() { int A, B; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;A, \u0026amp;B); //printf(\u0026#34;%lld\\n\u0026#34;, solve(B) - solve(A - 1));  printf(\u0026#34;%lld\u0026#34;, solve_block(B) - solve_block(A - 1)); } ","date":"2021-01-25T00:00:00Z","image":"https://blog.supersassw.com/p/acm-prac-2021_01_25/Yande-199983_hu24344327ed1750f50cc0e0aab802591d_7554577_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-prac-2021_01_25/","title":"ACM练习——P4863 JerryC Loves Driving……"},{"content":"数组课后练习题 判断题 第一、二、十八题（重要） 第一题\r在对全部数组元素赋初值时，不可以不指定一维数组的长度。\n\r\r知识点：\n 一位数组赋初值 【书 P121】  \r\r个人做错了这道题！\n\r\r答案与分析\r错误\n\r\r也就是说可以不指定数组长度……\n分析 如果提供了全部初始值数组，也可以不指定长度，编译提供会自动帮你指定。\n如：\nint a[] = {3,1,2,5,6,-2}; //编译系统会帮你指定为a[6] \r\r第二题\r在对全部二维数组元素赋初值时，可以不指定二维数组的行数。\n\r\r知识点：\n 二位数组赋初值 【书 P125】  \r\r个人做错了这道题！\n\r\r答案与分析\r正确\n\r\r分析 同一维数组， 如果提供了全部初始值数组，也可以不指定第一维长度，编译提供会自动帮你计算出长度并指定。\n但注意！\n不能省略第二维的长度。\n\r\r正确例子：\nint a[][3] = {1,2,3, 4,5,6, 7}; //编译系统会帮你指定为a[3][3] \n\r\r错误例子：\nint a[3][] = {1,2,3, 4,5,6, 7}; //编译系统无法确定长度 \n\r\r\r\r\r练习——第十八题\r在给全部数组元素赋初值时，可以不指定二维数组中的常量表达式，例如int a[][] = {1,2,3,4,5,6}。\n\r\r作为之前二维数组的练习题。\n\r\r个人做错了这道题！\n\r\r答案\r错误\n\r\r\r\r\r 第十题 定义一个一维字符数组有$50$个元素，用该一维字符数组表示一个字符串数组最多允许有$50$个字符\n\r 知识点：\n 字符数组的容量 【书 P128】  \r 答案与分析\r错误\n\r\r分析 字符数组char []，容量比定义的长度要少一个。\n因为字符数组还要存一个末尾的/0，\n所以题上定义了$50$个元素（char a[50]），但实际上只能存$49$个字符。\n同理：如果一个字符串长度是$n$，\n则它占用的空间是$n+1$个。\n例子见考前总结中最后的第7点。\n\r\r\r  第十一、十三题 第十一题\rC++中各种数据类型的变量在定义后会被自动初始化为0。\n\r\r知识点：\n 一维数组的初始值 【书 P121】  \r\r答案与分析\r错误\n\r\r分析 一般方式定义的数据类型，如int a，double b[10]，都是不会被赋初值的。\n这也就是为什么我们不赋初值就使用它会报错的原因，因为里面有以前的脏数据\n\r\r但如果加上static这个修饰词，定义为静态变量，就会被赋初值为0了。\n如：\nstatic int a; //a = 0 static int b[5]; //b1~b5 = 0 \r\r第十三题\r静态（static）数组被定义时，数组的所有元素自动获取初始值0。\n\r\r知识点：\n 静态一维数组 【书 P121】  \r\r答案与分析\r正确\n\r\r分析 同十一题，静态数组，里面所有元素自动赋初值为0。\n\r\r\r 第十七题 在C++中数组是具有一定顺序关系的若干相同类型变量的集合体。\n\r 知识点：\n 数组的概念 【书 P120】  \r 答案与分析\r正确\n\r\r分析 纯概念题，记住！\n\r  第二十题（重要） 程序段：\nchar s1[10]; s1 = \u0026#34;program\u0026#34;; 是合法的使用。\n\r 个人做错了这道题！\n为一道很容易错的操作题。\n\r 知识点：\n 一维字符数组的定义 【书 P127】  \r 答案与分析\r错误\n\r\r分析 请仔细阅读书上P127中「1.一维字符数组的定义」！\n里面有很多没有讲到的点，但很容易错。\n\r 由第二十题衍生的练习题 作为第二十题相关的练习题。\n\r 这些都是根据书上P127中「1.一维字符数组的定义」里面的内容所出题。\n故没有写分析，请仔细阅读书上事例来自行分析。\n第二十一题\r程序段：\nchar s1[10] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;}; cout \u0026lt;\u0026lt; s1; 是合法的使用。\n\r\r个人做错了这道题！\n与二十二题很容易混淆！\n\r\r答案\r正确\n\r\r\r\r第二十二题\r程序段：\nchar sa[] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;}; cout \u0026lt;\u0026lt; sa; 是合法的使用。\n\r\r个人做错了这道题！\n与二十一题很容易混淆！\n\r\r答案\r错误\n\r\r仔细看看与二十一题的区别在什么地方，\n很小的区别就造成了答案的不一样。\n\r\r第五十四题\r有如下的字符串数组定义语句：\nchar str1[] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;}; char str2[] = {\u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;\\0\u0026#39;}; char str3[] = \u0026#34;program\u0026#34;; 下列说法正确的是（）。\n A、str1中的数据可以作为一个整体（字符串）参加运算。\nB、str2和str3中的数据只能作为一个整体（字符串）参加运算。\nC、str2和str3中的数据既可以以元素为单位参加运算，也可以作为一个整体（字符串）参加运算。\nD、str1、str2和str3中的数据既可以以元素为单位参加运算，也可以作为一个整体（字符串）参加运算。\n所谓作为一个整体，即是如以下操作：\nstr1 = \u0026#34;abcd\u0026#34;; cout \u0026lt;\u0026lt; str1; 而以元素参加运算，即是如以下操作：\nstr1[2] = \u0026#34;a\u0026#34;; cout \u0026lt;\u0026lt; str1[3]; 如果只能以元素操作，则不能cout \u0026lt;\u0026lt; str1这样作为整体操作。\n\r\r\r\r个人做错了这道题！\n\r\r知识点：\n 二维数组的使用方法 【书 P125】  \r\r答案\rC、str2和str3中的数据既可以以元素为单位参加运算，也可以作为一个整体（字符串）参加运算。\n\r\r\r\r\r选择题 第三十、三十一题 第三十题\r在下面的一维数组定义中，（）有语法错误。\n A. int a[] = {1,2,3};\nB. int a[];\nC. int a[] = {0};\nD. int a[5];\n\r\r知识点：\n 一维数组的初始化 【书 P121】  \r\r个人做错了这道题！\n为一道很容易错的操作题。\n\r\r答案与分析\rB. int a[];\n\r\r分析  A、对于确定初始值的数组，可以不指定长度，是正确的。（见上面第一题） B、这种定义方式是不存在的，要么赋初值，要么指定长度。 C、很容易错选的选项，这种方式其实就代表定义个长度为1的数组，然后a[0]=0。是正确的。 D、基本的定义方式，是正确的。  注意还有一种定义类型int a[...] = {0}，代表定义个...长度的数组，其中全部赋初值为0。\n\r\r第三十一题\r在下面的二维数组定义中，（）有语法错误。\n A. int x[10][10];\nB. int x[][10] = {{1,3} ,5 ,7};\nC. int x[][];\nD. int x[10][10] = {0};\n\r\r知识点：\n 二维数组的初始化 【书 P125】  \r\r答案与分析\rC. int x[][];\n\r\r分析   A、基本的二维数组定义方式，没赋初值，是正确的。\n  B、这里有赋初值，所以可以不用指定行数，是正确的。\n 最终数组状态为：\nx[0][0] = 1; x[0][1] = 3; x[1][0] = 5; x[2][0] = 7;    C、错因跟上一样。\n  D、这里就是第三十题说得，定义一个确定长度的二维数组，然后全部赋初值为0，是正确的。\n  \r\r\r第三十五题 定义一个一维数组，正确的语句是（）。\n A. int a(10);\nB. int n = 10; int a[n]\nC. int n; cin\u0026gt;\u0026gt;n; int a[n]\nD. const int n = 10; int a[n]\n\r 知识点：\n 一维数组的定义 【书 P120】  \r 答案与分析\rD. const int n = 10; int a[n]\n\r\r分析 首先A选项，不知道他在干嘛，直接排除。\n对于B、C、D选项，涉及到一维数组的定义这个知识点。\nB和C中的n均是变量，故错误。\nD中的n为常量（const），故正确。\n书上原话 在定义数组时，数组的大小必须是常量，而不能是变量或者变量表达式。\n\r\r\r  第三十六题 以下哪种说法错误？（）。\n A. 数组中的元素在某些方面彼此相关。\nB. 数组中的所有元素具有相同的下标。\nC. 数组中的所有元素具有相同的数据类型。\nD. 数组中的所有元素具有相同的名字。\n\r 答案与分析\rB. 数组中的所有元素具有相同的下标。\n\r\r分析 纯概念题，记住！\nB是错的很容易看出来，\n主要是A、C、D是对的要记住。\n\r  第五十二题 若有定义语句int a[3][6]，\n按在内存中的存放顺序，a数组的第$10$个元素是（）。\n 我出成了填空题！……\n请想出正确答案！……\n\r 知识点：\n 二维数组的使用方法 【书 P125】  \r 答案与分析\ra[1][3]\n\r\r分析 二维数组的存放方式，也是按着顺序存放的。\n并且先是按行顺序存放，一行存完了再换下一列。\n也就是按照a[0][0],a[0][1],a[0][2]\u0026hellip;a[0][5],a[1][0],a[1][1],\u0026hellip;,a[2][5]的顺序存放，\n所以第$10$个，就是$10 = 2 * 3 + 4$，也就是第$2$行第$4$列，为a[1][3]。\n\r  第五十九题 以下关于二维数组的说法中，错误的是（）。\n A. 若在定义二维数组的同时给其赋初值，则二维数组的列数可以省略。\nB. 二维数组的每一行相当于一个一维数组，因此二维数组可以看成是由一维数组构成的数组。\nC. 给二位数组赋值时，可以将所有元素写在一个{}内。\nD. 引用二维数组时，必须包含数组名、行下标和列下标。\n\r 知识点：\n 二维数组的各种概念 【书 P125】  \r 答案与分析\rA. 若在定义二维数组的同时给其赋初值，则二维数组的列数可以省略。\n\r\r分析 纯概念题，记住！\n\r 未写入的题  第十二题——数组[]里能放的东西，只有常量和常量表达式 第十四题——数组不是C++基本数据类型 第十六题——数组再内存中是连续存在的（包括二维数组） 第十九题 （个人做错） ——字符串处理函数（strcpy、strcmp等）的头文件（\u0026lt;string.h或cstring或\u0026lt;iostream\u0026gt;），是不含string类的（头文件为\u0026lt;string\u0026gt;）。 第三十四题：  字符数组（char []）只能用字符串函数来处理（strcpy、strcmp）\n字符串（string）只能用运算符号（+、==）来处理。\n两者有各自对应的运算方式。\n   ","date":"2021-01-09T00:00:00Z","image":"https://blog.supersassw.com/p/univ-cpp-prac-array/Yande-314214_hua49f15ef087bdbbd47ec4ec6c539acdb_2635208_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/univ-cpp-prac-array/","title":"程序设计——数组习题……"},{"content":"以下为个人对教材中每章课后练习所出现的名字解释题进行的总结。\n教材为：心理学导论（第三版）——人民教育出版社 （黄希庭 郑涌 著）\n由于老师跳过了第二章，并且教学进度被缩短的原因，对第二章以及第五章后部分名字解释未整理。\n\r 带“心理学大辞典”的定义表示该定义是从「心理学大辞典」中查阅得来。\n\r 斜体表示该名词未在课后练习中出现，但个人总结出来了，仅供参考。\n\r 第一章 绪论 第一节 心理学的性质  心理学：心理学是一门研究心理现象的事实、机制、规律、和本性的实证科学。  一、个体心理现象概览 从个体心理的动态—稳态维度区分：\n 心理倾向：心理活动在特定时间里的指向状态。 心理过程：心理活动在一定时间内发生、发展的过程。  认知过程：个体获取知识和运用知识的心智活动。（人以感知、记忆、思维等形式反映客观事物的性质和联系的过程——心理学大辞典） 情绪过程：产生心理现象的历程。（人对客观事物的某种态度的体验——心理学大辞典） 意志过程：力图达到有目的、有计划地改造世界的心理过程。（人有意识地克服各种困难以达到一定目的的过程——心理学大辞典）   心理特征：一个人心里活动中经常表现出来的稳定特点。  三、心理学的科学性  可复制性：一项科学研究的结果是能够按照原创者所提供的研究方法精确加以重复验证的。 可证伪性：在表述一个科学理论时，必须遵循从该理论所推导出各种预测有可能被证伪。 系统性：心理学的科学知识是通过系统的实证研究而获得的。  第二节 心理学的方法 一、心理学研究的基本原则  可公开检验原则：科学发展是可以由任何人重验、批评、否定或继续发展的。 主客观资料科学整合原则：对人的心理研究中必须考虑把所有收集到的客观资料与主观资料科学地整合起来。 人文关怀原则：心理学研究者在科学研究中应遵守心理学家的职业道德。 操作性定义：以可观察、可测量的操作给一个概念下定义。  二、心理学研究的基本变量  刺激变量（S）：能够引起机体反应的刺激特征。 机体变量（O）：个体自身特征。 反应变量（R）：刺激引起在行为上发生变化的反应种类和特征。  三、心理学研究的基本方法  实验法：在控制的条件下系统地操纵某种变量的变化，来研究该变量的变化对其他变量产生的影响。（心理学大辞典 P1131）  自变量：研究者选定并在试验中操纵、掌握，以影响被试行为的因素。 因变量：被试的反应，即研究者想要预测的行为。 控制变量：除了自变量会对因变量影响之外，所有其他因素都应保持恒定或加以控制。 无关变量：与实验目的无关的变量。 实验组：专门接受实验处理的一组被试。（心理学大辞典 P1135） 控制组\u0026lt;对照组\u0026gt;：不受实验处理的被试组。（心理学大辞典 P700）   准实验法：在实验研究的设计上或情景控制上不具备实验法的一个或两个基本条件的研究方法。 问卷法：用问卷提问题的方式，要求被调查者就某个或某些问题问答自己的想法。  相关系数：用来度量两个或几个变量之间相互联系的性质和程度的指标。   演绎法：从理论或假设出发得出结论来验证其对心理现象或行为变化的预测和解释力的论证方法。 质性研究法：对特定的心理现象、行为、团体互动进行深入系统的观察、资料收集、分析理解，从而对所研究的心理现象或行为特征及其发展脉络提供具体、系统的描述。  归纳法：由繁到简、由特殊情形推论出普遍规则的过程。    第三节 心理学的历史  构造主义 机能主义 行为主义 格式塔心理学 精神分析 人本主义心理学  第四节 当代心理学的特点  生物学取向：着重从生物、生理、遗传基因的角度研究心理与行为。 行为取向：着重研究个体的行为是怎样受到环境和经验影响的。 认知取向：主张用信息加工观点来研究人类心理过程和结构。 社会文化取向：着重研究社会文化怎样影响个体的心理与行为。 心理动力学取向：着重研究个体心理与行为的动力因素。   第三章 心里的生物基础 第一节 神经系统与神经元  神经系统：由巨量神经细胞形成的神经组织与结构的总称。  一、中枢神经系统的结构和机能  中枢神经系统：是人体神经系统的主要部分，包括脑和脊髓\n功能：传递、储存和加工信息，产生各种心理活动，支配与控制人的全部行为。  二、周围神经系统的结构和机能  周围神经系统：从中枢神经系统发出，导向人体各部分，可分为躯体神经系统和自主神经系统\n功能：与身体各部分的联络工作，起传入和传出信息的作用。  三、神经元的结构和机能  神经元：是神经系统结构和功能的基本单位。 全或无定律：当刺激强度未达到某一阈值限时，神经冲动不会发生；而当刺激强度达到该值时，神经冲动发生并能瞬时达到最大强度，此后刺激强度即使再继续加强或减弱，已诱发的冲动强度也不再发生变化。 突触：相邻神经元其间的空隙。（神经元之间或神经元与效应器细胞之间传递信息的结构——心理学大辞典 P1264）  第三节 脑机制的研究方法 三、脑电图及事件相关电位  脑电图：在头皮表面记录到的自发节律性电活动。 事件相关电位：通过平均叠加技术从头颅表面记录大脑诱发电位，来反映大脑高级心理活动过程中大脑的神经电生理改变。  五、脑成像技术  功能性磁共振成像：功能更强的磁共振成像（磁共振成像：运用磁场原理来产生体内活动的图像），甚至可以使大脑的活动可视化。  专栏3-2\n 裂脑：切断大脑两半球之间的连结以研究人与动物的一种技术。（心理学大辞典 P758）  第四节 内分泌系统  内分泌系统：机体内对行为起重要调节作用的一个系统，由全身不同部位的多种内分泌腺体和组织细胞组成。 激素：内分泌腺所分泌的物质。  第五节 遗传对行为的影响  遗传：亲子之间以及子代个体之间性状存在的相似性，表明性状可以从亲代传递给子代。 基因型：个体的整个遗传禀赋。 表现型：在特定的环境中具有一定基因型的个体遗传得以实现的程度。 选择性繁殖：对动物特性遗传的一种研究方法。 双生子研究：一种研究方法，用于探讨遗传和环境因素对个体心理和行为发展的影响或作用。（心理学大辞典 P1175）   第四章 心理的环境基础 第一节 环境的内容 一、什么是环境  环境：与有机体发生联系的外部世界。 自然环境：环绕人们周围的各种自然因素的总和。 社会环境：人类生存及活动范围内的社会物质、精神条件的总和。 物理环境：除包括自然环境诸因素外，还包括人为的物理环境因素。 心理环境：人与人，人与物相互作用时所形成的环境。 情景：指一定场合下能被个体感知到的那一部分环境。  三、心理学家关于环境的理论  地理环境：显示的环境。 行为环境：个人意想中的环境。 生态系统理论：心理学发展环境理论，认为环境是由微系统、中系统、外系统、大系统四个由近及远的子系统组成的一个有层次序列的系统。（心理学大辞典 P1112）  第二节 自然环境 一、空气质量  空气污染综合征：受到长期的空气污染导致的症状，出现头疼、疲劳、失眠、消沉等症状。  二、噪声  噪声：一种非周期性的、无组织的、不定型的听觉刺激。  三、社会密度与拥挤  社会密度：一个给定的空间里所拥有的人数。 拥挤：一种感到空间不够大的主观感受。  第三节 社会环境 一、文化传统  文化：有广义、狭义之分。  狭义的文化：观念形态的文化，仅限于意识形态。 广义的文化：人类社会的全部遗产，囊括社会生活的全部领域。   亚文化：在社会的某一群体中形成一种既包括民族的一些主文化特征，也包括某些独特的文化特征的生活方式的这种群体文化。  第四节 社会影响  社会影响：运用个人或团体的社会力量在特定的方向上改变他人的观念和行为的过程。  一、从众与服从  从众：个人的观念和行为由于群体直接或隐含的引导或压力而与多数人保持一致的倾向。 服从：个体在他人的直接命令下而做出某种行为的倾向。  专栏4-3\n 角色\u0026lt;社会角色\u0026gt;：期望与个人的、训练个人的并鼓励他在一定社会情况中去完成某种权利、义务和责任的任何行为模式。   第五章 毕生心理发展  毕生发展：人类个体从受精卵开始，逐渐发育、成熟直至死亡，整个生命全程的与年龄有关的那些变化过程。  第一节 心理发展的基本观点 一、遗传与环境的交互作用  反应的交互作用：面对环境刺激，不同遗传基因的个体会以不同的方式来对其做出反应。 唤起的交互作用：个体的行为特征会招致人们对其的不同反应。 超前的交互作用：个体主动选择和创造他们所喜欢的环境，这些环境反过来又进一步作用于个体。  二、发展的连续性与变化性  发展的连续性：个体特征不因年龄增长而发生改变。 转折点：个体在发展过程中在几种途径中做出选择，从而导致个体生活环境的根本性变化。  三、发展中的个别差异  年龄特征：人类生理心理发展在各年龄阶段中大多数个体所表现出来的共同特征。 个别差异：受遗传基因与环境的不同影响，不同个体之间在身心特征上各不相同的现象。  四、心理发展的研究设计  横断研究：在同一时间内或较短时间内对某一个年龄或某几个年龄层次的个体或个体群组的发展水平进行观测与研究，并加以比较的一种研究设计。 纵向研究：对某一特定个体或某一组特定的个体随着其年龄的增长在其发展的不同阶段系统地进行反复观测，从而取得连续性的发展资料。  第二节 孕期与婴儿期 二、婴儿期的发展  依恋：婴儿依附于养育者的一种社会情绪性联系。  第三节 幼儿期与儿童期 一、认知发展  图式：个体灌注经验的心理模具。 同化：个体用现有的图式去理解事物。 顺应：使图式适应新经历的特殊性。 感觉运动阶段：0~2岁，指婴儿只能通过“这里”与“现在”来理解这个世界，只有那些能感觉和接触到的东西才是真实的。 前运算阶段：2~7岁，这一阶段儿童依靠的更多是感觉而不是逻辑。同时还表现为，总是从自己的观点看世界，不能从别人的观点直觉事务，称为自我中心主义。 具体运算阶段：7~11岁，儿童能依据具体事例进行推理思考，不会只依据表面现象，而是更有逻辑地进行思考，有了守恒的观念。 形式运算阶段：11岁以上，儿童能运用抽象的、符合形式逻辑的推理方式去思考问题。  ","date":"2021-01-08T00:00:00Z","image":"https://blog.supersassw.com/p/univ-intro_psychol-ne/67450790_p0_hu64a059195139e470f4d36bc000798f35_624654_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/univ-intro_psychol-ne/","title":"心理学导论——名词解释……"},{"content":"指针课后习题 判断题 第一题 从内存单元中存取数据的方法有直接访问方式和间接访问方式。\n\r 知识点：\n 内存单元的数据存取方式 【书 P186】  \r 答案与分析\r正确\n\r\r分析  直接访问方式：通过变量名存取变量内容。  如a = 2、cout \u0026lt;\u0026lt; a。\n  间接访问方式：通过 地址（即指针） 操作。  如*a = 5、cout \u0026lt;\u0026lt; *a。\n   \r  第二题 能够直接赋值给指针变量的整数是$0$和$1$。\n\r 知识点：\n 指针赋值 【书 P187】  \r 答案与分析\r错误\n\r\r分析 整数中，只有$0$才可以赋值指针，代表空地址（NULL）。\n书上原话 “地址”，可以是变量的地址、数组名、函数名等，也可以是数值$0$（或NULL）。\n没有任何对象会被分配到地址0（或NULL），因此数值$0$（或NULL）是可以直接赋给指针变量的唯一整数。\n\r\r\r  第四题 “变量的指针”含义是指该变量的地址。\n\r 个人做错了这道题！\n为一道很新颖的概念题。\n\r 答案与分析\r正确\n\r\r分析 纯概念题，记住！\n\r  第九题 在操作一个一维数组时，可能会用到两个指针变量指向该数组，\n这两个指针变量之间可以进行关系运算，其关系运算的结果表明了这两个指针变量所指向的数组元素的先后关系。\n\r 个人做错了这道题！\n为一道很新颖的概念题。\n【个人甚至都不知道这种方法……\n\r 知识点：\n 指向一维数组的指针的关系运算 【书 P190】  \r 答案与分析\r正确\n\r\r分析 当有两个指针指向同一个数组时，\n可以对这两个指针进行比较（\u0026lt;、\u0026gt;），以反应这两个指针的位置关系。\n例子\r假设：\n存在数组int a[10]，\n存在两个指针int *p1,*p2。\n这两个指针均指向数组a中某个位置（如p1=\u0026amp;a[4]，p2=\u0026amp;a[8]）\n 若p1 \u0026lt; p2，则代表p1所指向的数组元素，在p2所指向的数组元素前面。 若p1 = p2，则代表p1、p2指向数组中同一个元素。 若p1 \u0026gt; p2，则代表p1所指向的数组元素，在p2所指向的数组元素后面。  具体可以看书上，有图示来解释。\n\r\r\r  第十题 对于已经定义好的相同类型的两个指针变量，可以进行加法运算、减法运算和赋值运算。\n\r 个人做错了这道题！\n为一道很新颖的概念题。\n【个人甚至都不知道这种方法……\n\r 知识点：\n 指针间的运算 【书上没找到对应知识点】  \r 答案与分析\r错误\n\r\r分析 指针间存在三种运算。\n 假设两指针int *a,*b。\n 赋值运算（a = b）\n代表最基本的赋值。 关系运算（a \u0026lt; b）\n代表a和b位置关系。【一般用于数组中，代表谁指向前面谁指向后面】 减法运算（a - b） 代表a到b之间的距离。【一般用于数组中，如a = \u0026amp;arr[5]，b =\u0026amp; arr[7]，则a-b为$2$】   上述题错在：没有加法运算。\n\r  第十九题 使用动态储存分配时，用运算符new获取的内存空间，不必须用delete进行释放。\n\r 个人做错了这道题！\n为一道很新颖的概念题。\n\r 知识点：\n 动态存储分配 【书 P201】  \r 答案与分析\r错误\n\r\r分析 纯概念题，记住！\n书上原话 用new获取的内存空间，必须用delete运算进行释放，并且对同一个内存空间只能执行一次delete。\n\r\r【虽然个人感觉确实不用的，因为程序结束会自动帮你释放xd……\n注意只能delete一次\n\r\r\r  第二十二题 设int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}, (*p)[5];，\n则使用p = a语句是不合法的。\n\r 个人做错了这道题！\n\r 知识点：\n 数组指针变量 【书 P196】  \r 答案与分析\r错误\n\r\r分析 个人暂时也不知道原因，正在询问老师【……\n\r\r感觉是题目错了……\n\r  选择题 第三十三、三十四、三十七、三十八题 因为这几道题考点相同，故放在一起形成对照。【区别仅在++的位置】\n第三十三题\r设有如下程序段，输出的值为（）\nint x = 8, *p = \u0026amp;x; cout \u0026lt;\u0026lt; *p++ \u0026lt;\u0026lt; endl;  A. $8$\nB. $9$\nC. $8$的地址\nD. $9$的地址\n\r\r答案与分析\rA. 8\n\r\r分析 这里面先是运算*p，得到值$8$，\n然后就变成了cout \u0026lt;\u0026lt; 8++ \u0026lt;\u0026lt; endl;，这个时候就是先返回结果再运算。\n也就是先输出$8$，然后再*p = *p + 1变成$9$。\n\r\r第三十四题\r设有如下程序段，输出的值为（）\nint x = 8, *p = \u0026amp;x; cout \u0026lt;\u0026lt; ++*p \u0026lt;\u0026lt; endl;  A. $8$\nB. $9$\nC. $8$的地址\nD. $9$的地址\n\r\r答案与分析\rB. 9\n\r\r分析 注意这里面还是先运算*p，得到值$8$，\n然后就变成了cout \u0026lt;\u0026lt; ++8 \u0026lt;\u0026lt; endl;，这个时候就变成了先运算再返回结果。\n也就是先*p = *p + 1变成$9$，然后再输出$9$。\n总之前两道题，都是先运算*p。\n\r\r第三十七题\r设有定义语句：\nint a[10]={0,1,2,3,4,5,6,7,8,9},*p = a; 则数值不为$3$的表达式为（）。\n A. a[3]\nB. p[3]\nC. p += 2, *(p++)\nD. p += 2, *(++p)\n\r\r个人做错了这道题！\n为一道很容易错的操作题。\n\r\r答案与分析\rD. p += 2, *(++p)\n\r\r分析 首先A、B选项，直接能看出a[3]和p[3]均为数组第四个元素，即为$3$。\n所以讨论C、D选项。\n注意这里的指针，变成了指向数组的指针。\n所以是可以进行加法操作的，代表指向位置的移动。\n刚开始均有一个p += 2，也就是指向了第三项a[2]为$2$。\n然后这里打了括号，所以肯定先是运算括号里的东西。\n那么p++和++p的区别，也就在于是先返回值还是先加一。\n 对于++p，先运算，也就指向了a[3]，再返回值。那么还是$3$。 对于p++，先返回值，也就是a[2]，那么a[2]的值就为$2$了。  故选择C。\n\r\r练习——第三十八题\r设int x[] = {1,2,3,4,5,6}, *p = x;\n则数值为$3$的表达式是（）。\n A. p += 2, *++p\nB. p += 2, *p++\nC. p += 3, *p\nD. p += 2, ++*p\n\r\r作为之前三道题的汇总练习题。\n\r\r答案与分析\rB. p += 2, *p++\n\r\r分析 没打括号的时候，*p最先运算。\nA中，*与p被++隔开了，所以只能先运算++p。\n如果换成p += 2, *(p++)，也是正确答案。\n不过其运算过程与B完全不一样，运算后的结果更不一样！\n\r\r\r\r\r 第三十九、四十、四十九、五十题 因为这几道题考点相同，故放在一起形成对照。\n第三十九题\r设有定义语句：int a[5], *p = a;，\n则下列描述错误的是（）。\n A. 表达式p = p + 1是合法的\nB. 表达式a = a + 1是合法的\nC. 表达式p - a是合法的\nD. 表达式a + 1是合法的\n\r\r答案与分析\rB. 表达式a = a + 1是合法的\n\r\r分析 需要注意到：数组名其实也是一个指针，代表这个数组的起始位置，相当于\u0026amp;a[0]。\n但其是常量指针，故不可以执行赋值语句。\n也就是a + 1是对的，代表\u0026amp;a[0] + 1，\na = a + 1是错的，没法把\u0026amp;a[0] + 1赋值给\u0026amp;a[0]。\n\r\r第四十题\r有下面语句int a[10] = {10,9,8,7,6,5,4,3,2,1}, *p = a，\n则数值为$2$的表达式是（）。\n A. a[9]\nB. *p[8]\nC. *(a+8)\nD. p+8\n\r\r个人做错了这道题！\n【虽然是我没认真看题错的_(:з」∠)_……\n\r\r答案与分析\rC. *(a+8)\n\r\r分析  A、a[9]，代表的是数组第十个元素，也就是$1$。 B、p[8]的时候，已经代表的是第九个元素的值了，所以不能再加*。\n也就是说如果选项是p[8]就是对的，*p[8]存在语法错误。 C、*(a+8)，也就相当于a[8]，故为$2$，正确。 D、p+8，代表的是第九个元素的地址，不是里面的值。\n也就是说如果选项是*(p+8)就是对的。  \r\r第四十九题\r若有定义int a[10], *p = a;，\n对数组元素错误的使用的语句是（）。\n A. *(a+1)\nB. *(p++)\nC. p[1]\nD. *(a++)\n\r\r答案与分析\rD. *(a++)\n\r\r分析 跟前两道题一样，关键是多了++这个自增运算符。\n对于B，p是个指针变量，是可以执行自增（或说赋值）的语句的。 而对于D，p是个指针常量，是不能执行自增（或说赋值）的语句的。\n\r\r练习——第五十题\r若有定义int a[] = {0,1,2,3,4,5,6,7,8,9}, *p = a, i;，\n对数组元素正确的使用的语句是（）。\n A. a[p]\nB. p[a]\nC. p+12\nD. a[p-a]\n\r\r作为之前三道题的汇总练习题。\n\r\r答案与分析\rD. a[p-a]\n\r\r分析 注意[]里面，只能为具体的数值\n也就是说A、a[p]和B、p[a]均错误，\n因为[]里是地址，而不是数值。\n A改为a[*p]，则正确，代表a[0]，\nB改为p[*a]，则正确，代表p[0]（即a[0]）。\n 但如果数组元素换位int a[]={-1,0,1,2,3,4,5,6,7,8}，\n那么即便改为a[*p]也不正确，因为其代表a[-1]，对数组元素使用错误。\n\r\rC是很明显的数组越界。\nD中，前面的题（第十题）介绍过，指针间存在减法运算。\n那么这道题中p-a的运算结果为$0$（因为指向同一位置a[0]，之间不存在距离），\n然后a[0]是正确使用。\n\r\r\r 第四十三题 设char str[] = \u0026quot;hello\u0026quot;, *p = str;，\n则*(p+5)的值是（）。\n A. 随机值\nB. 字母o\nC. 字符串结束标志\\0\nD. 字母o内存的地址\n\r 答案与分析\rC. 字符串结束标志\\0\n\r\r分析 *(p+5)，也就是从字符串开头往后数$5$位。\n会发现，最后只能往后数$4$位到o，\n别忘了在字符数组char []中，最末尾还会有一个看不见的\\0这个东西，\n所以存在*(p+5)，代表的就是\\0。\n\r  第四十六题 设有定义语句int *p[4];，\n则标识符p是（）。\n A. 一个指向整型变量的指针变量\nB. 一个指向整型的指针数组名\nC. 一个指针，它指向一个含有四个整型元素的一维数组\nD. 一个非法的定义语句\n\r 个人做错了这道题！\n【虽然是我没认真看题错的_(:з」∠)_……\n\r 答案与分析\rB. 一个指向整型的指针数组名\n\r\r分析 就注意一下这种定义方式，\n其类型就是一个指向整型的指针数组名。\n\r  第五十一题 若有定义：int a[] = {1,2,3,4,5,6,7,8,9,10}, *p = a;，\n则数值为$7$的表达式为（）。\n A. *(p+7)\nB. p[*(a+6)]\nC. p+6\nD. a[*(p+5)]\n\r 个人做错了这道题！\n\r 答案与分析\rD. a[*(p+5)]\n\r\r分析 首先很容易判断出A，其数值为$8$，\nC，其没有加*，故代表的是a[6]的地址。只有加了*，即*(p+6)才数值为$7$。\n而B、D，关键要先把[]内部的给运算出来，\nD中，*(p+5)的值为$6$,而a[6]的值为$7$，\n所以D的最终值为$7$，符合题意。\n\r  第五十四题 若有定义：int a[3][4]，\n能正确表示数组a中元素地址的是（）。\n A. *(a[1]+4)\nB. *(*(a+3)+1)\nC. *(a[1]+2)*\nD. *(*(a+1)+1)\n\r 个人做错了这道题！\n为一道很混淆的操作题。\n\r 答案与分析\rD. *(*(a+1)+1)\n\r\r分析 个人暂时也不知道原因，正在询问老师【……\n\r\r觉得C好像也是对的……\n\r  没写入的题 以下题均为比较新的概念题，但个人没有写入，还是推荐去看一下记一下。\n\r  第六题——常量是否能赋给指针 第七题——数组名代表数组首地址 第四十五题——int *point = new int(4)，这段代码的执行顺序  ","date":"2021-01-08T00:00:00Z","image":"https://blog.supersassw.com/p/univ-cpp-prac-point/Yande-308381_hubfc4b78b5f13c939fbd8620a241a68e1_9631758_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/univ-cpp-prac-point/","title":"程序设计——指针习题……"},{"content":"文章目录 发现锚点在个人简介(About)页面不生效，待修正……\n\r 在左侧侧边栏增加了显示文章目录（Table Of Content）的功能……\n测试 这是h3…… 这是另一个h3…… h4以下默认是不会显示的qwqqq…… 很短的内容……\n没了！……\n另外的h3【1】…… 另外的h3【2】…… 另外的h3【3】…… 另外的h3【4】…… 另外的h3【5】…… 这里分隔一下……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n很多换行……\n另外的h3【6】…… 另外的h3【7】…… 另外的h3【8】…… 另外的很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长h3【⑨】…… 长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级超级长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n长内容！……\n测试h2……  参考文章或主题  hugo主题——Eureka  js借鉴于这个主题，然后个人加以修改实现的……\n  js实现滚动条自动滚动（scrollTop）  主要是依此了解了scrollTop的用法……\n  如何用js自己实现Animate运动函数  有关滚动动画的实现js来源处（极其感谢wuwuwu……\n   ","date":"2021-01-07T00:00:00Z","image":"https://blog.supersassw.com/p/test-toc/66488487_p0_hu927bcdeee8a2673c7ad35386c9152871_481055_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/test-toc/","title":"Table Of Content测试……"},{"content":"扩展Shortcode 以下Shortcode均来自Hugo的Hugo Book主题……\n\r 一、columns 分栏显示内容……\n使用方法 {{\u0026lt; columns \u0026gt;}} Content_1 (With Markdown) \u0026lt;---\u0026gt; Content_2 {{\u0026lt; /columns \u0026gt;}} 使用例 左侧栏 OI的发生，到底需要如何做到，不OI的发生，又会如何产生。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 塞涅卡在不经意间这样说过，真正的人生，只有在经过艰难卓绝的斗争之后才能实现。这启发了我， OI因何而发生?我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 既然如此， 了解清楚OI到底是一种怎么样的存在，是解决一切问题的关键。 既然如何， 现在，解决OI的问题，是非常非常重要的。 所以， 问题的关键究竟为何? 经过上述讨论就我个人来说，OI对我的意义，不能不说非常重大。 所谓OI，关键是OI需要如何写。 一般来讲，我们都必须务必慎重的考虑考虑。 OI的发生，到底需要如何做到，不OI的发生，又会如何产生。 既然如何， 那么， 既然如何， 我们不得不面对一个非常尴尬的事实，那就是， 歌德曾经说过，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。我希望诸位也能好好地体会这句话。中间栏 俾斯麦曾经说过，对于不屈不挠的人来说，没有失败这回事。带着这句话，我们还要更加慎重的审视这个问题： 要想清楚，OI，到底是一种怎么样的存在。 每个人都不得不面对这些问题。 在面对这种问题时， 培根曾经说过，要知道对好事的称颂过于夸大，也会招来人们的反感轻蔑和嫉妒。我希望诸位也能好好地体会这句话。 生活中，若OI出现了，我们就不得不考虑它出现了的事实。 就我个人来说，OI对我的意义，不能不说非常重大。 既然如何， 塞涅卡在不经意间这样说过，生命如同寓言，其价值不在与长短，而在与内容。我希望诸位也能好好地体会这句话。右侧栏 所谓OI，关键是OI需要如何写。 所谓OI，关键是OI需要如何写。 那么， 既然如何， OI，到底应该如何实现。 带着这些问题，我们来审视一下OI。 我们不得不面对一个非常尴尬的事实，那就是， 所谓OI，关键是OI需要如何写。\n图片测试\n偷偷摸摸栏？…… 测试……\n图片测试\n 中间的文本尽量不要太长，不然会占用很大竖直空间……\n\r 二、details 内容折叠栏……\n使用的为HTML的details标签……\n使用方法 {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} content {{\u0026lt; /details \u0026gt;}}  open为可选项，加入open代表默认打开……  另一种方法：\n{{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} content {{\u0026lt; /details \u0026gt;}} \n\r 使用例 源码 {{\u0026lt; details \u0026#34;折叠内容……\u0026#34; \u0026gt;}} 这里面是折叠内容…… {{\u0026lt; /details \u0026gt;}} 效果 折叠内容……\r这里面是折叠内容……\r\r 嵌套测试 不要点开看！……\r不要看！…… 都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n都说了不要点开啦qwqqq快关上！！……\n真的不要看啦【【…… 再这么看人家超害羞的(*/ω＼*)……\n 诶诶还不关上嘛！……\n真拿你没办法，那就给你看看我多年的代码实力吧！【x……\n#inculde(iosteam) using namespace qwq; int mian() { int a,b; cin\u0026lt;\u0026lt;a+b; cout\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; }  诶诶不喜欢嘛？……\n那那来看看世界第一可爱的童田明治吧！……\n\r\r\rがぶがぶ……\r11歳の、5歳です！……\r\r内嵌columns 图片测试 1 图片测试内嵌columns 图片测试 2 图片测试\r\r\r\r 已完成对之前问题的修复：\n内嵌的时候请不要使用\u0026gt; {{\u0026lt; details \u0026gt;}}（引用加上details），否则会造成错误与样式混乱\n\r\r解决方法：shortcodes的渲染要用.RenderString\n\r 已修复：details内嵌columns时，若columns有图片，会造成的格式错误（原因：markdown会把4个空格当为代码块处理，故shortcodes的{}中要加上'-\u0026lsquo;符号来删除多余空格）\n\r 样式更改参考自借助HTML5 details,summary无JS实现各种交互效果……\n\r 三、tabs 分标签显示……\n使用方法 {{\u0026lt; tabs \u0026#34;uniqueID\u0026#34; \u0026gt;}} {{\u0026lt; tabs/tab \u0026#34;1\u0026#34; \u0026gt;}} Content_1 {{\u0026lt; /tabs/tab \u0026gt;}} {{\u0026lt; tabs/tab \u0026#34;2\u0026#34; \u0026gt;}} Content_2 {{\u0026lt; /tabs/tab \u0026gt;}} {{\u0026lt; tabs/tab \u0026#34;3\u0026#34; \u0026gt;}} Content_3 {{\u0026lt; /tabs/tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} uniqueID为一个独一无二的ID……\n使用例 源码 {{\u0026lt; tabs \u0026#34;1\u0026#34; \u0026gt;}}{{\u0026lt; tabs/tab \u0026#34;第一标签页\u0026#34; \u0026gt;}}## 天才麻将少女 打麻将真开心啊…… {{\u0026lt; /tabs/tab \u0026gt;}}{{\u0026lt; tabs/tab \u0026#34;第二标签页\u0026#34; \u0026gt;}}## 兽娘动物园 是会每天没事干不务正业的Friends呢【指自己…… {{\u0026lt; /tabs/tab \u0026gt;}}{{\u0026lt; tabs/tab \u0026#34;第三标签页\u0026#34; \u0026gt;}}## 魔法少女小圆 身体好轻，怀着这么幸福的感觉战斗还是第一次，已经没什么好怕的了，因为我不再是孤单一人了！…… {{\u0026lt; /tabs/tab \u0026gt;}}{{\u0026lt; /tabs \u0026gt;}}效果 第一标签页\r天才麻将少女 打麻将真开心啊……第二标签页\r兽娘动物园 是会每天没事干不务正业的Friends呢【指自己……第三标签页\r魔法少女小圆 身体好轻，怀着这么幸福的感觉战斗还是第一次，已经没什么好怕的了，因为我不再是孤单一人了！……\r ","date":"2021-01-07T00:00:00Z","image":"https://blog.supersassw.com/p/test-shortcode-extend/Yande-312231_hub297abc0e6f09948596897695fbb9840_1998731_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/test-shortcode-extend/","title":"移植Shortcode测试……"},{"content":"LaTex显示好像有误，待修复\n\r 定积分  $\\int_0^{\\frac{\\pi}{2}} f(\\sin x)\\mathrm{d}x = \\int_0^{\\frac{\\pi}{2}} f(\\cos x) \\mathrm{d}x$ $\\int_0^\\pi xf(\\sin x)\\mathrm{d}x = \\frac{\\pi}{2}\\int_0^\\pi f(\\sin x) \\mathrm{d}x$  e.g.\n$\\int_0^\\pi \\frac{x\\sin x}{1+cos^2x} \\mathrm{d}x = \\frac{\\pi}{2}\\int_0^\\pi \\frac{\\sin x}{2-sin^2x} \\mathrm{d}x$\n  Walls公式：\n$I_n=\\int_0^\\frac{\\pi}{2}\\sin^nx\\mathrm{d}x\\=\\begin{cases}\\frac{n-1}{n}\\cdot\\frac{n-3}{n-2}\\cdot\\ \\cdots\\ \\cdot \\frac{3}{4}\\cdot\\frac{1}{2}\\cdot\\frac{\\pi}{2}\\quad (\\text{n is even}) \\\\frac{n-1}{n}\\cdot\\frac{n-3}{n-2}\\cdot\\ \\cdots\\ \\cdot \\frac{4}{5}\\cdot\\frac{2}{3}\\quad (\\text{n is odd, n\u0026gt;1})\\end{cases}$  ","date":"2021-01-04T00:00:00Z","image":"https://blog.supersassw.com/p/univ-am-formula/76524292_p0_hu496f4562aacbed9d40936841282eb41a_2147862_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/univ-am-formula/","title":"高等数学——常用公式……"},{"content":"一、什么是数组 1、与数学的联系——数列 关于数组，你可以就把他当作数学上的“数列”，用来存一系列的数。\n数学上的一个数列$a_i$：\n当$i=1$时，代表的是这个数列的第一个数$a_1$，当$i=3$时，代表的是这个数列的第三个数$a_3$……\n同时，这个数列可以叫数列$a_i$，也可以叫$b_i、{nico}_i$……\n可以用$i$来表示第几项（$a_i$），也可以用$j$来表示第几项（$a_j$）……\n\r 2、与数学的不同  数学上的数列是从第一项开始的，也就是$a_1$代表的就是$a$这个数列的第一项。\n然而编程里的数组，却是从第零项开始的，也就是a[1]代表的是a这个数组里第二项，a[0]才是第一项。 数学上的数列，我们不需要提前告诉这个数列中会有多少项。\n然而编程里的数组，我们需要提前告诉他这个数组里会有多少项，也就是int a[100]的100的意思，代表可能会存100项。  3、编程中的数组 那么类比到我们编程里：\n 这个$a_i$的$a$，就是程序里的这个数组的名字，专业名称叫“变量名”。 这个$a_i$的$i$，就是程序里的这个数组的第几项，专业名称叫“下标”。  比如arr[5]代表的就是arr这个数组里的第6项。\n二、数组的声明 申明部分，也就是定义。如：\nint arr[100];  int——代表的是这个数组的类型：即这个数组存的是一系列int类型的数。\narr——代表的是这个数组的变量名，之后用这个数组就是arr[2]、arr[i]之类的形式。\n[100]——代表的是这个数组的大小，也就是可能会存多少项。\n 对于数组大小的声明，必须为常量或者常量表达式。\n正确的例子：\nint a[10];\t//字面常量（常数） int b[5 * 5];\t//字面常量的表达式  const int len = 10; int c[len];\t//符号常量 int d[len * 2];\t//符号常量的表达式 \n\r\r错误的例子：\nint len = 10; int a[len];\t//len为变量，错误 int a[len + 5];\t//len+5为变量相关的表达式，错误 \n\r\r\r 三、数组的运用 1、对一个数组某个具体元素的运用   最简单的运用，我们直接把一个常数100存到arr数组里的第三项里：\na[2] = 100;   要把一个变量val存到arr数组里的第一项里：\na[0] = val;   要输出数组arr中的第二项：\ncout \u0026lt;\u0026lt; a[1];   2、对一个数组多个元素的运用 很多时候我们不止运用其中的某一个具体的数。\n比如我们要向这个数组读入10个数，然后输出这10个数，这就涉及了多个元素的操作。\n我们再类比数列，假如我们要对数列$a_i$的第一项到第十项求和：\n用的是不是$\\sum_{i=1}^{10}a_i$这个公式，\n用个$i$来代表第几项，然后$i=1\\sim10$，把$a_i$累加起来。\n类比到编程，同样用个i来代表第几项，然后i=0~9，把arr[i]累加起来存到sum里。\n仍要注意到第一项是从0开始，所以是0~9！\n\r\n  对数组前十项求和  for (i=0; i\u0026lt;=9; i++) sum = sum + arr[i];  其中这里的涉及到从头到尾加起来的操作，\n我们把对一个数组从头到尾进行某些操作叫做“遍历”。\n以后会提到的概念注意一下。\n\r 那么类推一下，要向数组里读入$10$个数\n 读入十个数到数组前十项  for (i=0; i\u0026lt;=9; i++) cin \u0026gt;\u0026gt; arr[i];  然后再输出\n 输出数组中前十项  for (i=0; i\u0026lt;=9; i++) cout \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;  总代码：\nint i, arr[100], sum = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入十个数：\u0026#34;; for (i = 0; i \u0026lt;= 9; i++) cin \u0026gt;\u0026gt; arr[i]; for (i = 0; i \u0026lt;= 9; i++) sum = sum + arr[i]; cout \u0026lt;\u0026lt; \u0026#34;你刚才输入的十个数为：\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt;= 9; i++) cout \u0026lt;\u0026lt; \u0026#34;arr[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34; \u0026lt;\u0026lt; arr[i] \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;总和为：\u0026#34; \u0026lt;\u0026lt; sum; 效果为： 上述代码效果\n 如果为先输入一个数n，然后读入n个数，只需要改下循环条件即可。\n 读入n个数到数组  int n; cin \u0026gt;\u0026gt; n; for (i = 0; i \u0026lt;= n-1; i++)\t//注意读n个数是(i=0;i\u0026lt;=n-1)，就像之前读10个数是(i=0;i\u0026lt;=9) //也可以写成 for (int i = 0; i \u0026lt; n; i++)，不过最好选择一种格式以后就这样写，不然可能会晕 \tcin \u0026gt;\u0026gt; arr[i];  其余输出什么的同理。\n3、对多个数组的运用 很多时候我们可能要从a数组拿出一些数放到b数组里，这个时候下标可能就会很疑惑。\n比如我们可能会把arr数组里十个数放到b数组对应位置里。\n这个时候数学表示就是$b_i=arr_i(i=1\\sim10)$\n  把arr数组十个数放到b数组里  for (i=0; i\u0026lt;=9; i++) b[i] = arr[i];  但不一定每次都是刚好把arr的第i项放到b的第i项，也可能是比如：\n从arr的第五项开始，取5项（即a[4] ~ a[8]，放到b的第十项后面（即(b[9] ~ b[13])。\n要记住数组的下标不只是用i来表示，也可以用其他变量来表示。\n因此我们可以定义两个变量j和k，来分别表示两个数组arr和b的下标。\n刚开始令j = 4，k = 9\n开始取第一项放进b时，也就是b[9] = arr[4]，这个时候就是b[k] = arr[j]。\n然后取第二项放进b时，也就是b[10] = arr[5]，\n因此我们就可以在放完一项后，让k = k + 1和j = j + 1，\n这个时候的b[k] = arr[j]，是不是就代表b[10] = arr[5]了。\n 从arr的第五项开始，取5项，放到b的第十项后面。  j = 4, k = 9;\t//分别代表arr数组和b数组的下标 for (i=1; i\u0026lt;=5; i++)\t//做5次循环，代表取5项 { b[k] = arr[j]; k++; j++; }  这里是比较难但很重要的点，如果分析也看不懂，可以手动模拟一下：\n自己按照程序一行一行执行，在本子上画两行表格，一行代表arr数组，一行代表b数组；j=4时就用个箭头指向arr[4]，j++则移动箭头指向arr[5]……\n如果理解了，那数组差不多也都理解了。\n四、例题讲解 选择“实验8”的第1题。\n1、题目要求 实验8第一题\n2、数组的定义分析 因为要输入的是实数（小数），所以要用double或float类型。\n然后有15个数，但注意到要把计算后的平均值存到a数组最后的a[15]里，即实际上为16个数，长度为16。\n 故定义数组：\ndouble a[16];  3、数组刚开始的原样读入、原样输出和求平均值 如果认真看了之前的“数组的运用”，这里应该问题不大。\n多的点就是要每行五个输出，并且域宽为10。\n 代码：\ndouble sum = 0;\t//求和变量注意清零  //读入部分 for (i = 0; i \u0026lt;= 14; i++)\t//i=0~14，读入十五个数 { cin \u0026gt;\u0026gt; a[i];\t//读入a[i] \tsum = sum + a[i];\t//顺便对a[i]的所有项求和，方便后面求平均值 } //求平均值部分 a[15] = sum / 15;\t//求的总和除以个数，也就算的是平均值，放到题上要求的a[15]里  //输出部分 for (i = 0; i \u0026lt;= 14; i++) { if ((i+1) % 5 == 0) cout \u0026lt;\u0026lt; endl; //这里用如果(i+1)%5==0则换行，也就是i=5,10,15,...的时候换行，达成了每五个换行的效果 \t//这个可以记下来，如果是每7个换行，就写 if (i%7 == 0) cout\u0026lt;\u0026lt;endl; \tcout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i];\t//输出a[i]，setw为设置域宽 }  4、调整a数组，以满足题目条件形式输出 因为我们要调整a数组里的数，最终输出a数组。\n所以可以先把a数组里的所有数存到b数组里，然后再“遍历”b数组，判断某一个数b[i]跟平均值的关系，如果大于则放到a数组前面，小于则放到后面。\n首先先来写怎么把a数组里的所有数存到b数组里，前面已经写过了这里直接写代码。\n 代码：\nfor (i = 0; i \u0026lt;= 14; i++)\t//把a数组放到b数组里 { b[i] = a[i]; }  接下来就是难点了，判断出关系后，怎么样才能把b[i]放到a数组前面或者后面。\n之前说过的，下标不一定只能用i，也可以定义新变量来表示下标。\n 于是我们可以定义两个变量begin和end，分别代表a数组前面和后面的下标。\n刚开始begin = 0, end = 14，分别代表最开始的前面的下标和后面的下标。\nway_1\n【注意a[15]为平均值】\n  然后遍历b数组，假如第一个数b[i]（$i=1$）为$3$，小于平均值a[15]则该放到后面，也就是a[end]。\n先让a[end]=b[i]，\nway_2\n  然后再让end = end - 1，\nway_3\n  这样，当再次找到下个小于平均值的数时，则会放到当前的最后面处；\n找到下个大于平均值的数时，则会放到当前的最前面处。\n如图： way_4\n   代码：  cout \u0026lt;\u0026lt; \u0026#34;调整后的数据为:\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt;= 14; i++)\t//把a数组放到b数组里 \t{ b[i] = a[i]; } int begin = 0, end = 14; for (i = 0; i \u0026lt;= 14; i++)\t//遍历b数组，跟平均数比较，放回a数组 \t{ if (b[i] \u0026lt; a[15])\t//跟平均数比较 \t{ a[end] = b[i]; end--; } else { a[begin] = b[i]; begin++; } } for (i = 0; i \u0026lt;= 14; i++)\t//输出a数组  { if (i % 5 == 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i]; }  5、总代码 #include \u0026lt;iomanip\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; int main() { int i; double a[16], b[16]; double sum = 0.0; cout \u0026lt;\u0026lt; \u0026#34;请输入15个实型数：\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt; 15; i++) //读入 \t{ cin \u0026gt;\u0026gt; a[i]; sum = sum + a[i]; } a[15] = sum / 15;\t//求平均值 \tfor (i = 0; i \u0026lt; 15; i++) //原样输出 \t{ if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) //【这里加了个i!=0的条件，防止最开始就换行 \t{ cout \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i]; } cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;调整后的数据为:\u0026#34; \u0026lt;\u0026lt; endl; for (i = 0; i \u0026lt; 15; i++) //把a数组放到b数组里 \t{ b[i] = a[i]; } int begin = 0, end = 14; for (i = 0; i \u0026lt; 15; i++) //遍历b数组，跟平均数比较，放回a数组 \t{ if (b[i] \u0026lt; a[15]) { a[end] = b[i]; end--; } else { a[begin] = b[i]; begin++; } } for (i = 0; i \u0026lt; 16; i++) //输出a数组【注意这里是遍历输出整个a数组，即a[15]这个存的平均值也要输出，所以变成了(i = 0; i \u0026lt;16; i++) \t{ if (i % 5 == 0 \u0026amp;\u0026amp; i != 0) cout \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; setw(10) \u0026lt;\u0026lt; a[i]; } }  这里只讲的老师的第一种方法，更好理解一些。对于第二种方法可以自行尝试，跟这个大致相同，不懂也可以自己在草稿纸上模拟一下。  五、其他提示   数组的范围可以开大，但不能开小。\n意思就是尽管最多可能只有10个整数，你可以定义为int a[100]，但不可以int a[9]。\n推荐是比最多个数开稍微大一点，这样又可以偷懒想要开几个，又可以防止越界错误【本来只定义了15个，你访问了a[20]】。\n  因为编程里数组第一项是从a[0]开始的，比较反人类x……\n所以如果想按照数学习惯，完全可以从a[1]开始存数。\n 比如读入15个数，原来可能写成\nfor (i = 0; i \u0026lt;= 14; i++) cin \u0026gt;\u0026gt; a[i]; 这样就是存在a[0]~a[14]里。\n你也可以写成符合我们习惯的\nfor (i = 1; i \u0026lt;= 15; i++) cin \u0026gt;\u0026gt; a[i]; 这样就是存在a[1]~a[15]里。\n 不过选择好一种自己喜欢的就这么写，不要一会从$0\\sim14$一会又$1\\sim15$，不然会很混乱。\n  没了。\n  有关排序的算法可能是常考点，各位可以自己去背一下。\n  以上。\n","date":"2020-12-26T00:00:00Z","image":"https://blog.supersassw.com/p/univ-cpp-note-array/72693520_p0_hu5438825b9b6d1014226d20d231e650c2_940838_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/univ-cpp-note-array/","title":"程序设计——数组……"},{"content":"以下大部分总结于半期考试之前……\n\r 一、注意的点 1、用作为“累加、累乘”的变量的注意事项 例子——累加、累乘的变量\r sum1 = sum1 + a;——作为累加求和。 sum2 = sum2 * a;——作为累乘求和。  \r   是否定义时赋初值？\n int sum1 = 0;——累加变量赋初值为0。 int sum2 = 1;——累乘变量赋初值为1。    在循环里反复使用，要注意可能要将累加变量清零，累乘变量赋一。\n例题\r题目：\n统计3组数据的和，其中每组数据会有n个数。\n\r\r部分代码：\nint sum = 0;\t//赋初值为0  for (int i = 1; i \u0026lt;= 3; i++)\t//循环3组数据 { cout \u0026lt;\u0026lt; \u0026#34;请输入第\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;组数据有多少个数：\u0026#34;; cin \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; \u0026#34;请输入n个数：\u0026#34;; for (int j = 1; j \u0026lt;= n; j++)\t//读入并统计这组数据里n个数的和  { cin \u0026gt;\u0026gt; a; sum = sum + a; } cout \u0026lt;\u0026lt; \u0026#34;这组数据和为：\u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; sum = 0;\t//关键语句：这里即要注意每读完一组数据要清零！否则会带着上次计算的结果算下一组 } 输出：\n 加了sum = 0;这句清零语句：\n正确答案 未加sum = 0;这句清零语句：\n错误答案  \r   2、有关函数的讲解和注意事项 函数的三个要点：\n 我要给他什么东西？（给几个东西、这些东西是什么类型） 我想要这个函数干嘛、完成什么事？ 他要给我返回个什么东西？（只能返回一个值，否则不叫函数）  \r 一般要求写函数，都是基于这三点分析：\n 根据1和3两点来确定怎么声明函数。 根据2这点来确定怎么实现函数。  例题一\r题目：要求写一个函数，用来返回两个整数的最大值。\n\r\r分析与实现\r分析如下：\n 我应该给这个函数两个int类型的数据。 这个函数应该找到这两个数谁最大。 这个函数应该返回给我这两个数的最大值，也是int类型的数据。   故声明部分为：\nint max(int, int); 实现部分为：\nint max(int num1, int num2) { if (num1 \u0026gt; num2) return num1; else return num2; } 使用部分为：\nint main() { int max(int, int); cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; \u0026#34;两个数的最大值为：\u0026#34; \u0026lt;\u0026lt; max(a,b); } \r\r例题二\r题目：要求写一个函数，用来确认某个数是否在某个数组a[10]里（为double类型数组）。\n\r\r分析与实现\r分析如下：\n 我应该给这个函数一个我要找的数，这个数为double类型；还要给我要找的数组，这个为数组的double*指针类型。 这个函数判断这个数是否存在于a这个数组。 这个函数应该返回给我这个数是否存在于a数组，是个bool类型的数据。   故声明部分为：\nbool if_inside(double, double*); 实现部分为：\nbool if_inside(double num, double* arr) { for (int i = 0; i \u0026lt;= 9; i++) { if (arr[i] == num)\t//如果与数组中某个数相等，代表找到，返回true  return true; } return false;\t//遍历完数组都没找到，代表真的没有，返回false } 使用部分为：\nint main() { bool if_inside(double, double*); cin \u0026gt;\u0026gt; n; if ( if_inside(n) )\t//判断n是否在a数组内  cout \u0026lt;\u0026lt; \u0026#34;n这个数在a数组内\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;n这个数不在a数组内\u0026#34;; } \r\r\r函数的注意事项   如果把函数实现写在int main()之前，便不用在main里声明函数了。【见书P86 第二个黑色方框】\n  函数一旦return后，便不会再执行之后的语句。\n  不同函数（包括main这个“主函数”）里面的变量不能互相调用。\n 即假如main()里有个int a，则不能在子函数fx()中用a = 1这样。\n如果main()里有个int a，子函数fx()里也有个int a：则main里只能用main里的a，fx里只能用fx里的a。\n 这个其实就是局部变量的原因，函数里的变量为局部变量，只能在这个函数里用。\n  \r 二、需要记住的模板 1、生成随机数   必须写上的代码（提供随机种子）\n直接写在int main()后面的第一句话就好。\nint main() { srand(time(NULL)); ... }   使用方法\n 要取得$(a,b)$的随机整数，使用( rand() % (b-a+1) ) + a + 1; 要取得$[a,b)$的随机整数，使用( rand() % (b-a) ) + a; 要取得$[a,b]$的随机整数，使用( rand() % (b-a+1) ) + a; 要取得$(a,b]$的随机整数，使用( rand() % (b-a) ) + a + 1;  例子——随机生成1到100内的整数（含1和100）\r代码：\nint num = rand() % (100 - 1 + 1) + 1; 或者直接写成：\nint num = rand() % 100 + 1; \r   记忆方法：\n想象$rand()$是能返回完全任意的数。\n当你对这个任意的数$\\mod 100$（对100取余数）后，那么余数范围只能是$0\\sim99$。\n再加个$1$，范围变成了$1 \\sim 100$。\n\r 2、最大公约数（GCD）和最小公倍数（LCM）的计算 这个比较重要，也很难背。\n\r 直接背代码。\n老师给的版本 最大公约数（GCD）\rint GCD(int a, int b) //求a和b的最大公约数 { int c, r; if (a \u0026gt; b) //保证a是两数中较小的数  { c = a; a = b; b = c; } r = b % a; while (r != 0)\t//这个过程背住orz……  { b = a; a = r; r = b % a; } return a;\t//最后的a值为求得的结果 } 最小公倍数（LCM）\rint LCM(int a, int b)\t//求a和b的最小公倍数 { return (a * b) / GCD(a, b); } \r这里用函数的形式来写，以后求解可可以直接用这个函数。如：\ncin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;和\u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt;\u0026#34;的最大公约数为：\u0026#34; \u0026lt;\u0026lt; GCD(n,m) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;和\u0026#34; \u0026lt;\u0026lt; m \u0026lt;\u0026lt;\u0026#34;的最小公约数为：\u0026#34; \u0026lt;\u0026lt; LCM(n,m); 不用函数的话，就把那里面的东西直接写到main()里就行。\n更好记的版本 利用递归思想求最大公约数，可以极大简化代码。\n\r 可以尝试理解下这个代码，能很好的锻炼递归思想。\nint GCD(int a, int b) { return b ? GCD(b, a % b) : a;\t//意思是如果b不为0，则a=b,b=a%b辗转相除；否则就返回a }  或者采用这个递推的思想，极其好记！\nint GCD(int a, int b) { while (b ^= a ^= b ^= a %= b); return a; } 【但原理就不要求掌握了，其中的^=是位运算……\n3、判断某数是否为质数 直接背代码。\n代码里有几个要注意的点。\n\r bool if_Prime(int num) { if (num == 1) return false; //！特别注意！：当num=1的时候很可能之后会判断失误，故需要“打补丁”：当num=1的时候直接返回false  bool flag = true;\t//刚开始假设是素数  for (int i = 2; i \u0026lt;= num-1; i++)\t//！注意！：这里是(2~num-1)，而不是(2~num)，很容易在这里写错  if (num % i == 0) //找到能被(2~num-1)之中的数除尽，证明不是素数，设置flag并退出循环  { flag = false; break; } return flag;\t//如果循环完都没有被除尽，证明是素数，会返回true；否则会返回flase } 这里用函数的形式来写，以后判断就可以直接用这个函数。如：\ncin \u0026gt;\u0026gt; n; if ( if_Prime(n) ) cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;是素数\u0026#34;; else cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;不是素数\u0026#34;; 4、对数组的排序 就两种排序方法：\n 冒泡排序 选择排序  两种方法仅存在写法上的区别，建议自己选择一种自己背得到的记住。\n而且写法的差别并不大，仅是for循环范围的区别。\n很可能会考到写法【个人感觉【……\n\r 【模板见老师的PPT，如果没记的话可以问我……\n5、二分查找（折半查找） 有可能要考，考的话会专门指出“请用二分查找来找出\u0026hellip;”。\n不然的话就可以用“从头到尾遍历数组”来找。\n【模板见老师的PPT，如果没记的话可以问我……\n使用二分查找，需要先让数组有序，如果是无序的数组先要排序。\n\r 三、常用头文件及函数  #include \u0026lt;...\u0026gt;   #include\u0026lt;iostream\u0026gt;\n最基本的库。\ncin、cout等基本指令都需要这个库，写程序直接写上即可。\n记忆方法\r io ————\u0026gt; input\u0026amp;output 输入输出 stream ————\u0026gt; stream n.流  即“输入输出流”。\r\n  #include\u0026lt;ctime\u0026gt;\n使用随机生成时要用到的库。\n即生成种子时用的time()需要这个库。 记忆方法\r c ————\u0026gt; 值c++ time ————\u0026gt; time n.时间  即用来管时间的库。（随机函数需要用时间来作为种子，这样才能保证随机生成不重复）\r\n  #include\u0026lt;iomanip\u0026gt;\n控制输出格式要用到的库。\nsetw(...)、fixed()、precision(...)（基本为这三个）需要用到这个库。 记忆方法\r io ————\u0026gt; input\u0026amp;output manip ————\u0026gt; manipulator n.操控器 的前五个字母  即“输入输出控制器”。\r\n  #include\u0026lt;string\u0026gt;\n使用c++的字符串要用到的库。\n对字符串大致使用不了解的看书P132-134。（会点很基础的输入输出就行，不用太了解）\n  【库这些东西多写了没坏处，可以写之前就把这些库都写上，之后复制粘贴就行xd……\n四、常见非编译问题和错误弹窗解释 1、未赋初值类 弹窗显示如图：\n错误类型1\n 中文意思：“val”（橙色圈出）这个变量没被初始化（赋初值）就在使用。 出现原因：一般出现在累加变量未赋初值为0，就在用sum=sum+a。 解决方法：找到变量名为引号里的变量，在使用其前赋相应初值。  错例\r错误1-例\n红色划线为对val的使用处，橙色划线为val的定义处。\n很明显看到val在使用前未被赋初值。\n故在使用前赋个初值（这里为累加变量，所以赋初值为0），即：val = 0。\n\r 2、数组越界类 弹窗显示如图：\n错误类型2\n 中文意思：变量“a”周围的栈被破坏。【理解不到没关系看下面_(:з」∠)_…… 出现原因：出现在对数组元素的访问中，访问的下标超过数组最大个数。 解决方法：找到变量名为引号里的数组的声明部分，将其空间开大点。  错例\r错误2-例\n橙色划线定义个数组空间为$10$，即只能用a[0]~a[9]。\n但在红色划线里，却用了a[10]，明显超出了最大范围，即越界了，所以会出现此错。\n故在定义部分int a[10]，把它空间开大点变成int a[11]即可。\n\r 这也是数组中很常见的误区和错误需要注意！\n\r 3、死循环类 这类错误不会报错，但会感觉程序怪怪的……\n比如：\n 一直黑屏，没有任何反应。\n（如果不确定是不是电脑卡了的原因，可在int main()最开始加一句cout\u0026lt;\u0026lt;\u0026quot;test\u0026quot;来判断：如果输出了test，则证明不是程序卡了。） 明明只想读入几个数，却发现一直在读入。 明明只想输出几个数，却发现一直在输出。  这几类便是说明你的程序陷入了“死循环”。\n 如下程序：\n错误3-例\n本意是只读入五个数，输出这五个数的和。\n运行时：\n错误3-运行界面 发现一直在读入。\n  出现原因：  循环变量没有改变。  如忘了i++、i--、i=i+2等。\n  循环条件不可能中止。  如for (i = 1; i \u0026gt;= 0; i++)，$i\\geq 0$会一直成立。\n  循环里不小心改变了循环变量。  如：\nfor (i = 1; i \u0026lt;=10; i++) { ... i = 0; } 每次循环i又会变为0，则会一直循环造成死循环。\n     还可能有其他各种原因，反正问题都出在循环里，仔细检查下自己写的循环部分。\n五、其他杂类   有关i++和++i的区别，不懂看书P45。\n  有关条件运算符... ? ... : ...的用法（不一定会用，但是要看得懂），不懂看书P45。\n  强制类型转换(int)4.8、(double)1是否还记得？不记得看书P50。\n  对const（符号常量）这个东西是否还记得？\n 如const double PI = 3.1415926\n 不记得看书P31。\n  确定是否掌握setw、precision等控制输出格式的用法，不会看书P34-P35。\n  对字符数组char a[100]，了解这是什么即可（c里面的字符串），不必掌握。\n  字符串最后会有个看不见的\\000这个空字符：\n 如字符串\u0026quot;MinatoAqua\u0026quot;\n 长度为$10$。 存储时存放$11$个字符串。     一定注意{}的匹配！ 特别牢记你的这个if或for要管哪几句话，就把哪几句话打上{}\n  强烈建议把程序写的规范一点\n 一句话（用;结尾的）就是一行 {和}单独占一行 {之后的语句空两格（或者按“Tab”这个键） }之后（包含这一行）的语句往前删两个空格（用的“Tab”的删一次就可以） 具体样式就是以上我写的那种样子。  \r 这样不只是好看，更能让你的整体思路保持清晰，不然很容易犯{}不匹配的问题！\n  要知道你每写一句话是在干嘛，这句话我写出来是什么目的。【有点抽象，不过确实很需要知道自己的目的，怎么实现这个目的，等熟练后这个自然也就会很清楚了orz……\n   以上，\n祝武运昌隆！……\n","date":"2020-12-26T00:00:00Z","image":"https://blog.supersassw.com/p/univ-cpp-summary/58541644_p0_hu0c218c74dadec57d38928125b7e7f710_1153603_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/univ-cpp-summary/","title":"程序设计——考点总结……"},{"content":"Timeline…… 时间线标签的移植测试……\n测试 总历程……\n2020-12-24 19:00提出构想……\n\r这个时间线好好看啊，我也要实现！……\n这里面还能套娃哦x……\n\r\r\r\r2020-12-25这里想要测试下所以这里的标题要非常非常非常的长这样才能测试是否全平台适配……\n\r到了明天【？……\n 感觉实现了……  这里面用Markdown写！……\n然后这里也要非常非常非常非常非常非非常非常非常非常非常非常常非常非常非常非常非常非常的长……\n\r\r2020-12-25 233:33:33\n\rtime其实内容随意（没有检测直接原样输出），填个不是时间的也可以……\n最后一个测试了！……\n 来个公式：  $$[{2{x^T}(t)x(t - \\tau ) = {x^T}(t){Q^{ - \\frac{1}{2}}}x(t - \\tau ) \\le \\frac{1}{\\alpha }{x^T}(t)Px(t) + \\alpha {x^T}(t - \\tau )x(t - \\tau )}]$$ 我也不知道这是啥_(:з」∠)_……\n  来个代码：  freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;r\u0026#34;,stdin); printf(\u0026#34;qwq\u0026#34;);    \r\r2020-12-25 20:28正式实现并适配……\n\r实现了！……\n也不知道会不会出问题，反正能跑就行.jpg……\n改后的样式配上这个主题感觉还是很好看的√……\n不过markdown里看着好乱啊也没办法的'_\u0026gt;'……\n好累orz……\n\r\r  ……Test 1……\n\r无标题的时间线测试……\r\r……Test 2……\n\r无标题的时间线测试……\r\r 实现方法 又又又又又是Shortcode！……\n换行输入模式……\n{ {\u0026lt; timeline theme=\u0026#34;...\u0026#34; \u0026gt;} } { {\u0026lt; timeline/node time=\u0026#34;...\u0026#34; title=\u0026#34;...\u0026#34;\u0026gt;} } 内容...... { {\u0026lt; /timeline/node \u0026gt;} } { {\u0026lt; timeline/node time=\u0026#34;...\u0026#34; title=\u0026#34;...\u0026#34; url=\u0026#34;...\u0026#34;\u0026gt;} } 内容...... { {\u0026lt; /timeline/node \u0026gt;} } { {\u0026lt; /timeline \u0026gt;} }  外层：\ntheme（可选项）：为这条时间线的标题……\n 内层：\ntime（必填项）：节点时间……\ntitle（可选项）：节点名称……\nurl（可选项）：节点链接（外部链接要加https://）……\nnew（可选项）：如果填了url，将new设为1可以在新窗口打开标签……\n   想法还是来自于：\n小康博客 —— Hexo博客之butterfly主题优雅魔改系列（持续更新）\n\r 个人在其基础上修改了CSS以适配此主题……\n并以Shortcode的形式完成对Hugo的移植……\n","date":"2020-12-24T00:00:00Z","image":"https://blog.supersassw.com/p/test-timeline/pixiv61107110_huba53cd19c95d0fe8cd12b027cea0c3df_3255125_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-timeline/","title":"Timeline测试……"},{"content":"发现note嵌套中还是会出现格式混乱的问题，待修复……\n\r 错误例子\r{{\u0026lt; note info \u0026gt;}} 1. 测试 {{\u0026lt; snote error \u0026#34;这里有问题……\u0026#34; \u0026gt;}} {{\u0026lt; /note \u0026gt;}} \r  Note测试…… 对Hexo中Volantis主题的note移植测试……\n NoteBlock 是 Blockquote 的增强版，在左边显示图标，并且可以自定颜色。\n 长Note 适用于需要换行输入的note……\n 很长很长的note！……\n还可以换行！……\n因为内容是Markdown格式……\n里面干什么都可以_(:з」∠)_……\n这句话是一句很长的话我用来测试他能否在不同移动端上也能正常显示我希望他真的能正常显示不然我又要去改scss了呜呜呜x但是现在这个长度还不够我还要再加长点嗯现在应该够了让我们看看效果吧！……\n为了能使长note内嵌，暂时将goldmark里的unsafe调为了true（能内嵌HTML），日后再改进……\n\r\r\r 使用方法：\n\u0026lt; note guide(theme) blue(color) \u0026gt; (content) \u0026lt; /note \u0026gt;  注意：\n如果要在引用内容（\u0026gt;）中使用，\n则只能在开头写一个\u0026gt;，其内容和结束部分都不要打\u0026gt;……\n\r  短Note 适用于很短的一句话的note……\n  不带颜色的……\n 成功（success）……\n\r 使用方法：\n\u0026lt; snote success \u0026#34;...\u0026#34; \u0026gt;    带颜色的……\n 背景是SuperSASS蓝（blue）的链接图示（link）……\n\r 使用方法：\n\u0026lt; snote link \u0026#34;...\u0026#34; blue \u0026gt;    图标问题已修复……\n\r  测试： Test——up……\n\r Test——paperclip in yellow……\n\r\n 参数 图标  带颜色的：quote, info, warning, done/success, error/danger 不带颜色的：radiation, bug, idea, link, paperclip, todo, message, guide, download, up, undo  颜色  clear, light, gray, red, yellow, green, cyan, blue   想法来自于：\n小康博客 —— Hexo博客之butterfly主题优雅魔改系列（持续更新）\n\r 使用了其CSS后，用基于Hugo的Shortcode实现，并更改部分CSS使得匹配该主题……\n更多note也可以参见该页面……\n同时滚动条样式也参考了这位dalao然后自己改的【感恩……\n","date":"2020-12-23T00:00:00Z","image":"https://blog.supersassw.com/p/test-note/Yande-713907_hu78325a06b1473fc65240ca2cf12d1105_794019_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-note/","title":"NoteBlock测试……"},{"content":"该笔记还未完成整理，待日后继续整理……\n\r 该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误……\n\r\n其实并不是笔记，\n只是在例题中自我总结了一点相关知识_(:з」∠)_……\n日后可能专门总结成笔记……\n源码 /* 并查集算法 用father数组记录每个节点的父节点，数据结构类似于树 关键操作：合并、查询 详细介绍: https://zhuanlan.zhihu.com/p/93647900 */ //P3958 奶酪: https://www.luogu.com.cn/problem/P3958 #include \u0026lt;bits/stdc++.h\u0026gt;#define N 1005 using namespace std; inline int quickRead() { int f = 1, num = 0; char t = getchar(); while (t \u0026lt; \u0026#39;0\u0026#39; || t \u0026gt; \u0026#39;9\u0026#39;) f = t == \u0026#39;-\u0026#39; ? -1 : 1, t = getchar(); while (t \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t \u0026lt;= \u0026#39;9\u0026#39;) num = num * 10 + t - \u0026#39;0\u0026#39;, t = getchar(); return f * num; } struct typeUnionFind { int num, father[N], rank[N]; //这里rank作用是记录节点深度（真实为深度-1），采用了按秩合并的优化  /* 按秩合并指将深度小的合并到深度大的树上，这样可以减少查询次数。 这里按秩合并与路径压缩一起使用时，rank可能会因路径压缩操作而变得不准确。 因此这里rank只是相对的判断标准，并不一定绝对会将深度小的合并到深度大的 */ void init(int n) { num = n; for (int i = 1; i \u0026lt;= num; i++) father[i] = i; } inline int find(int node) { return father[node] == node ? node : (father[node] = find(father[node])); //这里使用了路径压缩优化  } inline void merge(int node1, int node2) { int father1 = find(node1), father2 = find(node2); if (rank[father1] \u0026lt; rank[father2]) father[father1] = father2; else if (rank[father1] \u0026gt; rank[father2]) father[father2] = father1; else if (father1 != father2) father[father1] = father2, rank[father2]++; //如果深度一样且父节点不一样（不为一棵树），合并后新树深度会加一  } } UnionFind; struct typeHole { long long x, y, z; } hole[N]; bool ifIntersect(typeHole hole1, typeHole hole2, long long r) { return (hole1.x - hole2.x) * (hole1.x - hole2.x) + (hole1.y - hole2.y) * (hole1.y - hole2.y) + (hole1.z - hole2.z) * (hole1.z - hole2.z) \u0026lt;= 4 * r * r; } int main() { long long T, n, h, r; scanf(\u0026#34;%lld\u0026#34;, \u0026amp;T); while (T--) { scanf(\u0026#34;%d%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;h, \u0026amp;r); UnionFind.init(n); UnionFind.father[1001] = 1001, UnionFind.father[1002] = 1002; //这里用特殊的两个节点，1001代表底，1002代表顶。如果father[1001]==father[1002]则证明连通。  for (int i = 1; i \u0026lt;= UnionFind.num; i++) { scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;hole[i].x, \u0026amp;hole[i].y, \u0026amp;hole[i].z); if (hole[i].z \u0026lt;= r) UnionFind.merge(1001, i); if (hole[i].z \u0026gt;= h - r) UnionFind.merge(1002, i); } for (int i = 1; i \u0026lt;= UnionFind.num; i++) for (int j = 1; j \u0026lt;= UnionFind.num \u0026amp;\u0026amp; i != j; j++) if (ifIntersect(hole[i], hole[j], r)) UnionFind.merge(i, j); if (UnionFind.find(1001) == UnionFind.find(1002)) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } } /* WA 1st: 没考虑到只有一个洞以及贯穿的情况…… 修改: 1. merge(i,1001) ---\u0026gt; mergr(1001,i) 实际上完全没必要，因为无论前并后还是后并前，最终都是父节点合并…… 2. if (hole.z\u0026lt;=r) ... else if (hole.z\u0026gt;=h-r) ...; ---\u0026gt; if ...; if ...; 当时想着要么是底部相交要么是顶部相交，导致用了个else if，没考虑到直接贯穿的情况…… WA 2nd: long long！！！！…… */ ","date":"2020-12-20T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-union_find/60855211_p0_hu2f29f1f8fc777ac15405156777510011_1339015_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/acm-note-union_find/","title":"ACM学习笔记——并查集……"},{"content":"该笔记还处于基础部分，待日后继续深入整理……\n\r 该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误……\n\r\n简介 是一种用来维护 区间信息 的数据结构。\n可以实现的操作：\n 单点、区间修改 区间查询（区间求和、最大值、最小值） 等等  描述 线段树会将一个非点区间（即长度大于$1$）利用递归的思想，二分为两个子区间来进行操作。\n这样就会将一个线段划分转化成一个树形结构。\n其中：紫色的a[]是原数组，红色的d[]是线段树：存储的区间的和，黄色范围代表管辖区间。\n每个节点会存储并维护其所管辖的区间的当前信息。（如上图存的就是区间的和）\n可根据题目要求，确定自己所需存储维护的信息。\n实现方法 提前的宏定义 #define NOW_Node node[index]\t//代表当前节点 #define NOW_LSon node[index].sonL\t//代表当前节点左儿子下标 #define NOW_RSon node[index].sonR\t//代表当前节点右儿子下标 0x00 建树 基本认识 根据上图可发现几个要点：\n 每一个节点i的左儿子下标是2i，右儿子下标是2i+1。 记：i管辖的区间为$[s,t]$。\n令：$mid=\\frac{s+t}{2}$。\n则左儿子2i管辖区间为$[s,mid]$，右儿子2i+1管辖区间为$[mid+1,t]$。  实现方法 之前已经介绍了递归的思想，那么只需要确定递归边界。\n由上图很容易看出，递归边界就是当长度为$1$的点。\n记：当前点为node[index]，代表区间为$[l,r]$。原数组为arr[]\n当$l=r$的时候，说明到达递归边界，这个时候的值直接为对应区间的值。\n也就是node[index] = arr[r]\n因为二分的操作使得递归的深度不会大于$log(n)$，故完全可以采用递归的方式简化代码，不用担心递归的栈溢出等缺点。\n储存方法 方法1、 struct typeNode { int val, L, R, mid, len;\t//val代表储存的值，L、R分别代表区间左、右端点，mid代表区间中点，len代表区间长度 }node[4*N]; 直接用左儿子下标为2i，右儿子下标为2i+1转递。\n函数为build(int index, int l, int r)，建左儿子用则为build(2*i, l, r)。\n 空间范围：反正直接把长度设置为$4n$。\n因为该线段树深度为$\\lceil log(n) \\rceil$，又因为为完全二叉树，总节点个数为$2^{\\lceil log(n) \\rceil +1}-1$。但建树的时候最后一层不一定从左往右建，也可能很右边会有一个，所以要预留出所有的最后一层的节点位置，即开$4N$。\n具体分析见关于线段树的数组到底是开2N还是4N。  方法2、 struct typeNode { int val, L, R, mid, len, sonL, sonR;\t//多了个sonL和sonR，代表左儿子的index和右儿子的index }node[2*N]; build()的时候需要多一个计数器变量cnt，记录总过有多少节点。\n函数为build(int \u0026amp;index, int l, int r)。其中传引用会在伪代码中解释。\n这里多存了个左儿子和右儿子的下标，使得可以保证从按顺序建，不会出现空间浪费，于是可以开$2N$。\n相较于方法2空间消耗会少一点。\n以下采用“方法2”的方式来储存。\n伪代码 struct typeSegment{ int cnt = 0;\t//记录node节点的数量，便可实现按顺序建树  struct typeNode{ int val, L, R, len, mid, sonL = 0, sonR = 0; } node[N * 2]; void build(int \u0026amp;index, int L, int R) //对区间[L,R]建立节点，下标为index \t{ index = ++cnt; /*引用index的原因： 这里因为引用index，在递归时会直接把seg[index].son_赋值为某儿子的index。 */ NOW_Node.L = L, NOW_Node.R = R, NOW_Node.mid = (L + R) \u0026gt;\u0026gt; 1, NOW_Node.len = R - L + 1;//节点基本信息  if (L == R) NOW_Node.val = arr[R]; //为递归边界，直接为对应区间的值 \telse { build(NOW_LSon, L, NOW_Node.mid); //划分建立左区间，注意这里传的index是sed[index].lson \tbuild(NOW_RSon, NOW_Node.mid + 1, R); //划分建立右区间 \tNOW_Node.val = node[NOW_LSon].val + node[NOW_RSon].val; //计算该区间信息 \t} } }Segment;\t//直接用个总结构体，便于模板化。//其实就是个个人癖好orz…… 0x01 区间查询 对区间进行值的条件查询，如对区间$[L,R]$求总和，求区间最值等操作。\n实现方法 将要查询的区间，拆成几个在其范围里的节点的区间进行求解计算。（类似于分块思想）\n 如果当前区间完全在查询区间的范围里，则直接返回这个区间的值。 如果不是，则分别查询左右区间计算最终值。  如果查询区间的左端点小于等于当前区间中点，则查询范围会存在于左儿子区间里，要查询左儿子。 如果查询区间的右端点大于当前区间中点，则查询范围会存在于右儿子区间里，要查询右儿子。 注意：这里为大于！因为中点是算在左区间里的！……\n\r    【直接给代码吧ヾ(•ω•`)o……\n伪代码 int query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; q_R\u0026lt;= NOW_Node.R) return NOW_Node.val; //当前区间直接在查询区间里，直接返回值 \t//【我查了，一句返回了，有什么好说的…… \t//↓ 不完全包含于查询区间里，就要查询两子区间的值计算 \tint tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); //如果要查询区间左端点，比当前区间的中点还大，证明左儿子区间完全不在 \tif (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R);\t//为\u0026gt;，不是\u0026gt;= \treturn tmpAns; } 0x02 区间修改 对区间进行值的修改，如区间$[L,R]$加上或乘上一个数。\n(最初)实现方法 跟查询的方法一样，找到对应区间后直接修改值。\n但注意，如果不是长度为1的区间，值的修改要乘上对应修改区间的长度。\n 比如对$[1,2]$这个区间加上$2$。\n$[1,1]$和$[2,2]$这两个子区间会加$2$。\n但$[1,2]$则个大的区间应该加的就是$4$。\n同理，$[1,4]$这个大区间就该加$8$了。\n 缺点分析 【诶我说停停，先别着急写啊，不要啪的一下就写起来了很快啊……\n如果碰上这样的情况：\n  对区间$[1,10000]$加上$10000$次$233$。 查询区间$[23333,23333]$的值。   怎么样，有没有觉得自己被耍了！\n所以如果当老实人，他让我们修改区间，我们就老老实实修改区间，可是要吃大亏的。【指TLE……\n改进方法 所以他耍我们，我们也耍一下他xd。\n不是让我们对区间修改吗，我们就先偷下懒：不老老实实地全部修改完，只做个记号在那。\n等到他让我们真正查询这个区间的时候，我们也才真正的去修改，并返回查询值。【并且注意lazy清零！……\n这便是lazy懒标记的由来。\n但我们该怎么偷懒呢？\n 如果当前区间完全在修改区间的范围里，我们便可以按分析的那样，先把修改的值加到lazy里。等之后有需要再去真正地修改，即“下放lazy”。 如果不是，这里就需要注意，我们再直接加到lazy标记的话，有些明明不该修改的区间就会被修改。所以这里的懒就偷不得，就要真正的修改当前节点的值，并尝试修改子节点。（但如果儿子可以偷懒，就让儿子去偷懒）  如果修改区间的左端点大于当前区间中点，则不会修改左儿子区间。 如果修改区间的右端点小于等于当前区间中点，则不会修改右儿子区间。    伪代码  区间修改：  struct typeNode{ int ..., lazy;\t//这里多定义个lazy，用来存偷懒没修改的值 } void modify(int index, const int \u0026amp;m_L, const int \u0026amp;m_R, const int \u0026amp;m_val) { if (m_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= m_R) NOW_Node.lazy += m_val;\t//当前区间完全在范围里，直接偷懒 \telse { NOW_Node.val += (min(m_R, NOW_Node.R) - max(m_L, NOW_Node.L) + 1) * m_val;\t/* 这里是修改所包含区间的值 如要修改[4,9]，当前节点区间是(1,6)\t//这里为了区分用的小括号，实际上包含端点 则只会修改[4,6)，也就是val += (6 - 4 + 1) * 2 */ if (m_L \u0026lt;= NOW_Node.mid) modify(NOW_LSon, m_L, m_R, m_val); if (m_R \u0026gt; NOW_Node.mid) modify(NOW_RSon, m_L, m_R, m_val); } }  有lazy的区间查询：  struct typeNode{ ... void pushdown(typeSegment *Segment)\t//下放也不用太彻底，能摸一层是一层xd…… \t{ val += len * lazy;\tif (sonL) Segment.modify(sonL, L, mid, lazy); //存在子节点才下放【不然我这种结构就会无限下放_(:з」∠)_…… \tif (sonR) Segment.modify(sonR, mid + 1, R, lazy); lazy = 0;\t//！lazy注意清零！ \t} } int query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (NOW_Node.lazy) NOW_Node.pushdown(*this);\t//注意查询的时候，只要有懒标记就必下放【别人都来查岗了你还摸鱼.jpg……  if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= q_R)\t//以下跟普通的查询操作一样 \treturn NOW_Node.val; int tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); if (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R); return tmpAns; } Tip: 我这里的偷懒是直接连本身都先不修改，而在下放的时候才修改；其他人有些可能会先修改自身。算是个小优化，注意区分一下……\n最终代码 洛谷P3372 【模板】线段树 1\n#include \u0026lt;bits/stdc++.h\u0026gt; #define N 100000  #define NOW_Node node[index]\t//代表当前节点 #define NOW_LSon node[index].sonL //代表当前节点左儿子下标 #define NOW_RSon node[index].sonR //代表当前节点右儿子下标 using namespace std; long long arr[N + 5]; struct typeSegment { int cnt = 0; //记录node节点的数量，便可实现按顺序建树  struct typeNode { long long val; int L, R, len, mid, sonL = 0, sonR = 0, lazy = 0; void pushdown(typeSegment \u0026amp;Segment) //下放也不用太彻底，左右儿子仍加到lazy里。【能摸一层是一层xd…… \t{ val += len * lazy; if (sonL) Segment.modify(sonL, L, mid, lazy); //存在子节点才下放【不然我这种结构就会无限下放 \tif (sonR) Segment.modify(sonR, mid + 1, R, lazy); lazy = 0; //lazy注意清零。 \t} } node[N * 2]; void build(int \u0026amp;index, int L, int R) //对区间[l,r]建立节点，下标为index \t{ index = ++cnt; //引用原因： \t//这里因为引用index的原因，在递归时会直接把seg[index].lson赋值为左儿子的index。 \tNOW_Node.L = L, NOW_Node.R = R, NOW_Node.mid = (L + R) \u0026gt;\u0026gt; 1, NOW_Node.len = R - L + 1; //节点基本信息 \tif (L == R) NOW_Node.val = arr[R]; //为递归边界，直接为对应区间的值 \telse { build(NOW_LSon, L, NOW_Node.mid); //划分建立左区间，注意这里传的index是sed[index].lson \tbuild(NOW_RSon, NOW_Node.mid + 1, R); //划分建立右区间 \tNOW_Node.val = node[NOW_LSon].val + node[NOW_RSon].val; //计算该区间信息 \t} } void modify(int index, const int \u0026amp;m_L, const int \u0026amp;m_R, const int \u0026amp;m_val) { if (m_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= m_R) NOW_Node.lazy += m_val; //当前区间完全在范围里，直接偷懒。 \telse { NOW_Node.val += (min(m_R, NOW_Node.R) - max(m_L, NOW_Node.L) + 1) * m_val; /* 这里是修改所包含区间的值 如要修改[4,9]，当前节点区间是(1,6)\t//这里为了区分用的小括号，实际上包含端点 则只会修改[4,6)，也就是val += (6 - 4 + 1) * 2 */ if (m_L \u0026lt;= NOW_Node.mid) modify(NOW_LSon, m_L, m_R, m_val); if (m_R \u0026gt; NOW_Node.mid) modify(NOW_RSon, m_L, m_R, m_val); } } long long query(int index, const int \u0026amp;q_L, const int \u0026amp;q_R) { if (NOW_Node.lazy) //注意查询的时候，只要有懒标记就必下放【别人都来查岗了你还摸鱼.jpg…… \tNOW_Node.pushdown(*this); if (q_L \u0026lt;= NOW_Node.L \u0026amp;\u0026amp; NOW_Node.R \u0026lt;= q_R) return NOW_Node.val; //当前区间直接在查询区间里，直接返回值//【我查了，一句返回了，有什么好说的……  //↓ 不完全包含于查询区间里，就要查询两子区间的值计算 \tlong long tmpAns = 0; if (q_L \u0026lt;= NOW_Node.mid) tmpAns += query(NOW_LSon, q_L, q_R); //如果要查询区间左端点，比当前区间的中点还大，证明左儿子区间完全不在 \tif (q_R \u0026gt; NOW_Node.mid) tmpAns += query(NOW_RSon, q_L, q_R); return tmpAns; } } Segment; //直接用个大的结构体，便于模板化。 int main() { int n, m, tmp, w, l, r, i; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%lld\u0026#34;, \u0026amp;arr[i]); Segment.build(tmp, 1, n); //Segment.test(1); \twhile (m--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w); if (w == 1) { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;l, \u0026amp;r, \u0026amp;i); Segment.modify(1, l, r, i); } else { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;l, \u0026amp;r); printf(\u0026#34;%lld\\n\u0026#34;, Segment.query(1, l, r)); } } } ","date":"2020-12-20T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-segment_tree/67957130_p0_hu2c7318d0e2072da042ef7a1c5115b73e_4170699_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-segment_tree/","title":"ACM学习笔记——线段树……"},{"content":"音乐播放器 采用的APlayer的外链播放器……\n默认会显示在文章顶部……\n如需用吸底模式，请在第一个参数输入-fixed: 1……\n当然要放我最喜欢的怪力熊的歌啦！……\n【虽然网易云上没有原曲qwq……不过这两首也超好听的！……\n","date":"2020-12-19T00:00:00Z","image":"https://blog.supersassw.com/p/test-player/84038692_p0_hu3b9cb195d3b981b9da74048e9a17f8de_395719_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-player/","title":"音乐播放器测试……"},{"content":"Shortcode Hugo的Shortcode的测试……\n新增了Bilibili的链接……\n 不知道是什么的原文x：\n Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n 详解 使用方法类似于Hexo当中的标签插件（Tag Plugins）\n有两种Shortcode的使用方法……\n  内嵌Shortcode\n{{\u0026lt; type content \u0026gt;}}   Shortcode块\n{{\u0026lt; type \u0026gt;}} content {{\u0026lt; \\type \u0026gt;}}    对于内容的解析也有两种方法：\n  内容解析为HTML\n{{\u0026lt; ... \u0026gt;}}   内容解析为Markdown\n{{% ... %}} 一般这个不常用，个人自写的所有Shotrcode都是基于\u0026lt;\u0026gt;来处理的……\n   功能测试 YouTube Privacy Enhanced Shortcode \r\r需要科学上网才能查看……\n Bilibili Simple Shortcode \r   使用方法：\n{{\u0026lt; bilibili BV1754y1R7Nd \u0026gt;}}   默认为BV号。\n 可选参数：  av = \u0026quot;...\u0026quot;：使用av号。\n使用例：{{\u0026lt; bilibli av=\u0026quot;10492\u0026quot; \u0026gt;}} hq = *：画质。0为低画质，1为高画质。（默认值为1） p = *：视频选集。（默认值为1） 如果使用参数，则使用方式只能为{{\u0026lt; bilibili bv=... p=1 hq=1 \u0026gt;}}\n\r    ","date":"2020-12-18T00:00:00Z","image":"https://blog.supersassw.com/p/test-shortcode/78356827_p0_huc21610886fa327c8e802235e20e8c4e7_690415_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/test-shortcode/","title":"Shortcode测试……"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 Photo by Florian Klauer on Unsplash Photo by Luca Bravo on Unsplash\nPhoto by Helena Hertz on Unsplash Photo by Hudai Gayiran on Unsplash\n![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-12-18T00:00:00Z","image":"https://blog.supersassw.com/p/test-chinese/Yande-331204_hu78842091091c5acfc10d1d28fbf3f867_2198432_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/test-chinese/","title":"页面测试……"},{"content":"该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误……\n\r 线性筛素数   用途：对一定范围$n$内的数，构造素数表。\n  注意点：ifNot_Prime数组范围为数据大小的范围，并不是个数。\n  #define MAX_N 100000000 + 5 bool IfNot_Prime[MAX_N]; //0---素数 1---不是素数 int Prime[MAX_N], PNum;\t//PNum：记录范围内有多少个素数  void Init(int N) { for (register int Top=2; Top\u0026lt;=N/2+1; Top++) { if (!IfNot_Prime[Top]) Prime[++PNum]=Top; for (register int C=1; C\u0026lt;=PNum \u0026amp;\u0026amp; Top*Prime[C] \u0026lt;= MAX; C++) { IfNot_Prime[Top*Prime[C]]=1; if (Top % Prime[C] == 0) break; } } }  解释：  Prime内存放$1\\sim n$内的所有素数。\nifNot_Prime内存放否以具体的数是否为素数。\n   快速幂 long long q_pow(long long base, long long idx)\t//base 底数、index 指数 { long long answer = 1; while (idx) { if (idx \u0026amp; 1) answer = answer * base % MOD; //带模的运算 \tbase = base * base % MOD; idx \u0026gt;\u0026gt;= 1; } return answer; } //使用例： { q_pow(3,12);\t//3^12 } 拓展——矩阵快速幂  用途：矩阵DP  //long long注意！…… #include \u0026lt;bits/stdc++.h\u0026gt;#define matrix_MAX 100 #define MOD 1000000007 using namespace std; struct typeMatrix { long long mat[matrix_MAX + 1][matrix_MAX + 1] = {}; int x, y;\t//x——行，y——列  typeMatrix(int x, int y) : x(x), y(y) {} inline typeMatrix operator*(const typeMatrix \u0026amp;a) const //矩阵乘法实现 \t{ typeMatrix res(x, a.y); for (int i = 1; i \u0026lt;= x; i++) //矩阵a(x1,y1);b(x2,y2)， \t//新矩阵为res(x1,y2)，做y1(或x2)次乘法累加 \tfor (int j = 1; j \u0026lt;= a.y; j++) for (int k = 1; k \u0026lt;= y; k++) res.mat[i][j] = (res.mat[i][j] + mat[i][k] * a.mat[k][j]) % MOD; //就矩阵乘法 \treturn res; } void initPowAns(int size) { for (int i = 1; i \u0026lt;= size; i++) mat[i][i] = 1; //注意标准快速幂中初始化为令ans=1，换成矩阵后初始化为令主对角线为1…… \t} inline typeMatrix operator^(long long power) const //快速幂实现 \t{ typeMatrix ans(y, y), base = *this; ans.initPowAns(y); while (power) { if (power \u0026amp; 1) ans = ans * base; base = base * base; power \u0026gt;\u0026gt;= 1; } return ans; } }; int main() { long long n,k; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;k); typeMatrix Matrix(n,n);\t//定义矩阵 \t/*读入矩阵*/ typeMatrix ans = Matrix ^ k; /*输出结果矩阵*/ } GCD\u0026amp;EXGCD LL gcd(LL a, LL b)\t//递归式gcd { return b ? gcd(b, b % a) : a; } LL gcd_iteration(LL a, LL b)\t//迭代式GCD { while (b ^= a ^= b ^= a %= b); return a; } LL Exgcd_iteration(LL a, LL b, LL \u0026amp;x, LL \u0026amp;y)\t//迭代式EXGCD { x = 1, y = 0; //初矩阵：1 0  int x1 = 0, y1 = 1; // 0 1  while (b) { int d = a / b; tie(x, x1) = make_tuple(x1, x - d * x1); //矩阵乘法  tie(y, y1) = make_tuple(y1, y - d * y1); tie(a, b) = make_tuple(b, a - d * b); //迭代gcd()  } return a; } 并查集 并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的合并及查询问题。\n 用途：  查找（Find）：确定某个元素处于哪个子集。 合并（Union）：将两个子集合并成一个集合。    struct typeUnionFind { int num, father[N], rank[N]; //这里rank作用是记录节点深度（真实为深度-1），采用了按秩合并的优化  void init(int n) { num=n; for (int i = 1; i \u0026lt;= num; i++) father[i] = i; } inline int find(int node)\t//查询操作  { return father[node] == node ? node : (father[node] = find(father[node])); //这里使用了路径压缩优化  } inline void merge(int node1, int node2)\t//合并操作  { int father1 = find(node1), father2 = find(node2); if (rank[father1] \u0026lt; rank[father2]) father[father1] = father2; else if (rank[father1] \u0026gt; rank[father2]) father[father2] = father1; else if (father1 != father2) father[father1] = father2, rank[father2]++; //如果深度一样且父节点不一样（不为一棵树），合并后新树深度会加一  } } UnionFind; //使用例： { //初始化 \tUnionFind.init(n); UnionFind.merge(1,2);\t//合并1，2这两个子集。 \tUnionFind.find(3);\t//查询3这个元素处于哪个子集。 } ST表 用于处理区间最值询问问题。\n#define MAX_N 100005 #define Work max //根据题目要求选择Work方式（最大还是最小）  int Log[MAX_N],\t//Log表 \tNum[MAX_N],\t//存放原本数据的数组 \tF[MAX_N][30], //ST表 \tn; void InitLog() //初始化Log数组 { Log[1] = 0, Log[2] = 1; for (int i = 3; i \u0026lt;= n; i++) Log[i] = Log[i / 2] + 1; } void Init() { InitLog(); for (int i = 1; i \u0026lt;= n; i++) F[i][0] = Num[i]; //刚开始f[n][0],即长度为1的序列中最小的就是它本身。 \t//2开始，log2=1;log3=1;log4=2;log5=2;log6=2;log7=2;log8=3; \tfor (int i = 2; i \u0026lt;= n; i++) { F[i][1] = Work(F[i][0], F[i - 1][0]);//这里特殊处理1，因为2^(1-1)=1,而2\u0026lt;\u0026lt;(1-1)=2 \tfor (int j = 2; j \u0026lt;= Log[i]; j++) F[i][j] = Work(F[i][j - 1], F[i - (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); } } int Find(int l, int r) { int k = Log[r - l + 1]; return Work(F[l + (1 \u0026lt;\u0026lt; k) - 1][k], F[r][k]); } //使用例 { //初始化：先读入数据个数n，数组。 \tInit(); cout \u0026lt;\u0026lt; Find(l, r); //输出[l,r]间的最值 } 线段树 直接放模板。\n#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100005; const int L = 0, R = 1; struct Message {\t//节点维护的信息 \tlong long sum, len, add, mul; //区间和 区间长度 区间lazy的加法 区间lazy的乘法 \t/* ans = ans*mul + add */ Message() { //初始化函数 \tsum = 0; add = 0; len = 0; mul = 1; } Message(long long xsum, long long xlen, long long xadd, long long xmul) { //初始化函数 \tsum = xsum; len = xlen; add = xadd; mul = xmul; } Message operator+(const Message \u0026amp;b) { //定义 a+b \tMessage p(sum + b.sum, len + b.len, 0, 1); return p; } /* (ans * mul + add) * famul + faadd */ void modify(Message fa) { //父亲的信息为fa ， 父亲pushdown下传 \tmul = mul * fa.mul; add = add * fa.mul + fa.add; sum = sum * fa.mul + fa.add; } }; struct SegmentTree { int l, r;\t//当前管理区间 [l,r] \tint son[2]; //左儿子为 son[0] 右儿子为 son[1] \tMessage x; } node[N * 2]; void pushdown(int k) { //下传标记 \tif (node[k].x.add != 0) { node[node[k].son[L]].x.modify(node[k].x); node[node[k].son[R]].x.modify(node[k].x); node[k].x.add = 0; } } void update(int k) { //更新节点k \tnode[k].x = node[node[k].son[L]].x + node[node[k].son[R]].x; } int root, ini[N], cnt; //cnt 当前已经有了多少个节点 //假设数组初始时为ini  void buildTree(int \u0026amp;k, int l, int r) { //初始化一个管理[l,r]的节点 ， 下标为k \tk = ++cnt; node[k].l = l; node[k].r = r; node[k].x.len = (r - l + 1); //初始化[l,r] //k = cnt+1; cnt++; \tif (l == r)//没有儿子了 \t{ node[k].x.sum = ini[l]; } else //我是爸爸 \t{ int mid = (node[k].l + node[k].r) / 2; //儿子的左右分界 \tbuildTree(node[k].son[L], l, mid);\t//调用完后 左右儿子下表就可以被储存 \tbuildTree(node[k].son[R], mid + 1, r); update(k); } } Message work(int k, int ql, int qr, Message y) { //修改 [ql,qr] 顺带查询[ql,qr] \tif (ql \u0026lt;= node[k].l \u0026amp;\u0026amp; node[k].r \u0026lt;= qr) { node[k].x.modify(y); return node[k].x; } else if (ql \u0026gt; node[k].r || qr \u0026lt; node[k].l) return 空; else { Message p; pushdown(k); p = work(node[k].son[L], ql, mid, y) + work(node[k].son[R], mid + 1, qr, y); update(k); return p; } } int n, m; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;ini[i]); buildTree(root, 1, n); Message ans; //区间[l,r] += val \tint l, r, val; Message y; y.add = val; work(root, l, r, y); //区间[l,r] *= val \tMessage y; y.mul = val; work(root, l, r, y); //查询区间[l,r] \ty.add = y.len = y.sum = 0; ans = work(root, l, r, y); cout \u0026lt;\u0026lt; ans.sum \u0026lt;\u0026lt; endl; } 逆序对 用归并排序。\n其中包含了对全排列的hash。\n#define MAX_LENGTH 5000000  long long inver[MAX_LENGTH];\t//记录每位的逆序对 template \u0026lt;typename T\u0026gt; long long sortMerge_inv(T *rawArray, int indexLeft, int indexRight) //求逆序对版 { vector\u0026lt;T\u0026gt; tmpArray; long long sum = 0; if (indexLeft == indexRight) return 0; int mid = (indexLeft + indexRight) \u0026gt;\u0026gt; 1, indexTmpArray = 0, indexLeftMerge = indexLeft, indexRightMerge = mid + 1; sum += sortMerge_inv(rawArray, indexLeft, mid); sum += sortMerge_inv(rawArray, mid + 1, indexRight); while (indexLeftMerge \u0026lt;= mid || indexRightMerge \u0026lt;= indexRight) { if (indexLeftMerge \u0026lt;= mid \u0026amp;\u0026amp; (rawArray[indexLeftMerge] \u0026lt;= rawArray[indexRightMerge] || indexRightMerge \u0026gt; indexRight)) tmpArray.push_back(rawArray[indexLeftMerge++]); else { tmpArray.push_back(rawArray[indexRightMerge++]), sum += mid - indexLeftMerge + 1; for (ALL(i, indexLeftMerge, mid)) //这里为注意点：为左部分的剩余所有数的逆序对个数++  inver[i]++; } } for (ALL(i, indexLeft, indexRight)) rawArray[i] = tmpArray[indexTmpArray++]; return sum; } int hash_index[10]; long long fact(int num) { long long ans = 1; for (ALL(i, 1, num)) ans *= i; return ans; } void hash_init(int len) { for (ALL(i, 1, len)) hash_index[i] = len - i; } template \u0026lt;typename T\u0026gt; //求全排列的Hash long long sortMerge_hash(T *rawArray, int indexLeft, int indexRight, const int \u0026amp;length) { if (indexLeft == indexRight) return 0; vector\u0026lt;T\u0026gt; tmpArray; vector\u0026lt;T\u0026gt; tmpFact; //用来swap后对位权的swap  long long hashArr = 0; int mid = (indexLeft + indexRight) \u0026gt;\u0026gt; 1, indexTmpArray = 0, indexLeftMerge = indexLeft, indexRightMerge = mid + 1; hashArr += sortMerge_hash(rawArray, indexLeft, mid, length); hashArr += sortMerge_hash(rawArray, mid + 1, indexRight, length); while (indexLeftMerge \u0026lt;= mid || indexRightMerge \u0026lt;= indexRight) { if (indexLeftMerge \u0026lt;= mid \u0026amp;\u0026amp; (rawArray[indexLeftMerge] \u0026lt;= rawArray[indexRightMerge] || indexRightMerge \u0026gt; indexRight)) tmpArray.push_back(rawArray[indexLeftMerge++]), tmpFact.push_back(hash_index[indexLeftMerge - 1]); else { tmpArray.push_back(rawArray[indexRightMerge++]), tmpFact.push_back(hash_index[indexRightMerge - 1]); for (ALL(i, indexLeftMerge, mid)) { hashArr += fact(hash_index[i]); //hash计算  } } } for (ALL(i, indexLeft, indexRight)) rawArray[i] = tmpArray[indexTmpArray++], hash_index[i] = tmpFact[indexTmpArray - 1]; //补了交换权重【这样可以准确算出每一位的逆序对  return hashArr; } //使用例 int arr[MAX_LENGTH], arr_hash[MAX_LENGTH]; { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (ALL(i, 1, n)) scanf(\u0026#34;%d\u0026#34;, \u0026amp;arr[i]), arr_hash[i] = arr[i]; printf(\u0026#34;Each inversion:\\n\u0026#34;); //输出每一位的逆序对个数  cout \u0026lt;\u0026lt; setw(7) \u0026lt;\u0026lt; \u0026#34;---Top:\u0026#34;; for (ALL(i, 1, n)) cout \u0026lt;\u0026lt; setw(7) \u0026lt;\u0026lt; i; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; setw(7) \u0026lt;\u0026lt; \u0026#34;---Num:\u0026#34;; for (ALL(i, 1, n)) cout \u0026lt;\u0026lt; setw(7) \u0026lt;\u0026lt; arr[i]; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; setw(7) \u0026lt;\u0026lt; \u0026#34;\u0026#34;; for (ALL(i, 1, n)) cout \u0026lt;\u0026lt; setw(8) \u0026lt;\u0026lt; \u0026#34;↓\u0026#34;; cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; setw(7) \u0026lt;\u0026lt; \u0026#34;---CNT:\u0026#34;; long long inverSum = sortMerge_inv(arr, 1, n); for (ALL(i, 1, n)) cout \u0026lt;\u0026lt; setw(7) \u0026lt;\u0026lt; inver[i]; printf(\u0026#34;\\nInversions conut: %lld\\n\u0026#34;, inverSum); //输出逆序对和  hash_init(n); printf(\u0026#34;Hash: %lld\\n\u0026#34;, sortMerge_hash(arr_hash, 1, n, n)); //输出全排列hash值  printf(\u0026#34;Sort: \u0026#34;); //输出归并排序后结果。  for (ALL(i, 1, n)) printf(\u0026#34;%d \u0026#34;, arr[i]); } 单调队列 用来求一定范围内的最值。\n典型例题为“滑动窗口”\n 给出一个长度为$n$的数组，输出每$k$个连续的数中的最大值和最小值。\n  其中的单调为一种思想：  当我们解决问题的时候发现有许多冗杂无用的状态时，我们可以采用单调思想，用单调队列或类似于单调队列的方法去除冗杂状态，保存我们想要的状态，\n   struct Node { int Value, Top; } Line[1000005];\t//单调队列  int Line_N[1000005], //原数据 \tans[1000005],\t//最终得到的最值，答案数组 \tNum,\t//数据个数 \tLength;\t//窗口长度  void Push(int Top, int Num, int Tail) //入队操作 { Line[Tail].Top = Top; Line[Tail].Value = Num; } void Find_Min() //寻找最小值 { int Head = 1, Tail = 0; for (int i = 1; i \u0026lt; Length; i++) //这里前m-1个先直接进入队列，因为不用记录前m-1个的最值，只有第m个才能找出最值 \t//【假如窗长3，相当于第3个找第1个到第3个内的，第4个找第2个到第4个内的，所以把前2个push进队，从第三个开始找 \t{ while (Head \u0026lt;= Tail \u0026amp;\u0026amp; Line_N[i] \u0026lt;= Line[Tail].Value) Tail--; //维护序列单调，如入队的数小于尾，破坏了单调递增，tail--把尾pop出去，直到大于等于队尾呈递增或者队列空 \tPush(i, Line_N[i], ++Tail); //然后入队 \t} for (int i = Length; i \u0026lt;= Num; i++) { while (Head \u0026lt;= Tail \u0026amp;\u0026amp; Line_N[i] \u0026lt;= Line[Tail].Value) Tail--; Push(i, Line_N[i], ++Tail); //同上道理，首先，要维护单调性，然后push \tif (Line[Head].Top \u0026lt; i - Length + 1) Head++;\t//判断出窗没有 \tans[i - Length + 1] = Line[Head].Value; //这个时候第i个窗的最值为队首 \t} } //最大值只用将有关数据比较的小于等于改为大于等于即可 //使用例 { for (ALL(i,1,Num-Length+1)) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;;\t//直接从头到尾输出答案数组。 } 最小生成树 求出联通整个图所需要的最小边权。\n一定会选择$n-1$条边。\n典型例题为：\n 我们要在n个城市中建立一个通信网络，则连通这n个城市需要布置n-1一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？\n Kruskal 该算法的基本思想是从小到大加入边，是个贪心算法。\n  过程：\n 按照边权进行排序 寻找最小边，如果加入后不会形成环，则选择此边。 重复，直到所有点联通（选择$n-1$条边）。    算法点：\n 并查集（用于判断加入后是否为环） 贪心（排序） 图的存储    用途：\n 最小生成树 判断整个图是否联通。    #define N 200005  int n, m, f[N],\t//并查集数组 \tans,\t//最小边权和 \tbs;\t//当前连了几条边 bool pd = 0; //是否联通，联通为1 struct Edge\t//储存方式：按边存 { int u, v, w; } e[N]; int find(int x) //并查集查找 { if (f[x] == x) return x; return f[x] = find(f[x]); } bool cmp(Edge x, Edge y) //按权值排序 { return x.w \u0026lt; y.w; } //初始化 { for (register int i = 1; i \u0026lt;= n; i++) //并查集初始化 \tf[i] = i; sort(e, e + m, cmp);\t//对边排序 } //Kruskal算法实现 int main() { for (register int i = 0; i \u0026lt; m; i++) { int fv = find(e[i].v), fu = find(e[i].u); //我们取出当前边的起点和终点所在的祖先 \tif (fv == fu) continue; //如果它们相同，就说明它们联通，那么就不用加这条边了 \tf[fv] = fu;\t//把祖先存进去 \tans += e[i].w; //总答案+=这条边的权值 \tif (++bs == n - 1) {\t//连通n个点需要n-1条边 \tpd = 1; //判断是否连通的东西 \tbreak; } } if (!pd) cout \u0026lt;\u0026lt; \u0026#34;orz\u0026#34;; //如果不连通就输出（这题好像没有这个数据 \telse cout \u0026lt;\u0026lt; ans; } 最短路 Dijkstra   过程： 0. 初始化：将所有距离设为$\\inf$，然后把起点设为0，并加入小根堆。\n 对那些刚刚被加入第一个集合的结点的所有出边执行松弛操作。 从第二个集合中，选取一个最短路长度最小的结点，移到第一个集合中。 重复：直到第二个集合为空，算法结束。    注意点：没有负权。\n  const int MaxN = 100010, MaxM = 500010; struct edge //存储方式——邻接表 { int to, dis, next; } e[MaxM]; int head[MaxN]; //邻接表的头指针  int dis[MaxN], cnt; bool vis[MaxN]; int n, m, s; inline void add_edge(int u, int v, int d) { cnt++; e[cnt].dis = d; e[cnt].to = v; e[cnt].next = head[u]; head[u] = cnt; } struct node { int dis; int pos; bool operator\u0026lt;(const node \u0026amp;x) const { return x.dis \u0026lt; dis; } }; std::priority_queue\u0026lt;node\u0026gt; q; inline void dijkstra() { dis[s] = 0; q.push((node){0, s});\t//初始化2——起点 \twhile (!q.empty()) { node tmp = q.top(); q.pop(); int x = tmp.pos, d = tmp.dis; if (vis[x]) continue; vis[x] = 1;\t//要取出来后，才证明这个是最小dis，才更改vis \tfor (int i = head[x]; i; i = e[i].next)\t//对所有边松弛 \t{ int y = e[i].to; if (dis[y] \u0026gt; dis[x] + e[i].dis)\t//松弛操作 \t{ dis[y] = dis[x] + e[i].dis; if (!vis[y])\t//没被确定，入堆 \tq.push((node){dis[y], y}); } } } } int main() { scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;s); for (int i = 1; i \u0026lt;= n; ++i) dis[i] = 0x7fffffff; //初始化 \tfor (register int i = 0; i \u0026lt; m; ++i)\t//读边 \t{ register int u, v, d; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;d); add_edge(u, v, d); } dijkstra(); for (int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, dis[i]); } 拓扑排序   思想：\n 选择一个入度为0的顶点输出 从AOV网删除这个节点，并且将所有与这节点有关的节点入度-1 重复以上两步，直到不存在入度为0的 如果输出数少于节点数，即实际上还有节点没输出出来，因此肯定是此图有回路，否则拓扑排序成功    用途：\n 按照“在走到一个节点之前，必须把所有能走到它的节点走到”这种条件，对图排序。（类似于要先学前置知识） 判断是否有环。    int In[105],\t//In记录所有节点的入度， \tOut[105][105],\t//存储方式——邻接表。 \t//Out记录一个节点能走到的节点 \t//特别的Out[i][0]为i节点能走到节点的个数（出度） \tLine[105];\t//Line存排序结果  void Push(int Top, int \u0026amp;Tail) //入Line队列 { Line[++Tail] = Top; } void Pop_Push(int Top, int \u0026amp;Head, int \u0026amp;Tail) { cout \u0026lt;\u0026lt; Line[Top] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t//先输出这个节点 \tHead++;\t//删除这个节点，即出队 \tfor (int i = 1; i \u0026lt;= Out[Line[Top]][0]; i++) //把它所有能走到的节点的入度-- \t{ In[Out[Line[Top]][i]]--; if (!In[Out[Line[Top]][i]]) Push(Out[Line[Top]][i], Tail); //这个时候判断是否为0，如果为0即push入队列里 \t} } void Topo(int Many) //拓扑 //如果要判断是否有环，即看tail是否小于many即可 { int Head = 1, Tail = 0; for (int i = 1; i \u0026lt;= Many; i++) //刚开始从头到尾遍历一遍，如果入度为0，push到专门存入度为0的Line队列里 \tif (!In[i]) Push(i, Tail); while (Head \u0026lt;= Tail) Pop_Push(Head, Head, Tail); //开始排序 } int main() { int Many, T; cin \u0026gt;\u0026gt; Many;\t//有多少个节点 \tfor (int i = 1; i \u0026lt;= Many; i++) { cin \u0026gt;\u0026gt; T;\t//开始读入每个节点的边 \twhile (T) { Out[i][++Out[i][0]] = T; //记录能走到的节点 \tIn[T]++;\t//能走到的节点的入度++ \tcin \u0026gt;\u0026gt; T; } } Topo(Many); } /* 读入： 5 0 4 5 1 0 1 0 5 3 0 3 0 */ /* 输出： 2 4 5 3 1 */ KMP 用于“字符串匹配”问题。\n 什么是字符串的模式匹配？  给定两个字符串$S=“s_1,s_2,s_3,\\cdots,s_n”$和$T=“t_1,t_2,t_3,\\cdots,t_m\u0026quot;(m \\le t)$，\n在主串S中寻找子串T的过程叫做模式匹配，T称为模式。\n   #include \u0026lt;bits/stdc++.h\u0026gt;#define MAX 2000000 using namespace std; char s[MAX], f[MAX]; int Next[MAX]; int main() { scanf(\u0026#34;%s%s\u0026#34;, s, f); int lens = strlen(s), lenf = strlen(f), k = 0; for (int i = 1; i \u0026lt; lenf; i++) { while (k \u0026amp;\u0026amp; f[i] != f[k]) k = Next[k]; Next[i + 1] = f[i] == f[k] ? ++k : 0; } k = 0; for (int i = 0; i \u0026lt; lens; i++) { while (k \u0026amp;\u0026amp; s[i] != f[k]) k = Next[k]; k += s[i] == f[k] ? 1 : 0; if (k == lenf) printf(\u0026#34;%d\\n\u0026#34;, i - lenf + 2);\t//输出子串t在主串s中出现的位置 \t} for (int i = 1; i \u0026lt;= lenf; i++) printf(\u0026#34;%d \u0026#34;, Next[i]); } /* 输入： ABABABC ABA */ /* 输出： 1 3 0 0 1 */ //前面n-1行代表出现的不同位置 //最后一行代表字串t不同长度的border[i]  border[i] 记为$\\pi(i)$，代表：字符串$t$最长的“相等的真前缀与真后缀”的长度。\n特别地，规定 $\\pi[0]=0$ 。   举例来说，对于字符串 abcabcd ，\n$\\pi[0]=0$ ，因为 a 没有真前缀和真后缀，根据规定为$0$\n$\\pi[1]=0$ ，因为 ab 无相等的真前缀和真后缀\n$\\pi[2]=0$ ，因为 abc 无相等的真前缀和真后缀\n$\\pi[3]=1$ ，因为 abca 只有一对相等的真前缀和真后缀：a，长度为$1$\n$\\pi[4]=2$ ，因为 abcab 相等的真前缀和真后缀只有ab，长度为$2$\n$\\pi[5]=3$ ，因为 abcabc 相等的真前缀和真后缀只有abc，长度为$3$\n$\\pi[6]=0$ ，因为 abcabcd 无相等的真前缀和真后缀\n同理可以计算字符串 aabaaab 的前缀函数为 $[0, 1, 0, 1, 2, 2, 3]$ 。\n Manacher 用于求回文串的算法。\n 给出一个只由小写英文字符$\\texttt a,\\texttt b,\\texttt c,\\ldots\\texttt y,\\texttt z$组成的字符串$S$,求$S$中最长回文串的长度。\n字符串长度为$n$。\n #include \u0026lt;bits/stdc++.h\u0026gt;#define N 50000000 #define MaxLen Right - i #define Mirror 2 * Mid - i using namespace std; char s[N \u0026lt;\u0026lt; 1]; int RL[N \u0026lt;\u0026lt; 1]; void Read()\t//对读入的预处理——加入#来分割 { int i = 1; s[0] = \u0026#39;~\u0026#39;, s[1] = \u0026#39;#\u0026#39;; while ((s[++i] = getchar()) != EOF) s[++i] = \u0026#39;#\u0026#39;; } int Manacher() { int Mid = 2, Right = 3, len = strlen(s) - 3, ans = 0; RL[1] = 1, RL[2] = 2; for (int i = 3; i \u0026lt;= len; i++) { if (i \u0026lt; Right) RL[i] = min(MaxLen, RL[Mirror]); else RL[i] = s[i] == \u0026#39;#\u0026#39; ? 1 : 2; while (s[i - RL[i]] == s[i + RL[i]]) RL[i]++; if (Right \u0026lt; i + RL[i] - 1) Right = i + RL[i] - 1, Mid = i; ans = RL[i] - 1 \u0026gt; ans ? RL[i] - 1 : ans; } return ans; } int main() { Read(); cout \u0026lt;\u0026lt; Manacher(); } 字典树——Trie 用于：查找一个字符串是否在“字典”中出现过。\n找的封装好的模板。\nstruct trie { int nex[100000][26], cnt; bool exist[100000]; // 该结点结尾的字符串是否存在  void insert(char *s, int l) // 插入字符串 \t{ int p = 0; for (int i = 0; i \u0026lt; l; i++) { int c = s[i] - \u0026#39;a\u0026#39;; if (!nex[p][c]) nex[p][c] = ++cnt; // 如果没有，就添加结点 \tp = nex[p][c]; } exist[p] = 1; } bool find(char *s, int l) // 查找字符串 \t{ int p = 0; for (int i = 0; i \u0026lt; l; i++) { int c = s[i] - \u0026#39;a\u0026#39;; if (!nex[p][c]) return 0; p = nex[p][c]; } return exist[p]; } }; 其他 快速读入 inline int intRead() { int f=1,num=0; char t=getchar(); while (t\u0026lt;\u0026#39;0\u0026#39; || t\u0026gt;\u0026#39;9\u0026#39;) if (t==\u0026#39;-\u0026#39;) f=-1,t=getchar(); else t=getchar(); while (t\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; t\u0026lt;=\u0026#39;9\u0026#39;) num=num*10+t-\u0026#39;0\u0026#39;,t=getchar(); return f*num; } 宏 #define ALL(NAME_i, BEGIN, TO) \\ int NAME_i = BEGIN; \\ NAME_i \u0026lt;= TO; \\ NAME_i++  #ifdef SuperSASS freopen(\u0026#34;data.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif ","date":"2020-12-17T00:00:00Z","image":"https://blog.supersassw.com/p/acm-template/56669571_p0_hu2d9efed420e5413c9e9ff3384c8a765c_856728_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-template/","title":"ACM学习笔记 - 总模板……"},{"content":"该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误……\n\r 邻项比较排序介绍 定义 本来的排序型贪心，我们需要任意两个项都满足决策条件。\n但我们发现，如果数列每对相邻两项都满足决策条件，根据不等式的传递性，那么也就可以推出任意两项满足决策条件。\n于是我们分析决策条件时，就不用分析任意两项，可以就分析邻项然后推出决策条件。\n【主要用于如果决策条件复合了其他数据（比如：结果计算为$\\sum_{i=1}^na_i$，复合之前的数列），这样分析可以减少分析难度】\n  典型例题：\nP1080 国王游戏\n 可以见到这题便有一个「排在该大臣前面的所有人的左手上的数的乘积」这句话，\n如果我们分析任意两项的话，还要考虑两者中间的数据。\n所以我们可以指通过分析相邻两项，然后通过传递性，推及任意两项都满足。\n 【其实用任意两项分析也完全可以，而且分析也不难_(:з」∠)_……\n  那么实现的关键就是找到最终的决策方案（序列满足的条件），然后根据这个决策sort就行了_(:з」∠)_……\n【但是会有注意点后面会讲到……\n题目解决方法 引例  以下以此例题为例具体讲解：\nSWJTU OJ——10.31 A 排队\n 题目与国王游戏类似，用邻项交换排序的思想来找决策条件。\n1、找出每种状态的ans，选邻项代入  题目描述：\n也就是说，请重新给班尼特排队，要求是最大化$\\min_{i=1}^n{-h_i+\\sum_{j=1}^i v_j}$。\n 那么每种状态的ans$=\\min_{i=1}^nw_i$。\n既然要求$\\min_{i=1}^n{w_i}$，所以我们就比较邻项的$w_i,w_j$，比较其两项的$\\min(w_i,w_j)$，选择最大ans的状态。\n 为什么我们这样排序，能使ans$=\\min_{i=1}^nw_i$取得最小？  就相当于把比较时候的最小值看成短板，每次比较一次选最高的那个，就会把短板提上去一点。\n这样最后得到的就是最高的短板，也就是最大的$\\min$……\n   2、假设相邻位置，写出两种状态的ans 我们首先要把每个位置的收益表达式写出来：\n 题目描述：治疗第$i$个班尼特的收益$w_i$等于前面治疗的所有班尼特的$v$之和减去$h_i$。 $$ w_i=\\sum_{j=1}^iv_j-h_i $$\n 那么我们假设两个相邻位置$i,j$。其中$i$在$j$前，即$i=j-1$。【必须先假设一个在另一个前后，否则不可能$i$在$j$前满足，$j$在$i$前也满足】\n记：两者之前的$\\sum v$为$sum$。【将一些求$w$要用到的比如$\\sum$记为其他符号表示，可以简化式子】\n然后分别讨论$i$在$j$前和$j$在$i$前的情况：\n  原本状态：$i$在$j$前\n $$ \\begin{matrix} h \u0026amp; v \\\\ \\vdots \u0026amp; \\vdots(sum) \\\\ h_i \u0026amp; v_i \\\\ h_j \u0026amp; v_j \\\\ \\vdots \u0026amp; \\vdots \\end{matrix} $$\n 对$i$的收益：$w_{i1}=sum+v_i-h_i$\n对$j$的收益：$w_{j1}=sum+v_i+v_j-h_j$\n此状态的ans=$\\min(w_{i1},w_{j1})$\n  如果交换：$j$在$i$前\n $$ \\begin{matrix} h \u0026amp; v \\\\ \\vdots \u0026amp; \\vdots(sum) \\\\ h_j \u0026amp; v_j \\\\ h_i \u0026amp; v_i \\\\ \\vdots \u0026amp; \\vdots \\end{matrix} $$\n 对$i$的收益：$w_{i2}=sum+v_j+v_i-h_i$，\n对$j$的收益：$w_{j2}=sum+v_j-h_j$\n此状态的ans=$\\min(w_{i2},w_{j2})$\n  3、根据题意写出排序条件并化简，得到最终决策方案  题目描述：芭芭拉想让治疗每个班尼特收益的最小值最大。\n 题意要求使最小收益最大化，\n则最初排序条件为：$\\min(w_{i1},w_{j1})\\ge\\min(w_{j2},w_{i2})$\n【或者说**交换条件**为：$\\text{if} \\quad (\\min(w_{i1},w_{j1})\u0026lt;\\min(w_{j2},w_{i2})) \\quad \\text{swap}(i,j)$】\n *其他例子：国王游戏中，是使最大收益最小化。则排序条件为：$\\max(w_{i1},w_{j1})\\le\\max(w_{i2},w_{j2})$*\n 然后对这个决策条件化简，使得能直接表达出来。\n【所谓不能直接表达的，便是条件中含有如$\\sum$之类的运算。而我们不可能用循环专门去求，只能通过化简把他消掉】\n 化简方法：\n下列所提到的化简方法参考含max、min的不等式。\n  利用“完全展开法则”，观察是否含有恒成立或恒不成立。\n【或者直接观察题目中$w_{i1},w_{j1},w_{j2},w_{i2}$间的关系，找出恒成立或恒不成立，然后利用“**消元法则**”】\n  利用排序规则下特殊的“相同无关原则”，结合“取反性、结合性”等性质，化简并得到最终的最简决策\n   则本题中：\n展开为$\\text{if} \\quad ((w_{i1}\u0026lt;w_{i2} \\quad and \\quad w_{i1}\u0026lt;w_{j2}) \\quad or \\quad (w_{j1}\u0026lt;w_{i2} \\quad and \\quad w_{j1}\u0026lt;w_{j2})) \\quad \\text{swap}$。\n 发现$w_{i1}\u0026lt;w_{i2}$恒成立：  $\\sout{sum+v_i-h_i} \\quad?\\quad \\sout{sum}+v_j\\sout{+v_i-h_i}$\n$\\implies 0\u0026lt;v_j$\n  发现$w_{j1}\u0026lt;w_{j2}$恒不成立：  $\\sout{sum}+v_i\\sout{+v_j-h_j} \\quad?\\quad \\sout{sum+v_j-h_j}$\n$\\implies v_i\u0026gt;0$\n   故原式可简化为：\n$\\text{if} \\quad (w_{i1}\u0026lt;w_{j2}) \\quad \\text{swap}$\n$\\implies \\text{if} \\quad (v_i-h_i \u0026lt; v_j-h_j) \\quad \\text{swap}$\n这便是化简后的决策条件。\n 注意的点：\n不一定要化到最简，只要能在代码里直接表达就行。\n 本题中原始条件经过部分化简：\n运行结果：\n而完全化简后为：\n运行结果：\n可见差异并不大，所以说只要能化简到能表达的地步就可以。\n当然如果能化到最简更好，肯定还是比带min的条件快的。\n \r 4、自定义结构体，重载\u0026lt;运算符，使用sort，遍历寻答案 这一步就不多说了，重载的时候按自己分析到的最终最简决策重载就行。\n但重点是：\n这样排序出来后只是最优状态，\n至于最终答案ans要从头到尾遍历寻找，即不一定是第一个为最终答案。\n可能后面计算结果不是递增或递减，则最终答案不是第一个。【具体题目具体分析】\n\r  标程代码 #include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int N = 100010; struct Data { int h, v; bool operator\u0026lt;(const Data \u0026amp;t) { return v - h \u0026gt; t.v - t.h; } //以推出的最终最简决策重载\u0026lt;运算符 } d[N]; int main() { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;d[i].h, \u0026amp;d[i].v); sort(d + 1, d + n + 1); //就一个sort  int tmp = 0, res = 1e9; for (int i = 1; i \u0026lt;= n; ++i) { tmp += d[i].v; res = min(res, tmp - d[i].h); //从头到尾遍历，res记录最终答案 \t} printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } 使用注意事项 注意之前我们定义中存在一个推论：\n 如果数列每对相邻两项都满足决策条件，根据不等式的传递性，那么也就可以推出任意两项满足决策条件。\n 所以假如我们所推的某个决策条件，不满足不等式的传递性，那么用这个方法就会造成错误。\n而这种必须要满足不等性的传递性，有个专门术语叫做“严格弱序”。\n先前知识——严格弱序   $X \\not\u0026lt; X$（比较条件非自反性）\n意思是：$X$与$X$本身，不满足比较条件。  反例：比较条件是$a_i \\ge a_j$。\n那么$X(a_i) \\ge X(a_i)$满足比较条件，为$X \u0026lt; X$，故不是严格弱序。   若$X \u0026lt; Y$，则$Y \\not\u0026lt; X$（比较条件非对称性）\n意思是：$X$和$Y$比较若满足比较条件，则$Y$和$X$比较不会满足条件。  反例：比较条件是$a_i \\ge a_j$。\n那么若$a_i=a_j$，$X(a_i) \\ge Y(a_j)$满足条件，\n但$Y(a_j) \\ge X(a_i)$也满足条件，故不是严格弱序。   若$X \u0026lt; Y,Y \u0026lt; Z$，则$X \u0026lt; Z$（比较条件不等传递性）\n意思是：$X$和$Y$满足比较条件，$Y$和$Z$满足比较条件，则$X$和$Y$满足比较条件。   反例：比较条件是$\\min(a_i,b_j) \\le \\min(a_j,b_i)$。\n那么对于下组数据：\n    $a$ $b$     $i$ $2$ $1$   $j$ $1$ $1$   $k$ $1$ $2$    $X(\\min(a_i,b_j)=1)\u0026lt;Y(\\min(a_j,b_i)=1)$\n$Y(\\min(a_j,b_k)=1)\u0026lt;Z(\\min(a_k,b_j)=1)$\n但$X(\\min(a_i,b_k)=2) \\not\u0026lt; Z(\\min(a_k,b_i)=1)$，故不是严格弱序。 【再次提示这里的$\u0026lt;$并不代表小于，而是代表符合比较条件的意思。】\n   若$X=Y,Y=Z$，则$X=Z$（比较条件相等传递性）\n意思同上。\n在“ouuan”dalao的讲解种写的是$x\\not\u0026lt;y,y\\not\u0026lt;x,y\\not\u0026lt;z,z\\not\u0026lt;y$（不可比性的传递性）。我改成这样更好理解。\n不过注意判断相等的方法是$x\\not\u0026lt;y,y\\not\u0026lt;x$这么判断的。  反例见下引例的「错误分析」      这里的$X$、$Y$、$Z$代表的是取某下标$i$、$j$后的决策条件的一侧元素。并不一定是某一具体数据。 这里的$\u0026lt;$并不代表小于的意思，而是代表满足比较条件，那么$\\not\u0026lt;$则代表不满足比较条件。  引例  P2123 皇后游戏\n 按照之前的方法尝试解决   找出每种状态的ans，选邻项代入\n 题目描述：\n她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。\n 可知每种状态的ans$=\\max_{i=1}^nw_i$。\n那么比较邻项$i,j$，就是$max(w_i,w_j)$。\n  假设相邻位置，写出两种状态的ans\n首先先写收益表达式：\n$$ w_i=\\max(w_{i-1},\\sum_{j=1}^ia_j)+b_i $$ 【第一位的收益可以合并到这个表达式里，令$w_0=0$就可以了。】\n假设相邻位置$i,j$。其中$i$在$j$前，即$i=j-1$。\n记：之前的$\\sum a$为$sum$，前一项的$c_{i-1}$为$pre_w$。\n会发现，由于$a,b\u0026gt;0$，整个收益表达式中又没出现会使收益变少的运算，故收益单增。\n即在后面的大臣的收益一定大于在前面的。\n$i$在$j$前时，则$w_j$一定大于$w_i$，所以$\\max(w_i,w_j)=w_j$，可以拆开一层$\\max$。\n  原本状态：$i$在$j$前\n $$ \\begin{matrix} a \u0026amp; b \u0026amp; c \\\\ \\vdots(sum) \u0026amp; \\vdots \u0026amp; \\vdots(pre_w) \\\\ a_i \u0026amp; b_i \u0026amp; w_{i1} \\\\ a_j \u0026amp; b_j \u0026amp; w_{j1} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\end{matrix} $$\n $w_{i1}=\\max(pre_w,sum+a_i)+b_i$\n$w_{j1}=\\max(w_{i1},sum+a_i+a_j)+b_j$\n此状态的ans=$\\max(w_{i1},w_{j1})=w_{j1}$\n  如果交换：$j$在$i$前\n $$ \\begin{matrix} a \u0026amp; b \u0026amp; c \\\\ \\vdots(sum) \u0026amp; \\vdots \u0026amp; \\vdots(pre_w) \\\\ a_j \u0026amp; b_j \u0026amp; w_{j2} \\\\ a_i \u0026amp; b_i \u0026amp; w_{i2} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \\end{matrix} $$\n $w_{i2}=\\max(w_{j2},sum+a_j+a_i)+b_i$\n$w_{j2}=\\max(pre_w,sum+a_j)+b_j$\n此状态的ans=$\\max(w_{i2},w_{j2})=w_{i2}$\n    根据题意写出排序条件并化简，得到最终决策方案\n题意要求使最大收益最小化，\n则排序条件：$\\max(w_{i1},w_{j1}) \\le \\max(w_{i2},w_{j2})$\n开始化简：\n$\\max(w_{i1},w_{j1}) \\le \\max(w_{i2},w_{j2})$\n$\\implies w_{j1} \\le w_{j2}$\n$\\implies \\max(\\sout{pre_w+b_i+b_j},\\underline{sum+a_i}+b_i+\\underline{b_j},\\underline{sum+a_i}+a_j+\\underline{b_j}) \\le \\max(\\sout{pre_w+b_j+b_i},\\underline{sum+a_j}+b_j+\\underline{b_i},\\underline{sum+a_j}+a_i+\\underline{b_i})$\n【删除线的部分代表根据相同无关原则可以消去；下划线的部分代表根据结合性可以提出来】\n$\\implies \\max(b_i,a_j)+sum+a_i+b_j \\le \\max(b_j,a+i)+sum+a_j+b_i$\n$\\implies \\max(b_i,a_j)-a_j-b_i \\le \\max(b_j,a_i)-a_i-b_j$\n$\\implies \\max(-a_j,-b_i) \\le \\max(-a_i,-b_j)$\n$\\implies -\\min(a_j,b_i) \\le -\\min(a_i,b_j)$\n$\\implies \\min(a_j,b_i) \u0026gt; \\min(a_i,b_j)$\n最终的决策条件：$\\min(a_j,b_i) \u0026gt; \\min(a_i,b_j)$\n  那就开写呗……\n  然后交上去会WA，80分。\n证明我们这种方法有思路缺陷。\n错误分析 这里便不满足严格弱序的相等传递性这个性质。\n 当取$i,j$时，若$\\min(a_i,b_j)=\\min(a_j,b_i)$，\n当取$j,k$时，若$\\min(a_j,b_k)=\\min(a_k,b_j)$，\n则需要满足：取$i,k$时，$\\min(a_i,b_k)=\\min(a_k,b_i)$\n 反例：\n    $a$ $b$     $i$ $3$ $5$   $j$ $1$ $1$   $k$ $7$ $2$    虽然$\\min(a_i,b_j)=\\min(a_j,b_i)$和$\\min(a_j,b_k)=\\min(a_k,b_j)$都满足，\n但却不满足$\\min(a_i,b_k)=\\min(a_k,b_i)$。\n【只需要让$a_j,b_j$相等，就可以构建众多反例。】\n错误根本原因（新内容！）  为什么不满足严格弱序中传递性就会造成错误：  因为sort实现时，采用了分治的思想。\n会将数据分为两个部分，对两个部分进行排序，然后使数列直接有序。\n但问题就刚好出在这个“直接有序”上。\n之所以在左右都有序后，会认为整个数列直接有序，\n就是因为利用了严格弱序中的传递性：\n认为$X \u0026lt; Y,Y \u0026lt; Z$，则$X \u0026lt; Z$，\n以及$X = Y,Y = Z$，则$X = Z$。\n但假如不满足的第一条的话，分治处理过后：\n左侧的数是小于中间的，中间的数也是小于右边的，但左侧的是却不一定小于右边的了。\n会造成很严重的合并后错误。\n但假如不满足的第二条的话，分治处理过后：\n如果都是小于条件，根据第一条可推合并后也有序，没有问题。 这也就是为什么我们这个方法还能得部分分的原因——决策判断时没判断出相等。\n\r\n但一旦出现等于条件的情况，则不能推得左边的也等于右边的，\n同时$X=Y, Y\u0026lt;Z \\implies X\u0026lt;Z$、$X\u0026lt;Y, Y=Z \\implies X\u0026lt;Z$也无法推得。\n 举例：判断条件为$\\min(a_i,b_j) \u0026lt; \\min(a_j,b_i)$【就本题我们推的条件…… 对以下两组数据：\n    $a$ $b$     $i$ $1$ $1$   $j$ $1$ $2$   $k$ $2$ $2$    其中$X(i,j)=Y(j,i),Y(j,k)\u0026lt;Z(k,j)$，但$X(i,k) \\not\u0026lt; Z(k,i)$，为$X=Z$。\n    $a$ $b$     $i$ $1$ $2$   $j$ $2$ $1$   $k$ $1$ $1$    其中$X(i,j)\u0026lt;Y(j,i),Y(j,k)=Z(k,j)$，但$X(i,k) \\not\u0026lt; Z(k,i)$，为$X=Z$。\n 那么不满足传递性，就会导致虽然序列大部分满足决策条件，但并不是任意两项都满足条件的。\n而回到我们贪心的基本要求：需要任意两个元素都满足决策条件。\n故会造成错误。\n   改进方法 其实上述主要问题都归结于我们对相等状况的定义模棱两可。\n 对于满足严格弱序中的传递性的数据来说：\n出现相等状况，交换或者不交换都无所谓，因为可以通过传递性证得交换后对数列无影响。\n所以可以保持这种模棱两可的定义。  也就是说这种数据，我们即使将判断中的不取等判断改为取等的判断，也依旧不会有影响。只不过会多交换几次，让状态变得不同，但最终结果一致。\n  对于不满足严格弱序中的传递性的数据来说：\n我们就必须对相等状况作出严格的操作规定了，否则两种不同的状态会导致数据最终结果的不一致。\n也就是说我们要对相等状况进行特判。  那么我们就来考虑在$\\max(w_{i1},w_{j1}) = \\max(w_{i2},w_{j2})$的相等条件下，又该加什么判断。\n也就是说，除了这个很显然的条件在影响ans外，还有没有什么可能影响ans。\n根据个人看法不同，会有很多种可能的条件，以下列举两种正确的：\n  会发现：$a$的前缀和会影响$\\max(c_{i-1},\\sum_{j=1}^ia_j)$这个的选择，从而影响$w_i$，从而影响ans。\n因为要找最小的ans，所以我们**把$a$更小的放在前面**，这样就能让更加保证所得状态是最优的了。\n  会发现：两种状态的前后两项$w$，后者是一样的【我们比较条件就是用的两状态的后者】，因此我们要让前者尽量小，从而确保ans更小。\n所以我们把$b$更小的放在前面。\n   那么假如这两个条件判断出来也是相等的，需不需要再特判呢？  假如$\\min(a_j,b_i) = \\min(a_i,b_j)$和$a_i = a_j$（或者$b_i = b_j$）同时满足，\n则可以推出$a_i=a_j,b_i=b_j$，也就是这两项的数据完全一致，并不是比较用数据一致，因此我们这里也可以即交换又不交换，保持模棱两可定义。\n   很特殊的hack数据 在这里，我们会惊讶地发现，如果用选择排序的话，虽然是会TLE，但其结果是正确的。\n【相关原因请查看后面的「有关排序的深层理解」部分】\n个人发现了选择排序答案是正确的后，对各种排序的实现展开了思考和实验。\n认为像快速排序或归并排序等，是因为采用典型的分治思想才导致需要满足严格弱序的。\n那么对于其他排序方法比如“希尔排序”、“堆排序”、“锦标赛排序”等是否不需要满足严格弱序呢？\n【这里没考虑“计数排序”、“基数排序”和“桶排序”这三种非比较式排序算法。因为这里没有关键字，无法使用这三种排序方法。\n所以在实验的时候就弄出了一些其他的hack数据，\n然后其中发现了一组很特殊的hack数据！(:з」∠)……\n 数据：\n 1\n5\n9 7\n1 1\n4 5\n1 2\n6 5\n *以下表格中的option表示$\\max(c_{i-1},\\sum_{j=1}^ia_j)$选择的哪个*。\n  标准答案：27\n  利用选择排序后的结果\n    $a$ $b$ $c$ option     1 $1$ $2$ $3$    2 $1$ $1$ $4$ $c$   3 $4$ $5$ $11$ $\\sum a$   4 $9$ $7$ $22$ $\\sum a$   5 $6$ $5$ $27$ $c$      特殊性\n我们如果排序成：\n    $a$ $b$ $c$ option     1 $4$ $5$ $9$    2 $1$ $2$ $11$ $c$   3 $9$ $7$ $21$ $\\sum a$   4 $1$ $1$ $22$ $c$   5 $6$ $5$ $27$ $c$    会发现$1$和$2$（$i=1,j=2$）这两组数据，\n其实是不满足$\\min(a_i,b_j) \u0026lt; \\min(a_j,b_i)$这个条件的！\n故这也告诉了我们：最优解也可能存在有两项不满足决策条件的状态。\n【更准确叙述请查看后面的「有关贪心决策的满足度影响」部分】\n  有关自己使用其他排序方法验证的代码，以及其他两组hack数据可见Pastebin。\n决策条件是否正确的判断方法 1、条件检查器 基于以上分析，我们发现：\n如果按上述“基本决策寻找方法”得到的决策条件$P$是正确的，必须要满足基本的排序型贪心的条件：\n 数列任意两项满足决策条件。\n 如果决策条件$P$满足以下条件，则可证得排序后一定满足该基本条件：\n 满足严格弱序中的两个传递性。  根据以上一点，我们可以编写一个条件检查器。\n【这个条件检查器的方法是参考自“ouuan”的博客后了解的，个人在其基础之上有所修改并加入了注释……\n#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstdio\u0026gt;using namespace std; bool cmp(int i, int j); int a[10], b[10]; int main() { for (a[0] = 1; a[0] \u0026lt;= 6; ++a[0]) for (b[0] = 1; b[0] \u0026lt;= 6; ++b[0]) //构造第一组a,b数组数据：用来判断自反性  { if (cmp(0, 0)) //不满足自反性。  //分析知这条对于贪心思路并不是很重要，所以注释了。但如果用sort就很重要。  //printf(\u0026#34;No irreflexivity: %d %d\\n\u0026#34;, a[0], b[0]);  for (a[1] = 1; a[1] \u0026lt;= 6; ++a[1]) for (b[1] = 1; b[1] \u0026lt;= 6; ++b[1]) //构造第二组a,b数组数据：用来判断非对称性  { if (cmp(0, 1) \u0026amp;\u0026amp; cmp(1, 0)) //非对称性的判断  printf(\u0026#34;No asymmetric: %d %d %d %d\u0026#34;, a[0], b[0], a[1], b[1]); /* 这部分原本是判断 我们新的决策条件 与 最开始分析的决策条件 是否判断一致，但其实可以不用判断。 //同理，在ouuan所写的判断器中：有一个关于「排序完成后任意交换相邻元素均不会使答案更优」这个的判断，但实际上如果满足了严格弱序一定也会满足这个条件，也不用判断。 bool our_judge = cmp(0, 1), real_judge = min(a[0], b[1]) \u0026lt; min(a[1], b[0]), if_equal = min(a[0], b[1]) == min(a[1], b[0]); //注意这里真实判断（以决策条件判断），如果为0：有可能真的不满足，但也有可能是相等情况；如果为1：那就一定是满足 //所以我们要加个if_equal，如果是相同状况则不判断是否与真是判断相同 if (!if_equal \u0026amp;\u0026amp; our_judge != real_judge) //与真正决策条件判断不同 printf(\u0026#34;Not correct(%s): %d %d %d %d\\n\u0026#34;, (our_judge == 1 ? \u0026#34;We judge it\u0026#39;s right, but truth is wrong.\u0026#34; : \u0026#34;We judge it\u0026#39;s wrong, but truth is right\u0026#34;), a[0], b[0], a[1], b[1]); */ for (a[2] = 1; a[2] \u0026lt;= 6; ++a[2]) //构造第三组a,b数据：用来判断传递性  for (b[2] = 1; b[2] \u0026lt;= 6; ++b[2]) { bool flag_inequ = 1, flag_equ = 1; bool cmp_01 = cmp(0, 1), cmp_12 = cmp(1, 2), cmp_02 = cmp(0, 2); //注意我们判断两状态是否是用的!cmp(i,j) \u0026amp;\u0026amp; !cmp(j,i)（非对称性的利用）  bool euqal_01 = !cmp(0, 1) \u0026amp;\u0026amp; !cmp(1, 0), euqal_12 = !cmp(1, 2) \u0026amp;\u0026amp; !cmp(2, 1), euqal_02 = !cmp(0, 2) \u0026amp;\u0026amp; !cmp(2, 0); if ((cmp_01 == cmp_12 \u0026amp;\u0026amp; (cmp_01 == 1 || (cmp_01 == 0 \u0026amp;\u0026amp; !euqal_01 \u0026amp;\u0026amp; !euqal_12))) \u0026amp;\u0026amp; cmp_01 != cmp_02) //不符合不等传递性  { /* 怎么才算符合不等传递性： 1 1 -\u0026gt; 1 1 0 -\u0026gt; ? (2 \u0026lt; 7, 7 \\not\u0026lt; 5 ---\u0026gt; 2 \u0026lt; 5)(2 \u0026lt; 7, 7 \\not\u0026lt; 1 ---\u0026gt; 2 \\not\u0026lt; 1) 0 1 -\u0026gt; ? (Same way) 0 0 -\u0026gt; 0 //但要注意这里cmp为0：有可能是不满足，也有可能是因为等于的情况。所以要加!euqal来排除等于情况 */ flag_inequ = 0; printf(\u0026#34;No transitivity of inequivalence: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } if (!(euqal_01 == 0 \u0026amp;\u0026amp; euqal_12 == 0) \u0026amp;\u0026amp; (euqal_01 \u0026amp;\u0026amp; euqal_12) != euqal_02) //相等传递性  { /* 怎么才算符合相等传递性： 1 1 -\u0026gt; 1 1 0 -\u0026gt; 0 0 1 -\u0026gt; 0 0 0 -\u0026gt; ? (2 ≠ 3, 3 ≠ 2 ---\u0026gt; 2 = 2)//这个很好知道吧【…… */ flag_equ = 0; printf(\u0026#34;No transitivity of equivalence: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } if (flag_inequ == 1 \u0026amp;\u0026amp; flag_equ == 0) //私货：求证如果满足不等传递性，但不满足相等传递性，是否X=Y,Y\u0026lt;Z---\u0026gt;X\u0026lt;Z；X\u0026lt;Y,Y=Z---\u0026gt;X\u0026lt;Z？  { printf(\u0026#34;===In Case===\\n\u0026#34;); bool euqal_cmp01 = !cmp(0, 1) \u0026amp;\u0026amp; !cmp(1, 0), ineuq_cmp01 = cmp(0, 1), euqal_cmp12 = !cmp(1, 2) \u0026amp;\u0026amp; !cmp(2, 1), ineuq_cmp12 = cmp(1, 2), euqal_cmp02 = !cmp(0, 2) \u0026amp;\u0026amp; !cmp(2, 0), ineuq_cmp02 = cmp(0, 2); if (euqal_cmp01 \u0026amp;\u0026amp; ineuq_cmp12) { if (!ineuq_cmp02 \u0026amp;\u0026amp; !euqal_cmp02) printf(\u0026#34;---X=Y,Y\u0026lt;Z---\u0026gt;X not\u0026lt; Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); else if (!ineuq_cmp02) printf(\u0026#34;---X=Y,Y\u0026lt;Z---\u0026gt;X = Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } if (ineuq_cmp01 \u0026amp;\u0026amp; euqal_cmp12) { if (!ineuq_cmp02 \u0026amp;\u0026amp; !euqal_cmp02) printf(\u0026#34;---X\u0026lt;Y,Y=Z---\u0026gt;X not\u0026lt; Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); else if (!ineuq_cmp02) printf(\u0026#34;---X\u0026lt;Y,Y=Z---\u0026gt;X = Z: %d %d %d %d %d %d\\n\u0026#34;, a[0], b[0], a[1], b[1], a[2], b[2]); } } } } } return 0; } bool cmp(int i, int j) { /* 展开式：【用来debug方便watch的…… int min_ij = min(a[i], b[j]), min_ji = min(a[j], b[i]); bool ans = 0; if (min_ij == min_ji) ans = a[i] \u0026lt; a[j]; else ans = min_ij \u0026lt; min_ji; return ans; */ return min(a[i], b[j]) \u0026lt; min(a[j], b[i]); //Case.1  //return min(a[i], b[j]) \u0026lt;= min(a[j], b[i]); //Case.2  //return min(a[i], b[j]) == min(a[j], b[i]) ? a[i] \u0026gt; a[j] : min(a[i], b[j]) \u0026lt; min(a[j], b[i]); //Case.3  //return min(a[i], b[j]) == min(a[j], b[i]) ? a[i] \u0026lt; a[j] : min(a[i], b[j]) \u0026lt; min(a[j], b[i]); //Case.4 } 上述提到了：如果满足了严格弱序一定也会满足「排序完成后任意交换相邻元素均不会使答案更优」这个条件。\n所以我并没有写上“ouuan”博客中的那个条件。\n而且对于严格弱序，我也认为只用判断传递性即可。\n【如果这种修改有误，请务必告诉我！……\n因为决策条件$P$满足严格弱序后，我们按照$P$排序后，一定会使任意两项均满足$P$，则满足我们的贪心的思想，使得肯定这个状态是最优解状态。\n【但这种口头解释没有严格证明可能没有说服力，可以自己在判断器里删掉注释然后验证一下_(:з」∠)_……\n2、与选择排序对拍 当然，我们发现了：用选择排序的话结果是正确的。\n所以我们也可以很快地写个选择排序，然后跟我们新的方法进行对拍。\n其他补充点 有关排序的深层理解 我们发现选择排序用之前的条件，虽然会TLE，但是是正确的。\n 洛谷上测试状态【其余未放出的均AC】：\n将其两组数据放到本地测评：\n 主要就是因为排序这种绝对的$O(n^2)$的算法，是严格让所有数据都两两比较。\n正式因为其两两比较，使得不需要利用满足数据严格弱序的传递性。\n不会像快排或归并等其他非$O(n^2)$的算法一样，利用严格弱序中的传递性，来对某些情况减少判断，达成了降低复杂度的办法。\n也就是说，他们为了提高速度，省略了一些比较。代价就是数据必须要满足一定的条件，即严格弱序。\n同样，就连冒泡排序这种本来也是$O(n^2)$的排序算法【但实际上并不是绝对的$O(n^2)$，其最坏是$\\frac{(n-1)n}{2}$次操作】，\n因为只是比较相邻的数据，并未严格任意两两比较。也是利用了传递性。\n有关贪心决策的满足度影响 之前发现：\n让任意两项都满足决策条件，是一定是最优解的。\n但之前发现：如果存在两项不满足，也有可能是最优解。\n也就是任意两项都满足决策条件的这种状态，是最优解状态的一种，为$∈$关系。\n但我们只能去找任意两项均满足的这种状态。因为对于存在两项不满足的，也有可能不是最优解，就成了概率问题。\n【而这道题概率出来就是80分……\n有关排序对严格弱序的不同要求   $X \\not\u0026lt; X$（比较条件非自反性） 若$X \u0026lt; Y$，则$Y \\not\u0026lt; X$（比较条件非对称性） 若$X \u0026lt; Y,Y \u0026lt; Z$，则$X \u0026lt; Z$（比较条件不等传递性） 若$X=Y,Y=Z$，则$X=Z$（比较条件相等传递性）   前面已经说了，对于1、2点，其实对于贪心的题目要求并不严格。\n不满足的话只是会多交换几次，导致状态不同，但最终的ans是一样的。\n但某些算法要求必须要遵守1、2点。\n  对于用STL库的sort()：\n其必须还要考虑1、2点非自反性和非对称性。\n因为内部的算法实现，对下标的判断需要用到这两个性质，否则会越界导致RE。\n【不过我没有具体去看函数内部的代码实现，只是根据网上搜的以及自己实验得出来的，不一定准确。但确实不考虑这两个的话会出现RE……\n  对于其他非$O(n^2)$排序方法：\n如：归并排序merge：\n则不用考虑1、2点。\n【当然还是要根据自己的排序写法来判断是否需要满足1、2点……\n  有关传递性的简单判断 我们排序比较时，只会比较两个元素，也就是两个下标，一般用$i,j$代表。\n而排序（决策）条件，也一定是与$a_i$和$a_j$的衍生关系。\n那么排序条件的下标会有两种情况：\n  一侧只有一个下标\n形如：$cmp(x,y)=A_x?A_y$\n当比较条件一侧只有一个下标的时候很好理解，就是普通的数列排序。\n单侧下标时，两个下标的选择不会影响其对应的比较用数据的值，\n故一般能符合比较条件不等传递性和比较条件相等传递性。\n 举例：    条件为$a_i\u0026gt;a_j$\n取$i,j$：$a_i=a_j$\n取$j,k$：$a_j=a_k$\n取$i,k$：$a_i=a_k$ 条件为$a_i+a_{i+1}\u0026gt;a_j+a_{j+1}$\n取$i,j$：$a_i+a_{i+1}=a_j+a_{j+1}$\n取$j,k$：$a_j+a_{j+1}=a_k+a_{k+1}$\n【则可直接推得$a_i+a_{i+1}=a_j+a_{j+1}=a_j+a_{j+1}=a_k+a_{k+1}$】\n取$i,k$：$a_i+a_{i+1}=a_k+a_{k+1}$     一侧两个下标都有\n形如：$cmp(x,y)=A_{x,y}?A_{y,x}$\n当一侧两种下标都有时，则不同下标的选择会影响其对应的比较用数据的值。\n故需要具体判断是否比较条件传递性和比较条件相等传递性。\n 举例：    条件为$a_i+a_{j+1}\u0026gt;a_j+a_{i+1}$\n取$i,j$：$a_i+a_{j+1}=a_j+a_{i+1}$\n取$j,k$：$a_j+a_{k+1}=a_k+a_{j+1}$\n【不可直接推得$a_i+a_{j+1}=a_j+a_{i+1}=a_j+a_{k+1}=a_k+a_{j+1}$】\n但可证得：取$i,k$：$a_i+a_{k+1}=a_k+a_{i+1}$     总结 有关排序型贪心，最基本的条件：\n 数列任意两项满足决策条件。\n 而我们可以利用传递性，只用分析相邻两项，来得到决策条件。\n但在找到决策条件之后，要判定其是否满足严格弱序中的“相等传递性”和“不等传递性”\n因此题目解决大致思路方法：\n  找出每种状态的ans，选邻项代入 假设相邻位置，写出两种状态的ans 根据题意写出排序条件并化简，得到最终决策方案（不一定划到最简） 判断是否满足传递性 如满足：自定义结构体，重载\u0026lt;运算符，使用sort，遍历寻答案    以上部分参考自“ouuon”的「浅谈邻项交换排序的应用以及需要注意的问题」，以及“Joker\u0026amp;Liar”的「浅谈邻项交换排序」\n写在最后：\n 真的没想到写了这么多orz……弄了整整四天来写这一个东西qwqqq……\n写这么长而且也很混乱，估计以后自己或者其他人也根本看不下去吧x【……\n不过其实这里面还是有很多新发现的。比如快速排序算法的快速原因，以及最珍贵的就是那个不符合任意两项满足条件但是也对的hack数据什么的……\n也算是很深入地去理解贪心中这排序型贪心的本质……并且有一些也是在“ouuan”dalao博客里所没有的新发现，也算是比较安慰了【？……\n就这样吧，最近刚好也发生了很多事……\n按照自己的步调前行吧……\n ","date":"2020-12-15T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-neighbor_sort/71111285_p0_hud2648e021785c2a9f9434e425c67999f_2056049_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-neighbor_sort/","title":"ACM学习笔记——邻项比较排序……"},{"content":"该笔记目前直接复制的之前的笔记，还未调整格式。可能格式、内容、链接等混乱错误……\n\r 贪心介绍 定义 贪心，指的是决策时都采取当前最优解的算法。\n可以通过局部最优解拓展得到全局最优解。\n用处 寻找最优解（如：找最大(小)值）\n贪心类别 一、排序型贪心 这种类型就是通过给数据排序，不同的排序方法演绎下去就会有不同的答案ans。\n然后要比较所有排序方法，选让这些ans的最值。\n  为什么会想到排序？\n 虽然我们只看重眼前利益选择当前的最优解，随时准备开冲去比较两者选获利最大的【指直接从头开始遍历然后选择】。\n但这个时候我们暂且压一下枪理智一下：我们怎么知道我们现在选的是不是最优解呢？\n也就是说，可能现在这两个中，我选了一个当前最优解，但实际上跟后面比起来，这两个都不是最优解。\n也就是著名的苏格拉底的“拣麦穗的故事”。\n所以我们以全局眼光来看这些数据，飞到这片麦田之上，就会发现：“哦~原来利益最大的在那个地方、第二大的又在另个地方……”\n然后我们知道这些获利最大的点在哪里，就用原力把他们放到我们面前来，然后直接取走就行了。\n或者说：我们先辛苦一下对这些数据排下序，然后直接取最优结果就可以了。\n   所以我们就能得到有关排序型贪心的定义：\n 通过对数据，按照某种决策条件排序，使得任意两项均满足该决策条件，而找到最优解。\n 实现方法  根据题意，分析每种状态的ans如何计算，以及题目要求取ans的什么最值。 采用邻项交换排序思想，选取相邻两项$i,i+1$，比较两种状态的ans，选择最优的ans。由此可以推出一种基于数据比较的决策方案。 按照该决策方案排序，算出排序后状态的ans值，即为结果。  邻项交换排序 这一部分请查看邻项交换排序笔记。\n二、反悔型贪心 依然是上面的引例：\n【我管不了那么多了我现在就要开冲.jpg……\n但一路冲下去，如果发现有比之前选择的更好的数据，\n我们是不是就会觉得后悔，觉得如果之前不选那个而选这个该多好。\n因此我们就可以从之前所选择的当中，取一个最差的，然后跟这个最好的换一下。\n这就是反悔贪心法的基本思路：\n 无论当前的选项是否最优都先接受，然后继续往后进行比较。\n如果发现有比之前选择更优的，则反悔，舍弃之前最差的换成这个选项；否则继续往后比较。直到序列遍历完。\n  要记录之前所选择的，则一般采用优先队列。  ","date":"2020-12-14T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-greedy/80942286_p0_hu1614f1e19d3d1ca6099df8f8b769c088_1500547_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-greedy/","title":"ACM学习笔记——贪心……"},{"content":"该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误……\n\r GCD 引例：最大公约数 没什么好说的，就最大公约数。\n主要是他的求解方法：欧几里得算法(Euclidean algorithm)（即：辗转相除法）。\n欧几里得算法 也不多讲，证明也懒得_(:з」∠)_……\n主要是他的扩展：**扩展欧几里得定理**(Extended Euclidean algorithm, EXGCD)【没有在套娃xddd……\n主要依靠式子：$\\gcd(a,b)=\\gcd(b,a\\mod b)$\n当 $b=0$ 时，此时算出来的 $a$ 即为最终 $\\gcd(a,b)$ 的结果。\n时间复杂度为$O(\\log n)$。\n实现代码  递归实现：  long long gcd(long long a, long long b) { //if (a \u0026lt; b) \t//\treturn gcd(b, a); \t/* 删除原因： 虽然用辗转相除法需要满足a \u0026gt; b。 但如果a \u0026lt; b，则b % a = a， gcd(b, b % a)实际上就相当于交换了a,b。故不用单独判断。 */ if (b == 0) return a; return gcd(b, b % a); /* 一行代码： return b ? gcd(b,b%a) */ }  迭代实现：  long long gcd_iteration(long long a, long long b) { while (b ^= a ^= b ^= a %= b);\t//b^=a^=b^=a为交换两变量操作，最后以b的值为循环条件。  return a; } 多个数的最大公约数 求 $a_1,a_2,\\cdots,a_n$ 个数的最大公约数，\n直接为 $\\gcd(a_1,a_2,\\cdots,a_n)$。\n先算$\\gcd(a_1,a_2)$，所得结果$d_1$，再$\\gcd(d,a_3)$，反复进行。\n此处以上为基础部分。\n 裴蜀定理（贝祖定理） 在学EXGCD之前，要先来认识一下这个定理。\n裴蜀定理，又称贝祖定理(Bézout\u0026rsquo;s lemma)。是一个关于最大公约数的定理。\n\r 引自：OI-Wiki\n定义  若 $a,b$ 是不全为零的整数，记：$\\gcd(a,b)=d$，\n则对于任意的整数 $x,y$ ， $ax+by$ 都一定是 $d$ 的整数倍。\n 特别的：一定存在整数 $x,y$ ，使 $ax+by=d$ 成立。     为充要条件，即：\n若 $ax+by=c$ 有解，\n则 $\\gcd(a,b)\\mid c$ 。（其中 $\\mid$ 为整除符号，代表$c$能被$\\gcd(a,b)$整除）\n（或者说 $c$ 是 $\\gcd(a,b)$的整数倍）\n 特别的：如果 $ax+by=1$ ，则 $a,b$ 互质（$\\gcd(a,b)=1$）。  这个即为二元一次不定方程存在解的条件。\n  简洁一点则为：\n 若 $a,b$ 是不全为零的整数，\n则存在整数 $x,y$ , 使得 $ax+by=\\gcd(a,b)$ 。\n 这个定理只是个概念，让你知道有这样的解存在，但并没有实际告诉你该怎么解。\n推论  有关互质：  $a,b$ 互质（$\\gcd(a,b)=1$）的充要条件为：\n存在整数 $x,y$ ，使得$ab+by=1$\n  推广到$n$个数的情况：  设存在$n$个整数 $a_1,a_2,\\cdots,a_n$ ， $d= \\gcd(a_1,a_2,\\cdots,a_n)$ ，\n则存在整数 $x_1,x_2,\\cdots,x_n$ ， $x_1a_1+x_2a_2+\\cdots+x_na_n=d$ 有解。\n 特别的：\n如果 $a_1,a_2,\\cdots,a_n$ 互质，（不是两两互质，而是存在两个数互质，即：$\\gcd(a_1,a_2,\\cdots,a_n)=1$）\n则存在整数 $x_1,x_2,\\cdots,x_n$ ，使得 $x_1a_1+x_2a_2+\\cdots+x_na_n=1$ 。     参考自：“静听风吟。”的「数学：裴蜀定理」。\n基本应用（例题）  例题：Codeforces Round #290 (Div. 2) D. Fox And Jumping\n给出$n$张卡片，分别有$l_i$和$c_i$。在一条无限长的纸带上，你可以选择花$c_i$的钱来购买卡片$i$，从此以后可以向左或向右跳$l_i$个单位。 问你至少花多少元钱才能够跳到纸带上全部位置。若不行，输出$-1$。\n 分析该问题：\n如果每个格子都想要被跳到，则必须选出一些数，使得数次加减后绝对值为$1$。【我们定加减后值就为$1$。因为如果为$-1$，可以通过反向跳跃（取相反数）使得值为$1$。】\n这样通过每次移动$1$格，便能满足跳到每个格子上，否则一定不能满足。\n由上述裴蜀定理的“推论2”可知：\n如果要满足 $x_1a_1+x_2a_2+\\cdots+x_n*a_n=1$ ，\n则必须满足 $\\gcd(a_1,a_2,\\cdots,a_n)=1$ 。\n但又由于有代价的存在，【分析了这么多，那么代价呢x……\n所以可以用$dp$思想：\n 用个dp表存跳某步的代价最小值。\n那么每读入一个，则对所存的状态进行遍历，\n求取其与某状态的$\\gcd$，算出来是多少，则这两个数可以通过数次加减后走多少格。\n不断更新，最后如果dp[1]存在，则输出，否则输出-1。\n 又因为数据范围太大，故用map来代替基本的数组来存。\n【OI-Wiki上说可以用unordered_map。但由于这里要遍历，故我觉得还是要用map。unordered_map由于其内部是用哈希表实现的，遍历时可能访问不全。\n部分代码 map\u0026lt;int, int\u0026gt; dp; for (int i = 1; i \u0026lt;= n; i++) { dp[l[i]] = dp[l[i]] ? min(dp[l[i]], c[i]) : c[i];\t//如果存在要去最小  for (auto j : dp)\t//遍历当前dp表  { int to = __gcd(l[i], j.first);\t//计算能去的点（gcd）  int cost = dp[l[i]] + j.second;\t//计算代价  dp[to] = dp[to] ? min(dp[to], cost) : cost; } } 参考自：“Kanoon”的Codeforces Round #290 (Div. 2) D. Fox And Jumping（数论，裴蜀定理，gcd）\n扩展欧几里得定理 扩展欧几里得定理（Extended Euclidean algorithm, EXGCD），常用于求 $ax+by= \\gcd(a,b)$ 的一组可行解。\n\r 引自：OI-Wiki\n方法详解 求 $ax+by= \\gcd(a,b)$ 的一组可行解：\n设:$a\u0026gt;b$，则有以下两种情况\n  当$b=0$时，$\\gcd(a,b) = a$，所以存在一组解$\\left{\\begin{array}{ll}x = 1\\y =0\\end{array}\\right.$\n  当$a=0$时，$\\gcd(a,b)=\\gcd(b,0)$，一样的结果。\n  当$ab\\neq0$时：\n 设：\n$\\left{\\begin{array}{ll} ax_1+by_1=\\gcd(a,b) \\ bx_2+(a \\mod b)y_2=\\gcd(b,a \\mod b) \\end{array}\\right.$\n由欧几里得算法可知： $\\gcd(a,b) = \\gcd(b,a \\mod b)$\n故： $ax_1+by_1 = bx_2+(a \\mod b)y_2$\n又因为： $a \\mod b = a-(\\lfloor \\frac{a}{b} \\rfloor \\times b)$\n所以：\n$ax_1+by_1$\n$= bx_2+[a-(\\lfloor \\frac{a}{b} \\rfloor \\times b)]y_2$\n$= ay_2+bx_2 - \\lfloor \\frac{a}{b} \\rfloor \\times by_2$\n$= ay_2+b(x_2 - \\lfloor \\frac{a}{b} \\rfloor \\times y_2)$\n因为上下两式中： $a=a,b=b$\n所以：$\\left{\\begin{array}{ll} x_1=y_2 \\ y_1=x_2-\\lfloor \\frac{a}{b} \\rfloor \\times y_2 \\end{array}\\right.$\n 便可得到递归式：$\\textup{exgcd}(x,y)=\\textup{exgcd}(y,x-\\lfloor \\frac{a}{b} \\rfloor \\times y)$（此时的$a,b$是属于$\\textup{exgcd}(x,y)$状态的$a,b$）\n终止条件： $b=0$时，$\\left{\\begin{array}{ll}x = 1\\y =0\\end{array}\\right.$\n 虽然$\\gcd(a,b)$和$\\textup{exgcd}(a,b)$都有递归式，\n但$\\textup{exgcd}$不同于求$\\gcd$：\n 求解$\\gcd$是知道最开始的初状态，一直递归求得末状态。 求解$\\textup{exgcd}$只是知道末状态，要根据末状态再倒推回去求解初状态（一组解）。\n则需要不断递归到末状态，再由末状态反推到初状态。故可配合$\\gcd$求得$\\textup{ecgcd}$     实现代码  递归实现：  //函数返回值为gcd，过程中计算x,y。 int Exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if (b == 0) //代表通过gcd求得末状态，  { x = 1, y = 0; //由上分析知：终状态为x = 1, y = 0。  return a; } int gcd = Exgcd(b, a % b, x, y); //直接递归gcd求  int t = x; //这里之后开始反推回去  x = y; y = t - (a / b) * y; return gcd; }   迭代实现：\n有关$\\textup{exgcd}$的迭代方式，可以采用矩阵乘法的思路理解。\n 这是我们找到的递归式：\n$$\\textup{exgcd}(x,y)=\\textup{exgcd}(y,x-\\lfloor \\frac{a}{b} \\rfloor \\times y)$$\n或写为：$\\left{\\begin{array}{ll} x=y' \\ y=x'- \\lfloor \\frac{a}{b} \\rfloor \\times y' \\end{array}\\right.$（此时的$a,b$是属于$\\textup{exgcd}(x,y)$状态下的$a,b$）\n变成矩阵形式： $$\\begin{pmatrix} x \\ y \\end{pmatrix}=\\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_1 \\end{pmatrix}\\begin{pmatrix} x' \\ y' \\end{pmatrix}$$ 其中$d_1$表示第一次迭代（初状态）的$\\lfloor\\frac{a}{b}\\rfloor$。\n然后就可以一直乘下去展开，直到最终状态： $$\\begin{pmatrix} x \\ y \\end{pmatrix} = \\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_1 \\end{pmatrix} \\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_2 \\end{pmatrix} \\cdots \\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_n \\end{pmatrix} \\begin{pmatrix} 1 \\ 0 \\end{pmatrix}$$ 因此就可以顺着迭代：计算出中间$n$个二阶矩阵$\\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_i \\end{pmatrix}$的乘积。最后到最终状态乘$\\begin{pmatrix} 1 \\ 0 \\end{pmatrix}$，也就是直接取最终算出的二阶矩阵$\\begin{pmatrix} x_1\u0026amp;x_2 \\ y_1\u0026amp;y_2 \\end{pmatrix}$的$x_1,x_2$\n 我们还可以调整一下，设定一个初矩阵，然后直接乘每次的$\\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_i \\end{pmatrix}$，就不用额外处理初状态，直接顺着迭代着走就可以了。\n否则需要额外处理初状态，要令初矩阵为$\\begin{pmatrix} 0\u0026amp;1 \\ 1\u0026amp;-d_1 \\end{pmatrix}$，然后还要迭代次$\\gcd(a,b)$才能进入循环。\n易知这个初状态就是单位矩阵$\\begin{pmatrix} 1\u0026amp;0 \\ 0\u0026amp;1 \\end{pmatrix}$。\n   int Exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { x = 1, y = 0; //初矩阵：1 0  int x1 = 0, y1 = 1; // 0 1  /* 不定义这个初矩阵的话就要写为： x = 0, y = 1; //初矩阵：0 1 int x1 = 1, y1 = -a/b; // 1 -d1 tie(a, b) = make_tuple(b, a - (a/b) * b); //然后还要迭代一下 */ while (b) { int d = a / b; tie(x, x1) = make_tuple(x1, x - d * x1); //矩阵乘法  tie(y, y1) = make_tuple(y1, y - d * y1); tie(a, b) = make_tuple(b, a - d * b); //迭代gcd()  } return a; } ","date":"2020-12-12T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-gcd_exgcd/73415224_p0_hu09ddeb20de934db6dbd54dd691a098a4_1500993_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-gcd_exgcd/","title":"ACM学习笔记——GCD、裴蜀定理、EXGCD……"},{"content":"该笔记还未完成整理，待日后继续整理……\n\r 应用 矩阵加速递推 OI-Wiki —— 矩阵快速幂优化递推。\n\r 状态矩阵构造方法 根据题目状态转移方程分析，\n选状态为行、选决策为列……\n在斐波拉契中：\n 当前的结果取决于前两个数字（状态），\n但这两个数字就是这两个数字，相当于只有一种决策……\n即$dp[n][1] \\leftarrow dp[n-1][1] \\\u0026amp; dp[n-2][1]$……\n只有一种决策，便可以把列维度给省去……\n $mat[1],mat[2]$分别为前一个数和当前数……\n   在题P4838 P哥破解密码中：\n 当前的结果取决于上一次状态的三种决策。\n即$dp[n][1 \\sim 3] \\leftarrow dp[n-1][1 \\sim 3]$……\n $mat[1][],mat[2][]$就是上一次、这一次两状态…\n$mat[][1],mat[][2],mat[][3]$就是选$1$个$A$、选$2$个$A$、选$B$的决策……\n   做题记录  递推矩阵计算 构造完状态矩阵后，只需要手动模拟递推，需要加这个元素的令为$1$（要乘$n$便令为$n$），不需要的令为$0$……\n若状态矩阵大小为$n*m$，则递推矩阵大小：$m*m$……\n矩阵快速幂 即为标准快速幂，改为矩阵乘法罢了……\n矩阵快速幂讲解。\n\r 优点  时间复杂度：$O(\\log n)$ 因为时间短，便可在较少询问次数的时候，只需要一个矩阵直接去计算，不需要空间开销来存下状态。  ","date":"2020-12-12T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-matrix/64382354_p0_hu61b6ab99624e6082e1431a5ffad1ba52_1252024_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-matrix/","title":"ACM学习笔记——矩阵……"},{"content":"该笔记还未完成整理，待日后继续整理……\n\r 该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误……\n\r\n0x00 前提知识 同余 $\\equiv$：是数论中表示同余的符号。\n用法：$a \\equiv b \\pmod n$\n定义  最基本的定义：两个数$a,b$对另一个数$n$的取余都相同。 衍生定义：$(a-b) \\bmod n = 0$  记作：$a \\equiv b \\pmod n$，表示$a,b$对$n$同余。\n 如：\n$7 \\bmod 3 = 1$\n$10 \\bmod 3 = 1$\n则：$7 \\equiv 10 \\pmod 3$\n 性质 以下部分为个人总结，名称不一定准确。\n 自反性：$a \\equiv a \\pmod m$。 对称性：若$a \\equiv b \\pmod m$，则$b \\equiv a \\pmod m$。 传递性：若$a \\equiv b \\pmod m$，$b \\equiv c \\pmod m$，则$a \\equiv c \\pmod m$。 替换性：对于$M \\equiv ab \\cdot x \\pmod m$，若$ab \\equiv c \\pmod m$，则$M \\equiv c \\cdot x\\pmod m$。 加减可移项性：若$a \\pm b \\equiv c \\pmod m$，则$a \\equiv c \\mp b \\pmod m$ 线性运算：如果$a \\equiv b \\pmod m$，$c \\equiv d \\pmod m$，那么有：  $a \\pm c \\equiv b \\pm d \\pmod m$。 $ac \\equiv bd \\pmod m$。\n推论：若$a \\equiv b \\pmod m$，则有$an \\equiv bn \\pmod m (n\\in Z, n \\ne 0)$。   模数的除法：若$ac \\equiv bc \\pmod m$，$\\gcd(m,c)=d$，则$a \\equiv b \\pmod{m/d}$；\n特别地，当$\\gcd(m,c)=1$时，有$a \\equiv b \\pmod m$。 模数的乘法：若$a \\equiv b \\pmod m$，则有$ak \\equiv bk \\pmod{mk}$，其中$k$为大于零的整数；\n推论：若$a \\equiv b \\pmod m$，$d$为$a,b$及$m$三者的任一正公约数，则$a/d \\equiv b/d \\pmod{m/d}$。 传递性2：若$a \\equiv b \\pmod m$，且$d \\mid m$，则$a \\equiv b \\pmod d$。  参考自“wcwcwch”的「同余的性质」。\n其他点 需要注意的是：\n负数也可以进行取模，因此也存在同余。\n 如：\n$-36 \\bmod 15$，\n用除法表示为$-36 \\div 15 = -3 \\cdots 9$（验算：$15*-3+9=-36$），\n即$-36 \\bmod 15 = 9$，\n所以$-36 \\equiv 24 \\pmod{15}$。\n  由于这个符号很新颖和陌生，导致在学习的时候理解上产生了很大的障碍，\n因此需要尽快适应这个符号的使用方法。\n首先需要知道的是：同余代表的是一种关系，而非运算。\n因此才会采用类似于等号的符号来表示。\n但这种等于，并不是像$2=2$这样直接就可以判断，\n而是要经过稍微的运算，两边同时取模后等于，才叫同余。\n然后对于这个符号，有很多种不同的理解方式，\n建议自己确定一个自己习惯的理解方式并一直用下去。\n个人所采用的是：$a \\equiv b \\pmod m$，代表$a \\bmod m = b \\bmod m$。\n 需要牢记一个转换式： $$a \\equiv b \\pmod m \\implies a = mk + b (k∈Z)$$\n整除 $\\mid$：是数论中的表示整除符号。\n用法：$a \\mid d$\n注意：\n这里的整除就是整除，不是被整除。\n如上例：是$a$整除$b$，或说$b$被$a$整除。\n 如：\n$2\\mid14$\n则是$2$整除$14$，$14$被$2$整除。\n 整除也代表两者大除小余数为$0$，故同余还可以写为：\n$m \\mid (a-b)$\n$\\implies (a-b) \\bmod n = 0$\n$\\implies a \\equiv b \\pmod n$\n学习顺序  裴蜀定理 扩展欧几里得 初步认识线性同余方程 认识乘法逆元并求解 求解线性同余方程  其中：\n 1、2为$\\gcd$内容， 3、4、5为本章（线性同余方程）内容。  0x01 初步认识 定义 形如$f(x) \\equiv 0 \\pmod m$的方程称为同余方程，\n其中$f(x)=a_nx^n+a_{n-1}x^{n_1}+\\cdots+a_1x+a_0$。\n记：$f(x)$最高次数为$n$，则称为$n$次同余方程。\n特别的：当$n=1$时，称为一次同余方程，又称线性同余方程。\n即：\n形如$ax \\equiv b \\pmod m$的方程，\n被称为线性同余方程(Congruence Equation)。\n 如：\n$12x \\equiv 9 \\pmod {15}$\n解得：$x=\\cdots,-3,2,7,12,17,\\cdots,5n+2(n∈Z)$\n当$x=-3$时，$12*-3=36$，$-36 \\bmod 15 = 9$，满足方程。\n当$x=2$时，$12*2=24$，$24 \\bmod 15 = 9$，满足方程。\n当$x=7$时，$12*7=84$，$84 \\bmod 15 = 9$，满足方程。\n  同样，对于这个方程，\n我们也需要对其快速建立自己的理解方法。\n个人理解方法是：\n当$x$取某一值时，则$ax$对$m$取模的结果就是$b$。\n  与普通的一元线性方程不同的是：\n普通的一元线性方程肯定存在唯一解（如$2x+3=5$）；\n而线性同余方程若有解，需要存在一定条件。\n有解条件 对于线性同余方程$ax \\equiv b \\pmod m$，其存在解的条件是：\n$b$能够被$a$与$m$的最大公约数整除。\n表示为： $$\\gcd(a,m) \\mid b$$\n 如上例中：\n$12x \\equiv 9 \\pmod {15}$\n因为$\\gcd(12,15)=3$，而$3$能整除$9$，\n即$\\gcd(12,15) \\mid 9$，\n所以有解。\n  如：\n$3x \\equiv 5 \\pmod 6$，\n因为$\\gcd(3,6)=3$，而$3$不能整除$5$，\n故该同余方程无解，\n也就是说无论你$x$取何值，都不能满足$3x$对$6$取模后值为$5$。\n  注意到，若$x_0$是线性同余方程$ax \\equiv b \\pmod m$的一个解，\n那么对于$x_n \\equiv x_0 \\pmod m$，$x_n$也是该线性同余方程的解。\n或者说$mk+x_0(k∈Z)$均为解。\n 如上例中：\n$12x \\equiv 9 \\pmod {15}$\n$x_0=2$时为一解，\n因此$15k+2(k∈Z)$均为解，即$2,17,32,\\cdots$均为解。\n$x_0=7$时为一解，\n因此$15k+7(k∈Z)$均为解，即$7,22,37,\\cdots$均为解。\n$x_0=12$时为一解，\n因此$15k+12(k∈Z)$均为解，即$12,27,42,\\cdots$均为解。\n 因此对于线性同余方程的解的个数，我们定义为：\n在$0 \\sim (m-1)$中解的个数。\n 如上例中：\n$12x \\equiv 9 \\pmod {15}$\n解的个数就为$3$个，分别为$2,7,12$。\n 解的性质 对于线性同余方程$ax \\equiv b \\pmod m$，记$\\gcd(a,m)=d$\n若存在解，则会满足以下性质：\n 对于$x_0$为该线性同余方程的任意一解，记，\n则通解可以表示为$\\frac{m}{d}k + x_0 (k∈Z)$。  如上例中：\n$12x \\equiv 9 \\pmod {15}$\n$d=\\gcd(12,15)=3$\n得到一解$x_0=2$，\n则通解可以表示为$5k+2(k∈Z)$。\n  解的个数恰为$d$个。  如上例中：\n$12x \\equiv 9 \\pmod {15}$\n则在$0 \\sim 14$范围中，解为$2,7,12$。\n个数为$d=\\gcd(12,15)=3$，即$3$个。\n  唯一解定理：\n当$d=1$时，该同余方程有且仅有唯一解。  0x02 乘法逆元 定义 如果一个线性同余方程$ax \\equiv 1 \\pmod m$，存在解$x$，\n则$x$称为$a \\bmod m$的逆元，记作$a^{-1}$。\n 如：\n$5x \\equiv 1 \\pmod{14}$，\n当$x=3$时，$15 \\bmod 14 = 1$，满足方程。\n所以$3$为$5$关于$14$的逆元。\n 性质 对于一个线性同余方程$ax \\equiv 1 \\pmod m$，\n记$a$关于$m$的逆元$x$为$a^{-1}$。\n 存在充要条件：$a,m$互素，$\\gcd(a,m)=1$。 唯一性：$a^{-1}$在$[0,m-1]$范围内唯一。  证明：\n我们先假设$a$有两个不相等逆元：$a'$ 和$a''$，\n那么一定有：$aa' \\equiv aa'' \\equiv 1 \\pmod m$\n不妨设$a'∈[0,m-1]$，$a'\u0026lt;a''$且$a''-a'=k$，\n那么由于$a\\ne0$，所以$k$一定是$k \\equiv 0 \\pmod m$ ，即$k=cm(c∈Z,c\\ne0)$（见最上的转换式）\n所以$a''=a' + cm(c∈Z,c\\ne0)$，\n所以$a'\u0026lsquo;∈[cm,(c+1)m-1] (c∈Z,c\\ne0)$，一定不在$[0,m-1]$范围内，\n所以$a$在$[0,m-1]$范围内只能有一个逆元。\n  完全积性：$a^{-1} \\cdot b^{-1} = (a \\cdot b)^{-1}$ $\\gcd(a^{-1},m)=1$。 ${(a^{-1})}^{-1} \\equiv a \\pmod m$  作用 1. 对除法取模 首先对于取模运算，存在以下性质：\n$(a + b) \\bmod p = ((a\\bmod p) + (b\\bmod p)) \\bmod p$ （对）\n$(a - b) \\bmod p = ((a\\bmod p) - (b\\bmod p)) \\bmod p$ （对）\n$(a \\times b) \\bmod p = ((a\\bmod p) \\times (b\\bmod p)) \\bmod p$ （对）\n$(a \\div b) \\bmod p = ((a\\bmod p) \\div (b\\bmod p)) \\bmod p$ （错）\n 如：\n$(100/50)\\bmod20 = 2$\n$\\nRightarrow((100\\bmod20)/(50\\bmod20))\\bmod20=0$\n 因此如果对于一些题目，如果运算要求求余，但该运算为除法，\n我们就不能直接像加减乘运算一样拆开求余。\n但如果被除数，除数也超范围，那是不是只能用高精度了？\n并不是这样，我们可以利用乘法逆元来拆开求余。\n 乘法逆元又称为数论倒数。\n既然这么称呼，那么乘法逆元就跟倒数有相似之处。\n对于普通的数学运算$a \\div b$，\n其也可以写成$a \\times \\frac{1}{b}$。\n因此对于求余运算$(a/b) \\bmod m$，\n其也可以写成$(a \\cdot b^{-1}) \\bmod m$，\n这时便可以拆开求余为$((a\\bmod m) \\cdot (b^{-1}\\bmod m))\\bmod m$。\n 即存在性质： $$a/b \\bmod m = a \\cdot b^{-1} \\bmod m$$\n*参考自“Aloof__”的「乘法逆元的作用（逆元的作用是什么）」。*\n证明 根据逆元的定义，存在： $$b \\cdot b^{-1} \\equiv 1 \\pmod m$$\n同余式两边同乘$a$，得到： $$ab \\cdot b^{-1} \\equiv a \\pmod m$$\n同余式两边同除$b$，得到： $$a \\cdot b^{-1} \\equiv a/b \\pmod m$$\n得证。\n2. 线性同余方程的反函数 对于线性同余方程$ax \\equiv b \\pmod m$，\n表示为函数的形式即为$f(x) = ax \\bmod m$。\n如果知道函数值$f(x)$，\n那么反求解$x$的方法为：$x = f(x) \\cdot a^{-1}$。\n需要满足$x\u0026lt;m$，\n否则为$x \\equiv f(x) \\cdot a^{-1} \\pmod m$。\n 如：\n$2x \\equiv f(x) \\pmod{11}$。 当$x = 13$时，$f(x) = 4。\n$2$对$11$的逆元是$6$，\n$4 \\times 6 = 24$。\n$24 \\equiv x(13) \\pmod{11}$，\n而不是$24 = x(13)$。\n  主要应用于CTF中仿射加密的解密。\n证明 很简单的证明。\n$$ax \\equiv f(x) \\pmod m$$ $$ax \\cdot a^{-1} \\equiv f(x) \\cdot a^{-1} \\pmod m$$ $$x \\equiv f(x) \\cdot a^{-1} \\pmod m$$ 得证。\n求解方法 待补充！……\n","date":"2020-12-12T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-linear_equation/83179646_p0_hua9bd3bd10387d89cf6f6be61b75d18f9_1401560_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/acm-note-linear_equation/","title":"ACM学习笔记——线性同余方程……"},{"content":"该笔记还未完成整理，待日后继续整理……\n\r 该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误……\n\r\nSTL 详解 set——集合 set\u0026lt;int\u0026gt; STL_set\nset为关联容器。为一种体现集合性质的容器。\n其中不允许有重复元素。\n并且set中的元素是排好序的（升序）。\n用法 set\u0026lt;int\u0026gt; STL_set; //---对整体的操作--- STL_set.clear();\t//清空 STL_set.empty();\t//返回是否为空 STL_set.size();\t//返回元素个数 //---对元素的操作--- STL_set.insert(...);\t//在集合中插入元素 STL_set.erase(...);\t//删除集合中的元素 STL_set.count(...);\t//返回元素的个数【由于set不能存在重复元素，故只能返回0或1 //---迭代器--- STL_set.begin(); STL_set.end(); STL_set.find(...);\t//返回一个指向被查找到元素的迭代器，未找到返回set::end() STL_set.lower_bound(...)\t//返回大于等于某值的第一个元素的迭代器 STL_set.upper_bound(...)\t//返回大于某个值元素的迭代器 自定义性 set可支持自定义类型，但需要重载\u0026lt;运算符。\n struct type //用来存棋盘状态 { ...; bool operator\u0026lt;(type x) const { return ...; } }  实现 内部以红黑树的形式实现。\n应用场景 set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。\n同时可以实现数据去重。\n衍生STL  multiset: 关键字可重复出现的set。 unordered_set: 未排序的set（用hash函数组织）。 unordered_multiset: 未排序的可重复出现的set。  map——映射 map\u0026lt;int, int\u0026gt; STL_map\nmap为关联容器。为一种体现映射关系的容器，每个关键字对应一个值。\n数据会根据键值大小关系排序（升序）。\n数据元素都是成对出现(pair)。\n每一对中的第一个值称之为关键字(key)（也称键值），每个关键字只能在map中出现一次。\n第二个称之为该关键字的对应值(value)（也称实值）。\n用法 map\u0026lt;int, string\u0026gt; STL_map; //---初始构造--- STL_map = {{1,\u0026#34;a\u0026#34;},{2,\u0026#34;b\u0026#34;}};\t//为c++11标准 //---数组操作--- STL_map[25252] = \u0026#34;niconiconi\u0026#34;;\t//如果没有对应key则插入，如果已经存在则会修改value //---对整体的操作--- STL_map.clear(); STL_map.empty(); STL_map.size(); //---对元素的操作--- \t//insert过于麻烦不予讲解。 STL_map.erase(...);\t//删除对应key的元素，成功删除返回1，否则返回0 STL_map.count(...);\t//返回对应key元素的个数【由于map不能存在重复key，故只能返回0或1 //---迭代器--- STL_map.begin(); STL_map.end(); STL_map.find(...);\t//返回查找元素的迭代器，未找到返回map::end() STL_map.lower_bound(...)\t//返回key大于等于某值的第一个元素的迭代器 STL_map.upper_bound(...)\t//返回key大于某个值元素的迭代器 自定义性 set可支持自定义类型，但需要重载\u0026lt;运算符。\n struct type //用来存棋盘状态 { ...; bool operator\u0026lt;(type x) const { return ...; } }  实现 内部以红黑树的形式实现。\n应用场景 hash\n","date":"2020-12-03T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-stl/79059953_p0_hudcdceb022a1e552a3fbecef4125cea72_897862_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-stl/","title":"ACM学习笔记——STL……"},{"content":"比赛链接 Codeforces Round #682 (Div. 2)\n\r 总结范围  A B C D E F  A. Specific Tastes of Andre 比赛状态：AC\n\r  题目链接  题目大意 问题描述 定义一个“好数组”：该数组的元素和能被其长度整除。\n 例子：\n$[2,3,1]$是“好数组”——其元素和$6$能被长度$3$整除。\n$[1,1,2,3]$不是“好数组”——其元素和$7$不能被长度$4$整除。\n 读入格式 $T$组数据，每组读入一个长度$n$。\n输出格式 输出任意一个长度为$n$的“好数组”。\n分析 多试试就能知道$[1,1,1,\u0026hellip;]$，\n即全1数组为好数组。\n直接输出即可。\n代码 代码\r#include \u0026lt;bits/stdc++.h\u0026gt;#define MAX 100 using namespace std; int main() { int T,n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n;i++) printf(\u0026#34;%d \u0026#34;, 1); printf(\u0026#34;\\n\u0026#34;); } } \r B. Valerii Against Everyone 比赛状态：AC\n\r  题目链接  题目大意 问题描述 原数组$b_{i}$，令数组$a$，其中$a_{i}=2^{b_{i}}$。\n问：是否存在$l_{1},r_{1},l_{2},r_{2}$\n满足：\n $1 \\le l_{1} \\le r_{1} \\le l_{2} \\le r_{2} \\le n$ $a_{l_{1}}+a_{l_{1}+1}+a_{l_{1}+2}+\u0026hellip;+a_{r_{1}-1}+a_{r_{1}} = a_{l_{2}}+a_{l_{2}+1}+a_{l_{2}+2}+\u0026hellip;+a_{r_{2}-1}+a_{r_{2}}$  即左侧某区间之和等于右侧某区间之和。\n 例子：\n$b_{i}=[4,3,0,1,2,0]$\n则$a$数组：$a_{i}=[16,8,1,2,4,1]$\n当 $l_{1}=1, r_{1}=1, l_{2}=2, r_{2}=6$ 时：\n$(16)=(8+1+2+4+1)$ 故满足题意，为YES。\n 读入格式 $T$组数据。\n第一行一个$n$，代表数组长度；\n第二行分别为$b_{i}$。\n输出格式 如果存在，则输出“YES”，否则输出“NO”。\n分析 因为为$2^i$的这种数，有个特性就是有两个相同的数，才能得到序列的另一个其他的数。\n $1,2,4,8,16,32,\u0026hellip;$\n上面任意两个数相加都不可能得到该序列中的数【在倍增思想中可提现，如ST表。\n任意几个数相加也不可能等于其他几个数相加之和。\n 【严格证明我也不会_(:з」∠)_……\n个人把这个性质称为互斥性。\n因此考虑：\n $b_{i}$数组如果没有两个相同元素出现\n则会因为互斥性的影响，不可能满足条件，则为“NO” $b_{i}$数组存在至少两个相同元素，假设为$b_{i},b_{j}$\n则至少满足条件$l_{1}=r_{1}=i, l_{2}=r_{2}=j$，使得$a_{l_{1}}=b_{l_{2}}$  综上分析：只需要考虑数组中是否存在至少两个相同元素即可。\n 因此实现方法便是：\n先排序，然后从$2$到$n$遍历，如果b[i]==b[i-1]，满足题意输出“YES”，否则输出“NO”。\n代码 代码\r#include \u0026lt;bits/stdc++.h\u0026gt;#define N_MAX 200000 using namespace std; int main() { int T, n, num[N_MAX + 5]; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int flag = 1; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, \u0026amp;num[i]); sort(num + 1, num + n + 1); for (int i = 2; i \u0026lt;= n; i++) if (num[i] == num[i-1]) { flag = 0, printf(\u0026#34;YES\\n\u0026#34;); break; } if (flag) printf(\u0026#34;NO\\n\u0026#34;); } } \r C. Engineer Artem 比赛状态：AC\n\r  题目链接  题目大意 问题描述 一个矩阵，其每个单元能够通过加一或者不变的操作，\n即$b_{i,j}=a_{i,j}$或者$b_{i,j}=a_{i,j}+1$，使得任意相邻两个元素不相等。\n 例子：\n$\\begin{matrix} 1 \u0026amp; 1 \\\\ 3 \u0026amp; 3 \\end{matrix}$\n可经过变换得到：\n$\\begin{matrix} 1 \u0026amp; 2 \\\\ 3 \u0026amp; 4 \\end{matrix}$\n 读入格式 $T$组数据。\n第一行为行和列$n,m$，\n接下来$n$行$m$列读入这个矩阵。\n输出格式 输出经过变换后的这个矩阵。\n个人分析 因为题上说明了答案必存在。\n先想着bfs遍历每个单元，如果与周围单元值相同，就让那个单元格$+1$。\n这里改变了那个单元格后，可能引起那个单元格又不满足条件，所以又要bfs回去。\n类似于贪心的想法，每次确定当前单元格的周围符合条件。\n但贪心就要考虑反悔：有可能这里变为不$+1$反而符合条件。\n所以用个$vis[i][j]$表示是否被$+1$便于反悔。\n个人代码 Pastebin链接\n\r 个人代码\r#include \u0026lt;bits/stdc++.h\u0026gt;#define N_MAX 105 using namespace std; int val[N_MAX + 5][N_MAX + 5], vis[N_MAX + 5][N_MAX + 5], n, m; void bfs(int i, int j) { if (i != 1)\t//越界限定 \tif (val[i - 1][j] != -1)\t//未被赋值限定 \tif (val[i-1][j]==val[i][j]) { if (!vis[i - 1][j])\t//没被访问(+1) \tval[i - 1][j]++, vis[i - 1][j] = 1, bfs(i - 1, j); else\t//被访问了，该-1 \tval[i - 1][j]--, vis[i - 1][j] = 0, bfs(i - 1, j); } if (j != 1) if (val[i][j - 1] != -1) if (val[i][j-1]==val[i][j]) { if (!vis[i][j - 1]) val[i][j - 1]++, vis[i][j - 1] = 1, bfs(i, j - 1); else val[i][j - 1]--, vis[i][j - 1] = 0, bfs(i, j - 1); } if (i != n) if (val[i + 1][j] != -1) if (val[i+1][j]==val[i][j]) { if (!vis[i + 1][j]) val[i + 1][j]++, vis[i + 1][j] = 1, bfs(i + 1, j); else val[i + 1][j]--, vis[i + 1][j] = 0, bfs(i + 1, j); } if (j != m) if (val[i][j + 1] != -1) if (val[i][j+1]==val[i][j]) { if (!vis[i][j + 1]) val[i][j + 1]++, vis[i][j + 1] = 1, bfs(i, j + 1); else val[i][j + 1]--, vis[i][j + 1] = 0, bfs(i, j + 1); } } int main() { int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { memset(val, -1, sizeof(val)); memset(vis, 0, sizeof(vis)); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= m; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;val[i][j]); if (val[i][j] == val[i - 1][j] || val[i][j] == val[i + 1][j] || val[i][j] == val[i][j - 1] || val[i][j] == val[i][j + 1]) { val[i][j]++, vis[i][j] = 1; bfs(i, j); } } for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) printf(\u0026#34;%d \u0026#34;, val[i][j]); printf(\u0026#34;\\n\u0026#34;); } } } \r 题解分析 根据矩阵元素的奇偶性决定是否$+1$。\n因为如果使矩阵满足如下结构，\n则必定保证相邻两个元素奇偶性不同，两元素数也必然不同。 $$\\begin{matrix} odd \u0026amp; even \u0026amp; odd \u0026amp; \u0026hellip; \\\\ even \u0026amp; odd \u0026amp; even \u0026amp; \u0026hellip; \\\\ odd \u0026amp; even \u0026amp; odd \u0026amp; \u0026hellip; \\\\ \u0026hellip; \u0026amp; \u0026hellip; \u0026amp; \u0026hellip; \u0026amp; \u0026hellip; \\end{matrix}$$\n题解代码 题解代码\r#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; int t, n, m, x; int main() { cin \u0026gt;\u0026gt; t; while (t--) { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { cin \u0026gt;\u0026gt; x; if ((i + j + x) % 2)\t//根据i,j（即元素位置）确定该是奇还是偶 \tcout \u0026lt;\u0026lt; x; else cout \u0026lt;\u0026lt; x + 1; cout \u0026lt;\u0026lt; (j == m - 1 ? \u0026#39;\\n\u0026#39; : \u0026#39; \u0026#39;); } } } return 0; } \r D. Powerful Ksenia 比赛状态：未完成（没有时间看题）\n\r  题目链接  题目大意 问题描述 给定$n$个数，每次操作能选择其中三个数$x,y,z$皆变为它们的亦或$x \\oplus y \\oplus z$，问能否进行不超过$n$次操作使这$n$个数均相等。\n读入格式 第一行读入一个$n$，接下来一行读入$n$个数。\n输出格式 输出是否能满足条件：\n 如果能，输出一行YES，并在下一行输出所需的操作数m，在下一行输出m个所分别选择的三个数x,y,z。 如果不能，直接输出一行NO。  题解分析 参考自“哈哈哈哈哈哈”在知乎上的题解。\n\r 首先了解位运算中“三者异或”的基本性质：\n $x \\oplus x \\oplus y = 0 \\oplus y = y$\n即两个相同的数与另一个不同数三者异或，答案为不同的数。加上本题的要求，则三者均会变成相同的数$y$。 对三($n$)者异或，转成二进制后，某一位的$1$的个数的奇偶性不变，如表格所示：    (x,y,z) 1的个数奇偶性 结果 1个数的奇偶性     (0,0,0) 偶（0个） 0 偶（0个）   (0,0,1) 奇（1个） 1 奇（1个）   (0,1,0) 奇（1个） 1 奇（1个）   (0,1,1) 偶（2个） 0 偶（0个）   (1,0,0) 奇（1个） 1 奇（1个）   (1,0,1) 偶（2个） 0 偶（0个）   (1,1,0) 偶（2个） 0 偶（0个）   (1,1,1) 奇（3个） 1 奇（1个）       基于第一性质：如果我们能把数列分为$n$个$2$个相同的数$(x,x)$，最终加上任意一个数$y$，我们便能将该数列变为符合题意的均为$y$数列。\n每经过一次操作后，我们都能得到三个相同的数；而下一次操作如果我们再用上一次操作中的任意一个数，上一次操作便能得到两个相同的数。\n 经过简化：若我们按照$(1,2,\\underline3),(\\underline3,4,\\underline5),(\\underline5,6,7),\u0026hellip;$这样的顺序操作下去，最终便能得到$(x_1,x_1,x_2,x_2,x_3,x_3,\u0026hellip;,x_{n-1},x_{n-1},x_n,x_n,x_n)$这样一个数列。再按照**第一性质**得到结果。\n而要能使用这一种操作，则须满足数列个数为$2*n+1$个，即为**奇数个**。  即：若数列个数为奇数个，则必定可以通过上述操作满足题意。\n 那分析数列个数为偶数个的情况：\n对于最终态分析：\n如果我们能满足题意，即变成个数为偶数个的相同元素$x$的数列：\n对$x$的每一个二进制数位($5_{(10)}$\u0026mdash;\u0026gt;$101_{(2)}$)分析，其每一位$1$的个数必定全是$0$或者为偶数个$1$，即**所有数位$1$的个数均为偶数个**。\n又因为第二性质——异或后某一数位的$1$的个数的奇偶性不变\n对最初态数列的任意一数位假设：\n 如：\n第三位： 0 1 0 1 1 0\n第二位： 0 1 1 0 1 1\n第一位： 1 1 0 0 0 0\n（原数列:1 7 2 4 6 2）\n 令：该数列长度为$2n$。\n  $1$的个数为偶数个： 我们任选一个数$x_i$，将这个数放在最后分析，先操作剩下的$2n-1$个数。\n可知这$2n-1$个数为奇数。\n而对于选中的$x_i$，又有两种情况：\n 该位为$0$：\n则剩下的$2n-1$个数，该为$1$的个数仍为偶数个，但数却有奇数个。\n要达到最后所有数相同的情况（即该位全是$1$或全是$0$），只能最终全部为$0$。\n因此$x_i$的该位与剩下的$2n-1$个数操作后的该位结果相同。\n又因为为任意一数位，故最终$x_i$这个数必须与剩下的$2n-1$个数操作后的数值相同。 该位为$1$：\n则剩下的$2n-1$个数，该为$1$的个数变为奇数个，而数也有奇数个。\n同理，则最终全部为$1$，也相同。  又因为$x_i$也为任选。\n即任意一数$x_i$，其剩下的$2n-1$个数经过异或操作后变为相同数$m$，只有$x_i=m$时，才能满足题意。\n  $1$的个数为奇数个——不成立：\n由第二性质可直接得出矛盾——最初态该数位的$1$的个数(奇数个)与最终态(偶数个)的奇偶性不一致。\n但同理分析，可以得出任意一数$x_i$，其剩下的$2n-1$个数经过异或操作后变为相同数$m$，必定$x_i \\neq m$\n   综上：只有任意一数$x_i$，其剩下的$2n-1$个数经过异或操作后变为相同数$m$，只有$x_i=m$时，才能满足题意。\n  经过简化：若我们仍然按照$(1,2,\\underline3),(\\underline3,4,\\underline5),(\\underline5,6,7),\u0026hellip;$这样的顺序操作下去，\n最终得到$(x_1,x_1,x_2,x_2,x_3,x_3,\u0026hellip;,x_{n-1},x_{n-1},x_n,x_n,x_n,y)$这样一个数列。\n按照奇数个数的操作对前$2n-1$个操作，得到相同值$m$。\n若$m=y$，则一定满足题意，否则一定不满足。\n  即：\n若数列个数为偶数个，将前$2n-1$个变为相同数$m$，只有最后一个数$x_{2n}=m$，才能满足题意。\n题解代码 Pastebin链接\n\r 题解代码\r#include\u0026lt;bits/stdc++.h\u0026gt;using namespace std; const int maxn = 1e5+5; int n; int a[maxn]; void op(int i,int j,int k)\t//异或操作 { a[i] = a[j] = a[k] = a[i]^a[j]^a[k]; } void out(int i,int j,int k) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;k\u0026lt;\u0026lt;endl; } int main() { cin\u0026gt;\u0026gt;n; for(int i = 1;i \u0026lt;= n;++i) cin\u0026gt;\u0026gt;a[i]; int m = (n%2 ? n : n-1); // 如果是偶数，操作前n-1个数  for(int i = 4;i \u0026lt; m;i += 2) op(i-2,i-1,i); // 产生k对相同数  op(m,m-1,1); for(int i = 4;i \u0026lt; m;i += 2) op(i-2,i-1,1); // 选定第一个为最终答案  if(n%2==0 \u0026amp;\u0026amp; a[n]!=a[1]) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; } else { cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;\u0026lt;\u0026lt;m-2\u0026lt;\u0026lt;endl; for(int i = 4;i \u0026lt; m;i += 2) out(i-2,i-1,i); out(m,m-1,1); for(int i = 4;i \u0026lt; m;i += 2) out(i-2,i-1,1); } return 0; } 来自于“哈哈哈哈哈哈”在知乎上的题解。\n\r\r\r E. Yurii Can Do Everything 比赛状态：未完成（没有时间看题）\n\r  题目链接  题目大意 问题描述 给定一个数组a[n]，要求输出满足以下条件的子数组a[l..r]的个数：\n $l+1\\leq r-1$，即子数组长度至少为$3$。 $(a_l \\oplus a_r) = (a_{l+1}+a_{l+2}+\u0026hellip;+a_{r-2}+a_{r-1})$，即两端点异或的值等于中间所有数之和。  读入格式 第一行为数组长度$n$，接下来一行为长度为$n$的数组$a_i$的读入。\n输出格式 输出满足条件子数组个数。\n数据范围  $3\\leq n \\leq 2*10^5$ $1\\leq a_i \\leq 2^{30}$  题解分析 参考自“哈哈哈哈哈哈”在知乎上的题解。\n\r 异或的基本性质的补充：\n  任意两数异或，其结果不可能超过他们最大的二进制数位\n根据异或计算结果：\n $0 \\oplus 0 = 0$\n 最高位往后均为$0$，异或后结果也为0，因此结果的数位不可能超过最高位。\n如：$(3)_{10} \\oplus (6)_{10} = (11)_2\\oplus (110)_2 = (5)_{10}/(101)_2$，位数不可能超过最高位即$3$。\n最大情况为：$(3)_{10}\\oplus (4)_{10} = (11)_2\\oplus (100)_2 = (7)_{10}/(111)_2$\n但异或后的数值不能保证与两原数大小的直接关系，但由于数位可以保证，令两数分别为$x,y$，其二进制位数分别为$m,n$。\n故可确定$x\\oplus y\u0026lt;2^{max(m,n)}$。\n 假设最大为$x=(31)_{10}$，$(x)_2=(11111)_2$，\n则$m=5$，$2^m=(32)_{10}=(100000)_2$\n    这题如果暴力搜索的话，$O(n^2)$TLE。\n但由于以上的性质存在，可以跨级别性剪枝。\n根据以上性质我们可以粗略感觉到一个剪枝条件：\n 当$\\sum_{i=l+1}^{r-1}a_i\\geq 2^{max(m,n)}$时，则证明该区间不满足条件。\n 但如果搭配暴力搜索，假如选定$l$遍历$r$，$max(m,n)$选择的值可能因为$r$的改变而改变，使得无法通过这个条件来中止后续搜索。\n因此我们可以更暴力一点【？】，选定$l$后，我们就假定$max(m,n)$选择的值为$m$，即$l$的位数始终最大。然后向右遍历$r$。\n这样当我们找到不满足条件的情况后，后续的搜索便可以中止。\n可能会问，如果这样选择的区间最大值却是$n$，是否会出现问题？\n但如果最大值选的$n$，则一定满足情况$\\sum_{i=l+1}^{r-1}a_i\\leq 2^m \\leq 2^n$，这个区间也符合条件，不会影响的抬走下一个x……\n但这样的话，可能有区间就是以$n$，即右端点$r$为最大位数，但$2^m\\leq \\sum_{i=l+1}^{r-1}a_i\\leq 2^n$。\n因此我**们再从右向左，选定$r$，令$max(m,n)$选择的是$n$，向左遍历$l$便可解决这种问题**。\n这样肯定能保证不漏，但很明显会重复计算。\n即若有区间满足$\\sum_{i=l+1}^{r-1}a_i\\leq 2^m \\leq 2^n$或$\\sum_{i=l+1}^{r-1}a_i\\leq 2^n \\leq 2^m$，则从左向右和从右向左均满足，会被计算两次。\n故用“Hash+\u0026lt;STL\u0026gt;set”可以去重计数。\n 但为什么这样剪枝能跨级别性剪枝呢！？……\n因为如果要遍历较长的$l\\sim r$，则数列应构造为$1,2,4,8,\u0026hellip;,2^n$【从右向左$r=n$时，就能让$l$取到最左即$l=1$而中间求和仍少于$2^n$。\n这样反而限定了遍历范围为$log_2a_i$，则总复杂度为$O(2nloga_i)$。\n题解代码 Pastebin链接\n\r 题解代码\r#include\u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long ll; const int maxn = 2e5+5; int n; ll a[maxn]; set\u0026lt;ll\u0026gt; st; ll get_max(ll x) { for(ll i = 1LL\u0026lt;\u0026lt;31;i;i \u0026gt;\u0026gt;= 1){ if(i \u0026amp; x)return i\u0026lt;\u0026lt;1; } } int main() { cin\u0026gt;\u0026gt;n; for(int i = 0;i \u0026lt; n;++i)cin\u0026gt;\u0026gt;a[i]; for(int l = 0;l \u0026lt; n-2;++l){ ll s = a[l+1],maxs = get_max(a[l]); for(int r = l+2;r \u0026lt; n;++r){ if((a[l]^a[r]) == s)st.insert((ll)l*maxn+r); if((s+=a[r]) \u0026gt; maxs)break; } } for(int r = n-1;r \u0026gt; 1;--r){ ll s = a[r-1],maxs = get_max(a[r]); for(int l = r-2;l \u0026gt;= 0;--l){ if((a[l]^a[r]) == s)st.insert((ll)l*maxn+r); if((s+=a[l]) \u0026gt; maxs)break; } } cout\u0026lt;\u0026lt;st.size(); return 0; } 来自于“哈哈哈哈哈哈”在知乎上的题解。\n\r\r\r ","date":"2020-11-13T00:00:00Z","image":"https://blog.supersassw.com/p/acm-writeup-2020_11_13/64344151_p0_huf34c6936fd999bfe995d7fe57ee76eb0_1258122_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-writeup-2020_11_13/","title":"ACM比赛总结——Codeforces #682 (Div. 2)……"},{"content":"该笔记还未完成整理，待日后继续整理……\n\r 该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误……\n\r\n排序 不考虑算法  选择排序、冒泡排序、插入排序 $O(n^2)$ 计数排序、基数排序、桶排序 $O(n+w)$ 计数排序\n\r 希尔排序、锦标赛排序  快速排序 应用  寻找第k大的数  归并排序 应用  寻找逆序对\n可见之前笔记。\n（有关逆序对的问题还可以用树状数组或线段树来解决。）  对于逆序对问题的抽象：  询问最少经过几次（可能为相邻元素交换）交换，可使数列有序。   如果限制了为相邻元素交换，最开始很容易想到采用冒泡排序来做，但这样$O(n^2)$很容易TLE……\n发现即便是相邻交换，也是因为存在了逆序对才交换的……\n而每次交换后，能且仅能消除一个逆序对……\n要使序列达到最终有序，则肯定需要消除全部逆序对……\n故此类题目仍为求逆序对，且答案就为逆序对个数……\n 如果没有限制相邻元素交换，那么处理一位数，就能消除这位数的所有逆序对个数（与相邻交换的区别）\n所以就变成了找存在逆序对的位（简称：逆位）的个数。\n  模板题：\nP1908 逆序对  本地代码+题目分析+归并排序讲解+WA记录\n     总应用  贪心中的邻项交换排序  例题  P1774 最接近神的人  考点：归并排序、逆序对\n本地代码+题目分析+WA记录\n  SWJTU OJ-12.13 F XCPC  考点：归并排序、逆序对（没有相邻元素交换）\n题目分析\n   ","date":"2020-11-12T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-sort/86036732_p0_hud48aef1ba1119480544a4ab4b9f32654_3422651_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-sort/","title":"ACM学习笔记——排序……"},{"content":"该笔记还未完成整理，待日后继续整理……\n\r 该笔记目前直接复制的之前的笔记，还未调整格式。页面格式、内容、链接等可能存在混乱错误……\n\r\n最短路问题 就是求图中一源点到其他点的最短路径。（也可能为所有点到其他点的最短路径）\n算法 Floyd 算法 待补充……\nBellman-Ford 算法 一种基于松弛（relax）操作的最短路算法。\n一般不会写，了解就行，要用主要还是用SPFA。\n以下都基于有最短路情况讨论（即没有负环）。\n符号定义  $N$——节点个数 $M$——边个数 $S$——源点 $dist[v]$——源点$S$到点$v$的当前距离 $ralax(u,v)$——以$u$为中继点，判断经过此中继点到点$v$的距离是否更短，如是则覆盖$dist[v]$  操作  先对dist赋初值，对于$S=0$，对于其他点为$dist=∞$。 每次遍历所有的边，并对其进行$relax$操作。 直到没有松弛操作成功，证明已经找到全局最短路，退出循环。  动态演示：图解贝尔曼-福特算法\n分析 由于一次松弛操作会使最短路的边数至少$+1$（考虑极端情况为链）\n而最短路的边数最多为$n-1$。（即源点与每个点都链接）\n所以最多执行$n-1$次松弛操作，即最多循环$n-1$次。\n伪代码 for (i = 1 -\u0026gt; N) dist[i]=INF, dist[S]=0;\t//初始化dist  for (i = 1 -\u0026gt; N-1)\t//最多执行N-1次全局松弛 \tfor (ALL edge) relax(edge.s, edge.e);\t//遍历每条边  relax(u, v) { dist[v] = min(dist[v], dist[u]+edge_len(u, v)); } 时间复杂度 $O(NM)$（不理解可以看上方动态演示）\n额外应用  判断是否存在负环  跑Bellman-Ford算法，如果在$n-1$次之内求得最短路算法结束，则不存在负环，反之一定存在。\n   优化  当某次全局松弛时，并没有松弛操作成功（没有松弛），证明已经找到所有最短路，可以break。 用队列优化，即SPFA算法。  SPFA 算法 实际上为采用队列的Bellman-Ford算法，但一般要用就用这个。\n而且判断负环方式稍有不同。【故单独写出来祭奠一下x……\n额外符号定义  $que[]$——存被松驰过的点的队列 $in_queue[u]$——u点是否在松弛队列里  分析 很多时候我们并不需要那么多无用的松弛操作。\n很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。\n那么我们用队列来维护“哪些结点可能会引起松弛操作”，就能只访问必要的边了。\n即使用队列，将松弛的点push进来，基于此点松弛完后再pop出去。\n形式上与BFS非常相似。\n不同点为：\n BFS中一个点出队了后不会再重新进入序列。（因为搜索会把当前最优解搜索出来） SPFA一个点可能在出队后再次进入队列。（因为当前relax的可能会被别的relax再找到较短路。也就是说一个点修改过其他点后，过了一段时间可能会由其他点获得更短路劲，于是又可以用来修改其他点，这样反复循环。即是为接近最优解而非直接到达）  伪代码 que.push(S); in_queue[S] = true; while (!q.empty()) { u = q.pop(); in_queue[u] = false; for (ALL edge(u---\u0026gt;v))\t//遍历u的所有边 \tif (!in_queue[v]) { relax(u,v); q.push(v); in_queue[v] = true; } } 时间复杂度 期望：$O(KE)$（$K$为常数，平均值为$2$；$E$为边数）\n最坏：$O(NM)$\n仅为Bellman-Ford的优化，极端情况退化成Bellman-Ford。\n应用——判断负环  BFS1：松弛次数大于n-1。\n部分代码 BFS2：入队次数大于n-1。\n部分代码  以上两者代码极其相近(就调整了个顺序),区别在于按入队次数判断虽然慢（cnt增加的慢）,但更稳（可能存在重边导致了多次松弛）。\n  BFS3：起点到一个点的经过边数大于n-1。\n部分代码  这个方法较好【？……\n  DFS：遇到在栈内的节点。\n部分代码  DFS版对于随机数据来说具有较为优秀的表现，但是会被构造数据卡成指数级别的复杂度。【来自洛谷@vectorwyx】\n   有关两大类方法的疑问见：关于DFS版本的SPFA判负环\n注意事项 SPFA很可能被针对卡常数，导致TLE……\n故如果没有负环存在，请用Dijkstra……\n算法对比    Floyd Bellman-Ford Dijkstra Johnson     每对结点之间的最短路 单源最短路 单源最短路 每对结点之间的最短路   没有负环的图 任意图（可以判定负环是否存在） 非负权图 没有负环的图   $O(N^3)$ $O(NM)$ $O(M\\log M)$ $O(NM\\log M)$    Dijkstra和Floyed是不断的试点。Dijkstra试最优点，Floyed试所有点。\nBellman-Ford和SPFA是不断的试边。Bellman-Ford是盲目的试所有边，SPFA只试那些有利用价值的点的边。\n总结 如果是非负权图，求单源最短路请用Dijkstra，否则很容易卡常导致TLE…… 除非要判定负环，或报告最短路不存在，才用SPFA……\n例题  P3125 Bessie\u0026rsquo;s Birthday Buffet S  考点：图上动规、最短路\n本地代码+题目分析+SPFA讲解+WA记录+参考题解\n   ","date":"2020-11-12T00:00:00Z","image":"https://blog.supersassw.com/p/acm-note-shortest_path/Yande-298884_hu402752953fd669a3c7e7255c09a0516f_1637023_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-note-shortest_path/","title":"ACM学习笔记——最短路……"},{"content":"题目链接 P4838 P哥破解密码\n\r 题目分析  考点：矩阵动规……  典例：斐波拉契数列……   方法：矩阵快速幂……  标准动规思想，每个次序有三个决策，分别为选$1$个$A$，选$2$个$A$，选$B$……\n$f[i][A_1] = f[i-1][B]$\n$f[i][A_2] = f[i-1][A_1]$\n$f[i][B] = f[i-1][A_1] + f[i-1][A_2] + f[i-1][B]$\n最后输出：$f[n][A_1] + f[n][A_2] + f[n][B]$\n但直接动规求会TLE，发现满足矩阵动规性质，则采用动规优化——矩阵动规……\n矩阵动规讲解  见笔记「ACM学习笔记——矩阵……」中的“矩阵加速递推”。  个人代码 Pastebin链接\n\r //P4838 [P哥破解密码](https://www.luogu.com.cn/problem/P4838) #include \u0026lt;bits/stdc++.h\u0026gt; //#define MAX 10000000\t//dp中的状态存储图表最大大小（历史遗留垃圾x…… #define matrix_MAX 3 #define MOD 19260817  using namespace std; struct typeMatrix { long long mat[matrix_MAX + 1][matrix_MAX + 1] = {}; int x, y; typeMatrix(int x, int y) : x(x), y(y) {} inline typeMatrix operator*(const typeMatrix \u0026amp;a) const //矩阵乘法实现//第一个const Type \u0026amp;a用来直接传地址并防止修改，节约空间；第二个const防止修改结构体内其他变量 \t{ typeMatrix res(x, a.y); for (int i = 1; i \u0026lt;= x; i++) //矩阵a(x1,y1);b(x2,y2)，新矩阵为res(x1,y2)，做y1(或x2)次乘法累加 \tfor (int j = 1; j \u0026lt;= a.y; j++) for (int k = 1; k \u0026lt;= y; k++) res.mat[i][j] = (res.mat[i][j] + mat[i][k] * a.mat[k][j]) % MOD; //就矩阵乘法 \treturn res; } void initPowAns(int size) { for (int i = 1; i \u0026lt;= size; i++) mat[i][i] = 1; //注意标准快速幂中初始化为令ans=1，换成矩阵中初始化为令主对角线为1…… \t} inline typeMatrix operator^(int power) const //快速幂实现 \t{ typeMatrix ans(y, y), base = *this; ans.initPowAns(y); //见上面分析：递推矩阵大小为y*y \twhile (power) { if (power \u0026amp; 1) ans = ans * base; base = base * base; power \u0026gt;\u0026gt;= 1; } return ans; } } Matrix(2, 3), fx(3, 3); //Matrix状态矩阵，fx递推矩阵 int main() { int T, n; Matrix.mat[1][1] = 1, Matrix.mat[1][3] = 1;\t//设置状态矩阵 \tfx.mat[1][2] = fx.mat[1][3] = fx.mat[2][3] = fx.mat[3][1] = fx.mat[3][3] = 1; //设置递推矩阵 \tscanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); typeMatrix ans = Matrix * (fx ^ (n - 1)); printf(\u0026#34;%lld\\n\u0026#34;, (ans.mat[1][1] + ans.mat[1][2] + ans.mat[1][3]) % MOD); } } \r附：初始代码——基础动规方法\rstruct dp { long long A_1, A_2, B; } dp[MAX]; void init() { memset(dp, -1, sizeof(dp)); dp[1].A_1 = 1, dp[1].A_2 = 0, dp[1].B = 1; } long long dpSearch(int top, int cmd) { if (cmd == 1) return (dp[top].A_1 != -1) ? dp[top].A_1 : dp[top].A_1 = dpSearch(top - 1, 3) % 19260817; if (cmd == 2) return (dp[top].A_2 != -1) ? dp[top].A_2 : dp[top].A_2 = dpSearch(top - 1, 1) % 19260817; return (dp[top].B != -1) ? dp[top].B : dp[top].B = (dpSearch(top - 1, 1) + dpSearch(top - 1, 2) + dpSearch(top - 1, 3)) % 19260817; } int main() { int T, n; init(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); printf(\u0026#34;%lld\\n\u0026#34;, (dpSearch(n, 1) + dpSearch(n, 2) + dpSearch(n, 3)) % 19260817); } return 0; } 初始代码分析 最开始整体的动规思路是正确的，并且正确的求出了具体的状态转移方程……\n但首先，动规从开始到结束直接求出来，是$O(n)$的复杂度，要TLE……\n考虑动规的优化之一——矩阵DP+快速矩阵幂……\n同时即便用基本的动规，个人实现方法中也有两个问题……\n 计算动规采用的递归，虽然思路好想，但容易栈溢出且更耗时……\n故应该在用递归方式想出dp思路后，再改用递推（顺推）来计算…… 对于较少的询问，不必用表将计算出的解存储下来，直接计算即可……  \r ","date":"2020-11-10T00:00:00Z","image":"https://blog.supersassw.com/p/acm-prac-2020_11_10/pixiv61483143_hudb8b3bdf2d089baf7c03e9c67779ccab_1896816_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-prac-2020_11_10/","title":"ACM练习——P4838 P哥破解密码……"},{"content":"题目链接 P2191 小Z的情书\n\r 题目分析 一般的模拟题……\n模拟方阵顺时针转置……\n公式：(x,y)\u0026mdash;\u0026gt;(y,N-x+1)……\n推出这个就行……\n个人代码 Pastebin链接\n\r //P2191 [小Z的情书](https://www.luogu.com.cn/problem/P2191) #include \u0026lt;bits/stdc++.h\u0026gt; #define MAX (1000 + 5)  #define node_MAX MAX *MAX #define printX node[i].x #define printY node[i].y using namespace std; int N, nodeNum = 0; struct typeNode { int x, y; } node[node_MAX]; void rotate() //转置操作…… { for (int i = 1; i \u0026lt;= nodeNum; i++) { int tmp = node[i].x; node[i].x = node[i].y, node[i].y = N - tmp + 1; } } int cmp(typeNode node1, typeNode node2) { return node1.x \u0026gt; node2.x ? 0 : (node1.x == node2.x ? node1.y \u0026lt; node2.y : 1); } int main() { int times = 4; char letter[MAX][MAX], t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;N); for (int i = 1; i \u0026lt;= N; i++) for (int j = 1; j \u0026lt;= N; j++) { t = getchar(); while (t != \u0026#39;#\u0026#39; \u0026amp;\u0026amp; t != \u0026#39;O\u0026#39;) t = getchar(); t == \u0026#39;O\u0026#39; ? node[++nodeNum].x = i, node[nodeNum].y = j : 0; } for (int i = 1; i \u0026lt;= N; i++) for (int j = 1; j \u0026lt;= N; j++) { t = getchar(); while (t \u0026lt; \u0026#39;A\u0026#39; || t \u0026gt; \u0026#39;Z\u0026#39;) t = getchar(); letter[i][j] = t; } while (times--) //times=4，四次操作 \t{ for (int i = 1; i \u0026lt;= nodeNum; i++) printf(\u0026#34;%c\u0026#34;, letter[printX][printY]); rotate(); sort(node + 1, node + nodeNum + 1, cmp); //优化常数：存的只是符合输出的点，并非从头到尾遍历。因此转置后需要按输出顺序排序…… \t} } ","date":"2020-11-09T00:00:00Z","image":"https://blog.supersassw.com/p/acm-prac-2020_11_09/66020781_p0_hu83615bf817a735cca528325790529168_964835_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-prac-2020_11_09/","title":"ACM练习——P2191 小Z的情书……"},{"content":"题目链接 P1766 液体滴落\n\r 题目分析 一道模拟题……\n数据范围虽然很大，但仍可暴力O(n^2)得出……\n每次遍历线段，如果Ⅰ满足滴落条件，则Ⅱ判断是否为当前能滴落到的线段的最高那一个，\n遍历完后如果找到top则更新状态，找不到top == -1则输出当前$x$值……\n个人代码 Pastebin链接\n\r //P1766 [液体滴落](https://www.luogu.com.cn/problem/P1766) #include \u0026lt;bits/stdc++.h\u0026gt; #define MAX 100005  #define high_MAX (10e9 + 5) using namespace std; struct typeSegment { long long stX, stY, edX, edY; double k, b; void init() { long long tmp; k = 1.0 * (edY - stY) / (edX - stX); b = stY - k * stX; if (stX \u0026gt; edX) //(WA. 1)这里需注意在init中需对stX和edX进行判断，如果stX大则要swap，否则在checkInside会出错。  tmp = stX, stX = edX, edX = tmp, tmp = stY, stY = edY, edY = tmp; } bool checkInside(int x) //Ⅰ——判断是否满足滴落条件。  { return (stX \u0026lt; x \u0026amp;\u0026amp; x \u0026lt; edX); } double hDrop(int x) //利用直线的解析式，即k和b来计算落到当前线段会落到哪（哪个y值）。  { return k * x + b; } void dropTo(long long *x, long long *y) //更新状态  { if (stY \u0026gt; edY) *x = edX, *y = edY; else *x = stX, *y = stY; } } segment[MAX]; int main() { long long n, xNow; scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;xNow); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%lld%lld%lld%lld\u0026#34;, \u0026amp;segment[i].stX, \u0026amp;segment[i].stY, \u0026amp;segment[i].edX, \u0026amp;segment[i].edY); segment[i].init(); } long long hNow = high_MAX; //刚开始令为从无穷高处掉落。  while (1) { double hUp = -high_MAX, hDrop; //需要用个hUp，来存能掉落到最高的线段的掉落点高度。  long long top = -1; for (int i = 1; i \u0026lt;= n; i++) if (segment[i].checkInside(xNow)) //Ⅰ——满足掉落条件。即在线段横坐标里面。  if ((hDrop = segment[i].hDrop(xNow)) \u0026gt; hUp \u0026amp;\u0026amp; hNow \u0026gt;= hDrop) //(WA. 2)第一个判断：判断这个掉点是否是最高的，因为只能掉到最高那个线段。第二个判断：掉点是否在当前高度下，注意为掉点。  top = i, hUp = hDrop; if (top != -1) segment[top].dropTo(\u0026amp;xNow, \u0026amp;hNow); else return printf(\u0026#34;%lld\u0026#34;, xNow), 0; } return 0; } WA记录 第一次 checkInside直接用的stX \u0026lt; x \u0026lt; edX，但会存在stX \u0026gt; edX的情况……\n故要在init中判断这种情况并swap……\n第二次 这里之前第二个判断写的为：hNow \u0026gt; (segment[i].edY\u0026lt;segment[i].stY ? segment[i].edY : segment[i].stY)……\n也就是拿这条线段的最低端点判断……\n但对于如下情况：\n↓ \\ / \\ / \\ / X / \\ / 这样的话掉落完第一条线段到右侧后，hNow确实大于第二条线段最低点，故使答案错误……\n","date":"2020-11-08T00:00:00Z","image":"https://blog.supersassw.com/p/acm-prac-2020_11_08/76654594_p0_hu5438825b9b6d1014226d20d231e650c2_2658383_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.supersassw.com/p/acm-prac-2020_11_08/","title":"ACM练习——P1766 液体滴落……"},{"content":"该总结还暂未完成，待日后继续总结……\n\r 比赛链接 SWJTU Online Judge\n\r 题解文件 点击下载：月赛决赛.7z\n\r 总结范围  A C D E G H J K  注：前面带*号的题因题目简单，为简略总结。\n\r  其余题目均因时间原因暂未总结。  \r A - 排队 比赛情况：WA\n\r 题面搬运  题目链接  题面搬运\r题目描述 世界任务：是芭芭拉还是⑨⑨拉\n班尼特又误伤了自己，现在$n$个班尼特正找芭芭拉治疗。\n对于每个班尼特，芭芭拉需要给他补血$h_i$，然后获得一个价值$v_i$的圣遗物。\n治疗每一个班尼特都会获得一个收益，治疗第$i$个班尼特的收益$w_i$等于前面治疗的所有班尼特的$v$之和减去$h_i$。\n芭芭拉想让治疗每个班尼特收益的最小值最大。\n也就是说，请重新给班尼特排队，要求是最大化$\\min_{i=1}^n{-h_i+\\sum_{j=1}^i v_j}$ ，并输出这个值。\n芭芭拉并不擅长数学，因此请身为骑士团荣誉骑士的你帮帮她吧。\n任务奖励：10个原石，角色芭芭拉，以及月赛增加一个AC\n数据范围 $1 \\le n \\le 10^5$\n$1 \\le h_i,v_i \\le 10^4$\n输入格式 第一行有一个整数$n$。\n接下来有$n$行，每行有两个数字$h$,$v$，代表这个班尼特的补血量和圣遗物。\n输出格式 一行，只有一个整数，代表所有最小值中的最大值。\n样例数据 第一组 输入 3 100 200 300 500 400 700 输出 300 \r解释：\n若顺序为($100,200)(300,500)(400,700)$，则收益为$100,400,1000$，最小收益为$100$。\n若顺序为$(300,500)(100,200)(400,700)$，则收益为$200,600,1000$，最小收益为$200$。\n若顺序为$(400,700)(100,200)(300,500)$，则收益为$300,600,1100$，最小收益为$300$。\n还有其它顺序，但最小收益不会超过$300$，因此答案为$300$。\n\r 标准思路  算法点：贪心——邻项交换排序\n它把决定相邻两个元素先后的决策推广到整个序列，从而获得最优解。  这个题本身就是通过给数据排序，不同的排序方法会有不同的收益最小值，然后要比较所有排序方法，选让这个收益最值最大那种方法……\n所以排序的话我们就每次选两个人比较，标记为$i$和$j$……\n然后这两个人又有两种情况，要不就是$i$站在$j$前面，要不就是$j$站在$i$前面……\n这两种情况分别会有个当前两个人的收益最小值，如果目前这种方法（$i$站在$j$前面）的这个最值小于后者方法（$j$站在$i$前面），那肯定我就选后者，让收益最大化，就让他们交换顺序……\n就相当于把比较时候的最值看成短板，每次比较一次选最高的那个，就会把短板提上去一点，这样最后得到的就是最高的短板……\n用公式来说的话就是$\\text{if} \\quad (\\min(Wi_1,Wj_1) \u0026lt; \\min(Wi_2,Wj_2)) \\quad \\text{swap}((h,v)_i,(h,v)_j)$……\n最终分析得知就是if (vi-hi \u0026lt; vj-hj) swap(i,j);……\n有关“邻项交换排序”的详细介绍可以查看我的笔记「ACM学习笔记——邻项比较排序……」。\n\r 标程代码 Pastebin链接\n\r 标程代码\r//理解了就很简单，就不给标程加注释了…… #include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; const int N = 100010; struct Data { int h, v; bool operator\u0026lt;(const Data \u0026amp;t) { return v - h \u0026gt; t.v - t.h; } }; int n; Data d[N]; int main() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;d[i].h, \u0026amp;d[i].v); sort(d + 1, d + n + 1); int tmp = 0, res = 1e9; for (int i = 1; i \u0026lt;= n; ++i) { tmp += d[i].v; res = min(res, tmp - d[i].h); } printf(\u0026#34;%d\\n\u0026#34;, res); return 0; } \r ","date":"2020-10-31T00:00:00Z","image":"https://blog.supersassw.com/p/acm-writeup-2020_10_31/87698192_p0_hu8e7e420eeb9b421e908212b9c71edf3f_2179230_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-writeup-2020_10_31/","title":"ACM比赛总结——2020年 校十月月赛（决赛）"},{"content":"比赛链接 SWJTU Online Judge\n\r 题解文件 点击下载：月赛题解（预赛）.zip\n\r 总结范围  *A *C D E *G H J K  注：前面带*号的题因题目简单，为简略总结。\n\r  D、E因简单而未总结。 J因时间原因暂未总结。  \r *A - 落单水禽  题目链接  比赛情况：WA\n\r 个人方法 利用map映射，找到只出现一次的。\nWA原因：\n字符串操作问题。\n使用resize和scanf读入的时候，\n需注意重新读入时不会删去之前的字符串！\n 如第一次读入了个2333331919，之后又用这个字符串读了个114514，\n则新的字符串是1145151919。\n \r 标准思路 采用位运算。\n$2n+1$个数中，其中只有$1$个数只出现了奇数次，\n则对所有数进行异或，则可找出出现奇数次的数。\n*C - 新概念丢手绢  题目链接  比赛情况：未完成（看过题目不知道方法）\n\r 不难的题，没去认真思考。\n思考后会发现：按$1,2, \\cdots ,n$这样排列，就是最高分，即输出$n$。\n*G - 生活委员  题目链接  比赛情况：AC\n\r  知识点：$\\gcd(Fib(a), Fib(b)) = Fib(\\gcd(a, b))$  H - 胖生的数学题 比赛情况：未完成（看过题目不知道方法）\n\r  题目链接  题面搬运 题面搬运\r题目描述  连乘符号：$\\prod_{i=a}^bn=n_a*n_{a+1}*\\cdots*n_{b-1}*n_b$  最近，小胖生学习了一个新的东西：GCD，他发现GCD真是一个神奇的东西，今天，老师给他布置了一道关于GCD的题，他很快就算出来了，因此，为了寻找优越感，他想考考你，看你会不会。\n题目如下：\n输入一行包含六个正整数$a,b,c,d,x,y$,求$\\prod_{i=a}^{b}\\prod_{j=c}^{d}\\gcd(x^{i},y^{j}) \\mod 998244353$。\n注：这里$\\gcd(a,b)$表示a和b的最大公约数。\n 题目理解补充：\n这里两个连乘符号代表的是分别乘$\\gcd(x^{a\\sim b},y^{c\\sim d})$。  如：\n$a=1,b=2$；$c=3,d=4$\n则为：$\\gcd(x^1,y^3)\\gcd(x^1,y^4)\\gcd(x^2,y^3)*\\gcd(x^2,y^4)$\n   数据范围 $0 \\le a,b,c,d \\le 3e6$\n$a \\le b$\n$c \\le d$\n$0\u0026lt;x,y \\le 1e9$\n输入格式 一行，包含六个正整数。\n输出格式 一行，计算得到的结果。\n样例数据 第一组 输入 1 2 1 2 8 4 输出 2048 \r第二组 输入 1 2 3 4 120 180 输出 235140177 \r解释：\n$\\gcd(120^1,180^3)=120$\n$\\gcd(120^1,180^4)=120$\n$\\gcd(120^2,180^3)=14400$\n$\\gcd(120^2,180^3)=14400$\n$\\prod_{i=1}^{2}\\prod_{j=3}^{4}\\gcd(x^{i},y^{j})=2985984000000$\n$2985984000000 \\mod 998244353=235140177$\n\r 标准思路 暴力的话两个for，$O(n^2)$，而$a,b \\le 3e6$，会超时。\n看到求gcd，就应该尝试对给出的数分解质因数。\n\r 引自：标准题解\n回到求$\\gcd$的本质：\n $\\gcd$，为求两个数的最大公约数（因数）。\n故可将两个数分别分解质因数，然后寻找两数所有共同的质因数，则结果为两数共同质因数的乘积。\n 如：\n$\\gcd(120,180)$：\n$120=\\underline{2} \\times \\underline{2} \\times 2 \\times \\underline{3} \\times \\underline{5}$\n$180=\\underline{2} \\times \\underline{2} \\times \\underline{3} \\times \\underline{5} \\times 5$\n则$\\gcd(120,180)=2\\times2\\times3\\times5=60$。\n  由于这里为多项$\\gcd$的连乘，又由上述可知本身$\\gcd$的运算就为乘积运算，\n故总的运算就可以写为各个项共同质因数的总乘积。\n我们又可以从本质中发现，我们所取的每项质因数的次数，都是两数中出现次数较少的次数，以下统称为最小次数。\n 如上例中对$2$这个质因数所取次数：\n$120$有$3$个$2$，\n$180$有$2$个$2$。\n则$\\gcd(120,180)$有关$2$这一项则取$2$个。（$\\gcd(120,180)=2\\times2\\times\\cdots$）\n 而有关幂操作，就相当于对于每项质因数的次数进行幂操作。\n 例：\n$180^3=2^{2^{\\underline{3}}}\\times3^{2^{\\underline{3}}}\\times5^{1^{\\underline{3}}}$\n 综上：\n对于原题两个数的某范围中的幂，分别求$\\gcd$，\n可以转换为两数共同质因数，其每一项在其范围中的幂，取两者最小次数为该次运算的结果。\n所有最小次数之和即为这一项的幂次，幂出来就是这一项质因数所求得的最小公约数。\n然后所有项的最小公约数之积就是最终结果。\n 然后对于怎么取最小次数的问题：\n假设当前共同质因数为base。\n  对于第一个数的base个数确定：\n先确定一个$i∈[a,b]$，则当前第一个数的base个数为$x*i$。\n然后计算出来一个界点min。（由于这里幂是整数，所以我们暂对min向下取整）\n  对于第二个数的base个数分析：\n$y * c \\sim y * d$中任意一个$y*k\\quad (k∈[c,d])$\n 当$k \\le$min时，$x * i \\ge y * k$，则这个时候$\\gcd$取$y * k$ 当$k\u0026gt;$min时，$x * i \u0026lt; y * k$，则这个时候$\\gcd$取$x * i$    【也可以用向上取整，但会更难想。\nmin计算方法：\n $min = ⌊x * i / y⌋$。（程序里直接写min = x*i/y）  sum计算方法：\n 当$k∈[c,min]$，$sum+=y * k$（条件：$min \u0026gt;= c$）。\n则这部分区间的总和为：$sum+=y * sum(k)$（可算得$sum(k)=(c + min) * (min-c+1)/2）$。 当$k∈(min,d]$，$sum+=x * i$（条件：$min \u0026lt; d$）。\n则这部分区间的总和为：$sum+=x * i * len(k)$（可算得$len(k) = d - min$）。\n【但因为$min=d$时，$len(k) = 0$，所以条件也可写为$min \\le d$】   所以我们可以先将两个原数分别分解质因数。\n然后对每个共同的质因数项讨论其幂次。\n对于任一项质因数，选一个原数for遍历其幂次，\n则对另一个原数，便可直接用上述的min确定选择最小次数的其区间临界点，直接可求得其不同幂次的每次的结果。\n故可将两个for的$O(n^2)$时间复杂度降下一层来为$O(n)$。\n 需要注意的点：\n选好最小次数后求和时，如果要对幂次取模，\n按照欧拉/费马小定理，模数应该取$\\varphi (998244353)$（为欧拉函数）。\n欧拉函数讲解。\n标程代码 Pastebin链接\n\r 标程代码（附个人注释）\r#include \u0026lt;cstdio\u0026gt;#include \u0026lt;unordered_map\u0026gt; const long long MOD = 998244353; long long q_pow(long long base, long long idx) //带取模的快速幂 { long long answer = 1; while (idx) { if (idx \u0026amp; 1) { answer = answer * base % MOD; } base = base * base % MOD; idx \u0026gt;\u0026gt;= 1; } return answer; } long long a, b, c, d; long long calc(long long x, long long y, long long base) { long long sum = 0; //求算出来最终的幂  for (long long i = a; i \u0026lt;= b; ++i) { long long min = x * i / y; //使得y*k \u0026gt; x*i的最小值  /*有关min用法： 【相应的分析放到了“题目分析”里】 */ if (min \u0026gt; d) //这里的处理方式是，如果bound \u0026gt; d，则不存在k∈(mid,d]的区间，直接令min=d，使得后面加这个区间时len(k)=0---\u0026gt;sum+=0。  min = d; else if (min \u0026lt; c) //同理，如果min \u0026lt; c，则不存在k∈[c,min]的区间，直接令min=c-1，使得后面加这个区间时sum(k)=0---\u0026gt;sum+=0。  min = c - 1; sum = (sum + (y * (c + min) * (min - c + 1) / 2)) % (MOD - 1); //对应k∈[c,min]情况  sum = (sum + x * i * (d - min)) % (MOD - 1); //对应k∈(min,d]情况  /* % (MOD - 1)的原因： 这里是数论里的欧拉函数应用 */ } long long res = q_pow((long long)base, sum); return res; } int main() { long long x, y; scanf(\u0026#34;%lld %lld %lld %lld %lld %lld\u0026#34;, \u0026amp;a, \u0026amp;b, \u0026amp;c, \u0026amp;d, \u0026amp;x, \u0026amp;y); std::unordered_map\u0026lt;long long, long long\u0026gt; factor_nums; for (long long i = 2; i * i \u0026lt;= x; ++i) //分解x的质因数  { while (x % i == 0) { ++factor_nums[i]; x /= i; } } if (x \u0026gt; 1) ++factor_nums[x]; long long answer = 1; for (long long i = 2; i * i \u0026lt;= y; ++i) //对y按顺序分解质因数  { if (y % i == 0) { long long count = 0; do { ++count; y /= i; } while (y % i == 0); if (factor_nums[i]) answer = answer * calc(factor_nums[i], count, i) % MOD; } } if (y \u0026gt; 1 \u0026amp;\u0026amp; factor_nums[y]) //y剩下的  answer = answer * calc(factor_nums[y], 1, y) % MOD; printf(\u0026#34;%lld\\n\u0026#34;, answer); return 0; } \r K 比赛情况：WA\n\r  题目链接  题面搬运 题面搬运\r题目描述 有$L$个方块排成一排，从左到右标记为$1,\\cdots,L$\n$L$个方块上站了$n$个人，从左到右标记为$1,\\cdots,n$。第$i$个人站在第$a_i$个方块上\n你可以做以下操作任意次：\n选择一个人，令他向左或向右移动。这个人会一直移动直到前方没有空的格子。也就是说，当前方没有格子或前方的格子上有人时他才会停止移动。\n举个例子，假设$n=3,L=10$，$n$个人一开始在$(2,3,7)$。现在我们让第$2$个人向右走，他会走到$6$停止，如果我们让第$3$个人往右走，他会走到最右侧$10$停止。\n你的任务是使第$i$个人到达$b_i$位置，判定是否可行并找到最少操作次数。\n数据范围 $1 \\le N \\le 10^5$\n$N \\le L \\le 10^9$\n$1 \\le A_1 \\lt A_2 \\lt \\cdots \\lt A_N \\le L$\n$1 \\le B_1 \\lt B_2 \\lt \\cdots \\lt B_N \\le L$\n 所有输入均为整数。  输入格式  $N \\quad L$\n$A_1 \\quad A_2 \\quad\\cdots \\quad A_N$\n$B_1 \\quad B_2 \\quad\\cdots \\quad B_N$\n 输出格式 如果目标不可达，输出-1，否则输出最小指令数。\n样例数据 第一组 输入 4 11 3 4 6 10 1 5 6 11 输出 3 \r第二组 输入 1 3 1 2 输出 -1 \r\r 个人方法 就是想的纯模拟，交上去后WA……\n之后对拍发现几处修改和WA点，现在不知道改正后是否正确_(:з」∠)_反正先贴上来……\n【WA点已经写在代码里了……\nPastebin链接\n\r 个人代码\r#include \u0026lt;bits/stdc++.h\u0026gt;#define Length 100005 #define to_Left toLoc - 1 #define to_Right toLoc + 1 using namespace std; int start[Length], to[Length], current[Length] = {0}, n, l, sum = 0; int check(int topPrime, int top, int toLoc) { if (current[top] \u0026amp;\u0026amp; to[top] == toLoc) return 0; /* FIX\u0026amp;WA FIX.1. 经过已经到达了要去的点，应该直接返回0。 WA.2. 第一次改没加to[top]==toLoc，可能在之后的使用中要去的点不是本要去的点，但却在之前current=1 */ if (toLoc \u0026lt; start[top]) //左移  { if (top == 1) //最左边的节点  { if (toLoc == 1) //去左墙  { if (toLoc == to[top]) //如果恰好是要去的地方，把current=1  current[top] = 1; return 1; } else return -1; } else //不是最左边的  { if (topPrime == top - 1) //反复横跳了  return -1; int checkToLeft = check(top, top - 1, to_Left); //左边那个，能否去要去点的左边  if (checkToLeft != -1) { if (toLoc == to[top]) current[top] = 1; //如果恰好是要去的地方，把current=1  return checkToLeft + 1; } else return -1; } } else if (toLoc \u0026gt; start[top]) //右移  { if (top == n) //最右边的节点  { if (toLoc == l) //去右墙  { if (toLoc == to[top]) current[top] = 1; //如果恰好是要去的地方，把current=1  return 1; } else return -1; } else //不是最右边的  { if (topPrime == top + 1) //反复横跳了  return -1; int checkToLeft = check(top, top + 1, to_Right); //右边那个，能否去要去点的右边  if (checkToLeft != -1) { if (toLoc == to[top]) current[top] = 1; //如果恰好是要去的地方，把current=1  return checkToLeft + 1; } else return -1; } } else //不移动  { if (toLoc == to[top]) /* WA WA.3. 有可能这步要让他在原地不动，但不是他最终要去的地方，故这个判断很重要！ */ current[top] = 1; /* WA WA.1. 不移动的时候要改current=1 */ return 0; } } signed main() { #ifdef SuperSASS  freopen(\u0026#34;data.in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif  scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;l); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, start + i); for (int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%d\u0026#34;, to + i); for (int i = 1; i \u0026lt;= n; i++) //从左到右check。  if (!current[i]) //如果在某次操作中已经到达最终位置，便不再计算  { int value = check(i, i, to[i]); if (value == -1) { printf(\u0026#34;-1\u0026#34;); return 0; } else sum += value; } printf(\u0026#34;%d\u0026#34;, sum); return 0; } \r 标准思路 区间上节点移动问题，可以转换为区间合并问题。\n\r  比如：\n$L=6$，点为$2,5$，转换为区间长为$1,2,1$。\n如要把$2$向左移，即区间长变为$3(1+2),0,1$。\n 考虑两个人之间的空位，记为$x_1,x_2,x_3,\u0026hellip;,x_n$。\n$x_1$为最左侧空格子数，$x_n$为最右侧空格子数，其余$x_i$为第$i$个人和第$i-1$个人之间的空位。\n让第i个人往左相当于$x_i += x_{i-1}, x_{i-1} = 0$，往右相当于$x_{i-1} += x_i, x_i = 0$。\n\r 引自：标准题解\n初状态和终状态，因为数的个数一样，所以总区间长度和肯定一样。\n那么要使最初状态转换为最终状态，则从左向右遍历，一定能使终状态某区间，变为由初状态中若干个区间合并。\n又由于碰到相邻的停下，使得只能相邻区间合并。\n故若若干个区间合并后，长度超过却不能等于，则这个区间一定不能达成，证明不能移动得到，输出-1。\n故从左到右遍历，碰到存在长度的终状态区间，就开始寻找从初状态未被合并过的区间找若干个存在长度的区间尝试合并。\n若成功合并，则移动次数就是左侧合并了多少个区间加上右边合并了多少个区间。\n公式为：$ans += max(i-l,0) + max(r-i,0)$。\n 这里用个$max(\\cdots,0)$，是因为存在减为负数的情况。【可以参见标程代码中的例子】  标程代码 Pastebin链接\n\r 标程代码（附个人注释）\r#include \u0026lt;bits/stdc++.h\u0026gt;using namespace std; typedef long long LL; const int N = 100005; int n, m, a[N + 9], b[N + 9]; LL ans; void Get_ans() { ++n; a[n] = b[n] = m + 1; //技巧1：最右侧加个墙壁，方便计算最右侧区间长度。  for (int i = n; i \u0026gt;= 1; --i) //把始末状态转换为区间长度，其中a[i]=i-1~i的距离  a[i] -= a[i - 1] + 1, b[i] -= b[i - 1] + 1; for (int i = 1, j = 1; i \u0026lt;= n; ++i) { if (!b[i]) //从左向右，一直找到终状态存在长度（需要合并操作）的区间。  continue; for (; !a[j]; ++j); //从初状态中未合并过的区间开始向右找，找到存在长度（可以合并）的区间。  int sum = 0, l = j; //l记录左边开始进行合并的位置。  for (; j \u0026lt;= n \u0026amp;\u0026amp; sum \u0026lt; b[i]; ++j) //尝试进行b[i]=a[l]+a[l+1]+...+a[r-1]+a[r]这个操作  sum += a[j]; if (sum ^ b[i]) //如果无法把b[i]这个区间由若干个a[i]区间拼合而成，则不满足，输出-1  { ans = -1; return; } ans += max(i - l, 0) + max(j - 1 - i, 0); //ans加上：完成这个区间合并操作所要操作的节点个数（左侧和右侧）。【要合并1——3区间，只需要移动2个节点，即3-1=2……  /* 变量解释： i为当前要合并的区间 l为操作到最左边的区间 j为操作到最右边的区间(由于for的原因，这里j比实际的r多了1) 【这里非常巧妙的是：正因为j比实际的r多1，导致下次查找的时候j会跳过之前已找过的区间，不会重复合并。 */ /* 是否需要max： 是需要的。存在减为负数的情况。 如： \u0026gt; 1 2 3 4 5 \u0026gt; 6 7 8 9 10 a（开始状态）数组为: 0、0、0、0、0、5 b（结束状态）数组为: 5、0、0、0、0、0 那么i=1、l=6、j=7 */ } } int main() { scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); for (int i = 1; i \u0026lt;= n; ++i) scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i]); Get_ans(); printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } \r ","date":"2020-10-24T00:00:00Z","image":"https://blog.supersassw.com/p/acm-writeup-2020_10_24/85632010_p0_hu1a4360dbf172a18f1159639719209d07_2635798_120x120_fill_box_smart1_2.png","permalink":"https://blog.supersassw.com/p/acm-writeup-2020_10_24/","title":"ACM比赛总结——2020年 校十月月赛（初赛）"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://blog.supersassw.com/p/","title":""}]